This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-15T08:09:07.834Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
app.controller.spec.ts
app.controller.ts
app.module.ts
app.service.ts
auth/auth.controller.ts
auth/auth.module.ts
auth/auth.service.ts
auth/client-auth.controller.ts
auth/client-auth.service.ts
auth/decorators/client-roles.decorator.ts
auth/decorators/current-user.decorator.ts
auth/decorators/roles.decorator.ts
auth/dto/login.dto.ts
auth/dto/login.ts
auth/dto/register.dto.ts
auth/dto/register.ts
auth/dto/update-user.dto.ts
auth/dto/update-user.ts
auth/guards/client-auth.guard.ts
auth/guards/client-roles.guard.ts
auth/guards/jwt-auth.guard.ts
auth/guards/organization-auth.guard.ts
auth/guards/organization-jwt.guard.ts
auth/guards/roles.guard.ts
auth/guards/system-auth.guard.ts
auth/strategies/client-jwt.strategy.ts
auth/strategies/jwt.strategy.ts
auth/strategies/system-jwt.strategy.ts
auth/system-auth.controller.ts
auth/system-auth.service.ts
client-users/client-users.controller.ts
client-users/client-users.module.ts
client-users/client-users.service.ts
client-users/dto/create-client-user.dto.ts
client-users/dto/update-client-user.dto.ts
common/enums/client-role.enum.ts
common/enums/organization-role.enum.ts
common/enums/system-role.enum.ts
common/pipes/zod-validation.pipe.ts
domain/rmf/catalog.controller.ts
domain/rmf/catalog.module.ts
domain/rmf/catalog.service.ts
domain/rmf/dto/catalog.dto.ts
domain/rmf/dto/control-link.dto.ts
domain/rmf/guards/catalog-auth.guard.ts
entities/approval.entity.ts
entities/artifact-revision.entity.ts
entities/artifact.entity.ts
entities/asset.entity.ts
entities/ato-package.entity.ts
entities/audit-log.entity.ts
entities/base.entity.ts
entities/catalog.entity.ts
entities/client-user.entity.ts
entities/continuity-plan.entity.ts
entities/control-artifact.entity.ts
entities/control-assessment.entity.ts
entities/control-link.entity.ts
entities/control.entity.ts
entities/document.entity.ts
entities/group.entity.ts
entities/incident.entity.ts
entities/mitigation-priority.entity.ts
entities/organization-audit-log.entity.ts
entities/organization.entity.ts
entities/parameter.entity.ts
entities/part.entity.ts
entities/poam.entity.ts
entities/port-mapping.entity.ts
entities/quantitative-risk.entity.ts
entities/risk-matrix-entry.entity.ts
entities/risk-profile.entity.ts
entities/service-provider-client.entity.ts
entities/system-user.entity.ts
entities/system.entity.ts
entities/user-organization.entity.ts
enums/artifact.enum.ts
enums/ato.enum.ts
enums/incident.enum.ts
enums/organization.enum.ts
enums/risk.enum.ts
enums/system.enum.ts
main.ts
migrations/.snapshot-securecenter_v1.json
migrations/backup/Migration20241211202532.ts
migrations/backup/Migration20241212053500.ts
migrations/backup/Migration20241212063915.ts
migrations/backup/Migration20241212175619.ts
migrations/backup/Migration20241212180400.ts
migrations/backup/Migration20241212183455.ts
migrations/backup/Migration20241212183500.ts
migrations/backup/Migration20241213035500.ts
migrations/backup/Migration20241213171045.ts
migrations/backup/Migration20241214040117.ts
migrations/Migration20241215000000.ts
migrations/Migration20241215000001.ts
migrations/Migration20241215000002.ts
migrations/repomix-output.txt
organizations/audit-logging.service.ts
organizations/dto/create-organization.dto.ts
organizations/dto/update-organization.dto.ts
organizations/organizations.controller.ts
organizations/organizations.module.ts
organizations/organizations.service.ts
risk-profile/dto/update-risk-profile.dto.ts
risk-profile/risk-profile.controller.ts
risk-profile/risk-profile.module.ts
risk-profile/risk-profile.service.ts
seeders/DatabaseSeeder.ts
seeders/OrganizationSeeder.ts
seeders/reset-db.ts
seeders/run-org-seed.ts
seeders/run-seeder.ts
seeders/seed.ts
seeders/SystemUserSeeder.ts
seeders/UserOrganizationSeeder.ts
system-users/dto/create-system-user.dto.ts
system-users/dto/update-system-user.dto.ts
system-users/system-users.controller.ts
system-users/system-users.module.ts
system-users/system-users.service.ts
system-users/types/system-user.types.ts
users/dto/create-user.dto.ts
users/dto/update-user.dto.ts
users/types/user.types.ts
users/users.controller.ts
users/users.module.ts
users/users.service.ts

================================================================
Repository Files
================================================================

================
File: app.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';
describe("AppController", () => {
    let appController: AppController;
    beforeEach(async () => {
        const app: TestingModule = await Test.createTestingModule({
            controllers: [AppController],
            providers: [AppService],
        }).compile();
        appController = app.get<AppController>(AppController);
    });
    describe("root", () => {
        it("should return \"Hello World!\"", () => {
            expect(appController.getHello()).toBe("Hello World!");
        });
    });
});

================
File: app.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';
@Controller()
export class AppController {
    constructor(private readonly appService: AppService) { }
    @Get()
    getHello(): string {
        return this.appService.getHello();
    }
}

================
File: app.module.ts
================
import { Module } from '@nestjs/common';
import { MikroOrmModule } from '@mikro-orm/nestjs';
import { AuthModule } from './auth/auth.module';
import { SystemUsersModule } from './system-users/system-users.module';
import { OrganizationsModule } from './organizations/organizations.module';
import { RiskProfileModule } from './risk-profile/risk-profile.module';
import { ClientUsersModule } from './client-users/client-users.module';
import { CatalogModule } from './domain/rmf/catalog.module';
import mikroOrmConfig from '../mikro-orm.config';

@Module({
    imports: [
        MikroOrmModule.forRoot(mikroOrmConfig),
        AuthModule,
        SystemUsersModule,
        OrganizationsModule,
        RiskProfileModule,
        ClientUsersModule,
        CatalogModule,
    ],
})
export class AppModule {}

================
File: app.service.ts
================
import { Injectable } from '@nestjs/common';
@Injectable()
export class AppService {
    getHello(): string {
        return "Hello World!";
    }
}

================
File: auth/auth.controller.ts
================
import { Controller, Post, Get, Body, UseGuards, Request } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
@Controller("auth")
export class AuthController {
    constructor(private readonly authService: AuthService) { }
    @Post("login")
    async login(
    @Body()
    loginDto: LoginDto) {
        return this.authService.login(loginDto);
    }
    @Post("register/admin")
    async registerAdmin(
    @Body()
    registerDto: RegisterDto) {
        return this.authService.registerAdmin(registerDto);
    }
    @Post("register/client")
    async registerClient(
    @Body()
    registerDto: RegisterDto) {
        return this.authService.registerClient(registerDto);
    }
    @UseGuards(JwtAuthGuard)
    @Get("profile")
    async getProfile(
    @Request()
    req) {
        return this.authService.getProfile(req.user);
    }
}

================
File: auth/auth.module.ts
================
import { Module, Logger, OnModuleInit } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { SystemAuthController } from './system-auth.controller';
import { ClientAuthController } from './client-auth.controller';
import { SystemAuthService } from './system-auth.service';
import { ClientAuthService } from './client-auth.service';
import { SystemJwtStrategy } from './strategies/system-jwt.strategy';
import { ClientJwtStrategy } from './strategies/client-jwt.strategy';
import { OrganizationAuthGuard } from './guards/organization-auth.guard';
import { ClientAuthGuard } from './guards/client-auth.guard';
import { SystemAuthGuard } from './guards/system-auth.guard';
import { ClientRolesGuard } from './guards/client-roles.guard';
import { OrganizationJwtGuard } from './guards/organization-jwt.guard';
import { SystemUsersModule } from '../system-users/system-users.module';
import { ClientUsersModule } from '../client-users/client-users.module';
@Module({
    imports: [
        // Make ConfigModule available globally
        ConfigModule.forRoot({
            isGlobal: true,
        }),
        PassportModule.register({
            defaultStrategy: ["system-jwt", "client-jwt"],
        }),
        JwtModule.registerAsync({
            imports: [ConfigModule],
            useFactory: async (configService: ConfigService) => {
                const secret = configService.get<string>("JWT_SECRET");
                if (!secret) {
                    const error = "JWT_SECRET must be configured";
                    console.error("[AuthModule] Configuration error:", {
                        error,
                        timestamp: new Date().toISOString()
                    });
                    throw new Error(error);
                }
                console.log("[AuthModule] Configuring JWT Module:", {
                    secretConfigured: !!secret,
                    expirationConfigured: !!configService.get<string>("JWT_EXPIRATION"),
                    timestamp: new Date().toISOString()
                });
                return {
                    secret,
                    signOptions: {
                        expiresIn: configService.get<string>("JWT_EXPIRATION") || "1d"
                    },
                };
            },
            inject: [ConfigService],
        }),
        SystemUsersModule,
        ClientUsersModule,
    ],
    controllers: [
        AuthController,
        SystemAuthController,
        ClientAuthController
    ],
    providers: [
        Logger,
        AuthService,
        SystemAuthService,
        ClientAuthService,
        SystemJwtStrategy,
        ClientJwtStrategy,
        OrganizationAuthGuard,
        ClientAuthGuard,
        SystemAuthGuard,
        ClientRolesGuard,
        OrganizationJwtGuard,
        ConfigService,
    ],
    exports: [
        AuthService,
        SystemAuthService,
        ClientAuthService,
        SystemJwtStrategy,
        ClientJwtStrategy,
        OrganizationAuthGuard,
        ClientAuthGuard,
        SystemAuthGuard,
        ClientRolesGuard,
        OrganizationJwtGuard,
    ],
})
export class AuthModule implements OnModuleInit {
    private readonly logger = new Logger("AuthModule");
    constructor(private configService: ConfigService) { }
    onModuleInit() {
        console.log("[AuthModule] Initializing module:", {
            jwtSecret: this.configService.get("JWT_SECRET") ? "Configured" : "Missing",
            jwtExpiration: this.configService.get("JWT_EXPIRATION") || "1d",
            timestamp: new Date().toISOString()
        });
        this.logger.log("Auth module initialized with JWT configuration");
    }
}

================
File: auth/auth.service.ts
================
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { EntityManager } from '@mikro-orm/postgresql';
import * as bcrypt from 'bcrypt';
import { SystemUser } from '../entities/system-user.entity';
import { ClientUser } from '../entities/client-user.entity';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';
import { SystemRole } from '../common/enums/system-role.enum';
import { Organization } from '../entities/organization.entity';
import { UserOrganization } from '../entities/user-organization.entity';
@Injectable()
export class AuthService {
    constructor(private readonly em: EntityManager, private readonly jwtService: JwtService) { }
    async validateSystemUser(email: string, password: string): Promise<SystemUser | null> {
        const user = await this.em.findOne(SystemUser, { email });
        if (user && await bcrypt.compare(password, user.password)) {
            return user;
        }
        return null;
    }
    async validateClientUser(email: string, password: string): Promise<ClientUser | null> {
        const user = await this.em.findOne(ClientUser, { email }, { populate: ["organization"] });
        if (user && await bcrypt.compare(password, user.password)) {
            return user;
        }
        return null;
    }
    async validateAdmin(email: string): Promise<boolean> {
        const user = await this.em.findOne(SystemUser, { email });
        if (!user || ![SystemRole.GLOBAL_ADMIN, SystemRole.ADMIN].includes(user.role)) {
            return false;
        }
        return true;
    }
    async getProfile(user: any) {
        if (user.type === "client") {
            const clientUser = await this.em.findOne(ClientUser, { id: user.id }, { populate: ["organization"] });
            if (!clientUser) {
                throw new UnauthorizedException("User not found");
            }
            return {
                id: clientUser.id,
                email: clientUser.email,
                firstName: clientUser.firstName,
                lastName: clientUser.lastName,
                isActive: clientUser.isActive,
                lastLogin: clientUser.lastLogin,
                type: "client",
                clientRole: clientUser.clientRole,
                organizationRole: clientUser.organizationRole,
                organization: {
                    id: clientUser.organization.id,
                    name: clientUser.organization.name
                }
            };
        }
        else {
            const systemUser = await this.em.findOne(SystemUser, { id: user.id });
            if (!systemUser) {
                throw new UnauthorizedException("User not found");
            }
            return {
                id: systemUser.id,
                email: systemUser.email,
                firstName: systemUser.firstName,
                lastName: systemUser.lastName,
                role: systemUser.role,
                isActive: systemUser.isActive,
                lastLogin: systemUser.lastLogin,
                type: "system"
            };
        }
    }
    async login(loginDto: LoginDto) {
        const systemUser = await this.validateSystemUser(loginDto.email, loginDto.password);
        if (systemUser) {
            if (!systemUser.isActive) {
                throw new UnauthorizedException("User account is inactive");
            }
            const payload = {
                sub: systemUser.id,
                email: systemUser.email,
                role: systemUser.role,
                type: "system"
            };
            // Update last login
            systemUser.lastLogin = new Date();
            await this.em.persistAndFlush(systemUser);
            return {
                access_token: this.jwtService.sign(payload),
                user: {
                    id: systemUser.id,
                    email: systemUser.email,
                    firstName: systemUser.firstName,
                    lastName: systemUser.lastName,
                    role: systemUser.role,
                    isActive: systemUser.isActive,
                    lastLogin: systemUser.lastLogin,
                    type: "system"
                },
            };
        }
        // Try client login if system login fails
        const clientUser = await this.validateClientUser(loginDto.email, loginDto.password);
        if (clientUser) {
            if (!clientUser.isActive) {
                throw new UnauthorizedException("User account is inactive");
            }
            if (!clientUser.organization) {
                throw new UnauthorizedException("User is not associated with any organization");
            }
            // Include essential security information in the token
            const payload = {
                sub: clientUser.id,
                email: clientUser.email,
                type: "client",
                organizationId: clientUser.organization.id,
                clientRole: clientUser.clientRole,
                organizationRole: clientUser.organizationRole
            };
            // Update last login
            clientUser.lastLogin = new Date();
            await this.em.persistAndFlush(clientUser);
            return {
                access_token: this.jwtService.sign(payload),
                user: {
                    id: clientUser.id,
                    email: clientUser.email,
                    firstName: clientUser.firstName,
                    lastName: clientUser.lastName,
                    isActive: clientUser.isActive,
                    lastLogin: clientUser.lastLogin,
                    type: "client",
                    clientRole: clientUser.clientRole,
                    organizationRole: clientUser.organizationRole,
                    organization: {
                        id: clientUser.organization.id,
                        name: clientUser.organization.name
                    }
                },
            };
        }
        throw new UnauthorizedException("Invalid credentials");
    }
    async registerAdmin(registerDto: RegisterDto) {
        const existingUser = await this.em.findOne(SystemUser, { email: registerDto.email });
        if (existingUser) {
            throw new UnauthorizedException("Email already exists");
        }
        const hashedPassword = await bcrypt.hash(registerDto.password, 10);
        const user = new SystemUser();
        user.email = registerDto.email;
        user.password = hashedPassword;
        user.firstName = registerDto.firstName;
        user.lastName = registerDto.lastName;
        user.role = registerDto.role || SystemRole.ADMIN;
        user.isActive = true;
        await this.em.persistAndFlush(user);
        const payload = {
            sub: user.id,
            email: user.email,
            role: user.role,
            type: "system"
        };
        return {
            access_token: this.jwtService.sign(payload),
            user: {
                id: user.id,
                email: user.email,
                firstName: user.firstName,
                lastName: user.lastName,
                role: user.role,
                isActive: user.isActive,
                type: "system"
            },
        };
    }
    async registerClient(registerDto: RegisterDto) {
        const existingUser = await this.em.findOne(ClientUser, { email: registerDto.email });
        if (existingUser) {
            throw new UnauthorizedException("Email already exists");
        }
        const hashedPassword = await bcrypt.hash(registerDto.password, 10);
        const user = new ClientUser();
        user.email = registerDto.email;
        user.password = hashedPassword;
        user.firstName = registerDto.firstName;
        user.lastName = registerDto.lastName;
        user.isActive = true;
        await this.em.persistAndFlush(user);
        if (registerDto.organizationId) {
            const organization = await this.em.findOne(Organization, { id: registerDto.organizationId });
            if (organization) {
                user.organization = organization;
                await this.em.persistAndFlush(user);
            }
        }
        const payload = {
            sub: user.id,
            email: user.email,
            type: "client",
            organizationId: registerDto.organizationId
        };
        return {
            access_token: this.jwtService.sign(payload),
            user: {
                id: user.id,
                email: user.email,
                firstName: user.firstName,
                lastName: user.lastName,
                isActive: user.isActive,
                type: "client",
                organization: registerDto.organizationId ? { id: registerDto.organizationId } : null
            },
        };
    }
}

================
File: auth/client-auth.controller.ts
================
import { Controller, Post, Body, Get, UseGuards, Request, Logger } from '@nestjs/common';
import { ClientAuthService } from './client-auth.service';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
@Controller("auth/client")
export class ClientAuthController {
    private readonly logger = new Logger("ClientAuthController");
    constructor(private readonly clientAuthService: ClientAuthService) { }
    @Post("login")
    async login(
    @Body()
    loginDto: LoginDto) {
        this.logger.log("Login attempt", {
            email: loginDto.email
        });
        const result = await this.clientAuthService.login(loginDto);
        this.logger.log("Login successful", {
            userId: result.user.id,
            organizationId: result.user.organizationId
        });
        return result;
    }
    @Post("register")
    async register(
    @Body()
    registerDto: RegisterDto) {
        this.logger.log("Registration attempt", {
            email: registerDto.email
        });
        const result = await this.clientAuthService.register(registerDto);
        this.logger.log("Registration successful", {
            userId: result.user.id,
            organizationId: result.user.organization?.id
        });
        return result;
    }
    @UseGuards(JwtAuthGuard)
    @Get("profile")
    async getProfile(
    @Request()
    req) {
        this.logger.log("Profile request", {
            userId: req.user.id
        });
        const result = await this.clientAuthService.getProfile(req.user);
        this.logger.log("Profile retrieved", {
            userId: result.id,
            organizationId: result.organization?.id
        });
        return result;
    }
}

================
File: auth/client-auth.service.ts
================
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { EntityManager } from '@mikro-orm/postgresql';
import * as bcrypt from 'bcrypt';
import { ClientUser } from '../entities/client-user.entity';
import { Organization } from '../entities/organization.entity';
import { UserOrganization } from '../entities/user-organization.entity';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';
import { ClientRole } from '../common/enums/client-role.enum';
import { OrganizationRole } from '../common/enums/organization-role.enum';
@Injectable()
export class ClientAuthService {
    constructor(private readonly em: EntityManager, private readonly jwtService: JwtService) { }
    private async validateUser(email: string, password: string): Promise<ClientUser | null> {
        console.log("[ClientAuthService] Validating user:", { email });
        const user = await this.em.findOne(ClientUser, { email }, { populate: ["organization"] });
        if (user && await bcrypt.compare(password, user.password)) {
            console.log("[ClientAuthService] User validated successfully:", {
                userId: user.id,
                organizationId: user.organization?.id
            });
            return user;
        }
        console.log("[ClientAuthService] User validation failed");
        return null;
    }
    async getProfile(user: any) {
        console.log("[ClientAuthService] Getting profile for user:", { userId: user.id });
        const clientUser = await this.em.findOne(ClientUser, { id: user.id }, { populate: ["organization"] });
        if (!clientUser) {
            console.error("[ClientAuthService] User not found:", { userId: user.id });
            throw new UnauthorizedException("User not found");
        }
        console.log("[ClientAuthService] Profile retrieved successfully:", {
            userId: clientUser.id,
            organizationId: clientUser.organization?.id
        });
        return {
            id: clientUser.id,
            email: clientUser.email,
            firstName: clientUser.firstName,
            lastName: clientUser.lastName,
            isActive: clientUser.isActive,
            lastLogin: clientUser.lastLogin,
            type: "client",
            clientRole: clientUser.clientRole,
            organizationRole: clientUser.organizationRole,
            organization: clientUser.organization ? {
                id: clientUser.organization.id,
                name: clientUser.organization.name
            } : null
        };
    }
    async login(loginDto: LoginDto) {
        console.log("[ClientAuthService] Login attempt:", { email: loginDto.email });
        // Fork EntityManager for transaction
        const em = this.em.fork();
        try {
            // Begin transaction
            await em.begin();
            const user = await this.validateUser(loginDto.email, loginDto.password);
            if (!user) {
                console.error("[ClientAuthService] Invalid credentials:", { email: loginDto.email });
                throw new UnauthorizedException("Invalid credentials");
            }
            if (!user.isActive) {
                console.error("[ClientAuthService] Inactive user attempted login:", {
                    userId: user.id,
                    email: user.email
                });
                throw new UnauthorizedException("User account is inactive");
            }
            if (!user.organization) {
                console.error("[ClientAuthService] User has no organization:", {
                    userId: user.id,
                    email: user.email
                });
                throw new UnauthorizedException("User is not associated with any organization");
            }
            // Check if UserOrganization relationship exists
            const userOrg = await em.findOne(UserOrganization, {
                clientUser: user,
                organization: user.organization
            });
            // Create UserOrganization relationship if it doesn't exist
            if (!userOrg) {
                console.log("[ClientAuthService] Creating missing UserOrganization relationship:", {
                    userId: user.id,
                    organizationId: user.organization.id
                });
                const newUserOrg = new UserOrganization();
                newUserOrg.clientUser = user;
                newUserOrg.organization = user.organization;
                newUserOrg.isActive = true;
                await em.persist(newUserOrg);
            }
            // Include essential security information in the token
            const payload = {
                sub: user.id,
                email: user.email,
                type: "client",
                organizationId: user.organization.id,
                clientRole: user.clientRole,
                organizationRole: user.organizationRole
            };
            // Update last login
            user.lastLogin = new Date();
            await em.persist(user);
            // Commit transaction
            await em.flush();
            await em.commit();
            console.log("[ClientAuthService] Login successful:", {
                userId: user.id,
                organizationId: user.organization.id
            });
            return {
                access_token: this.jwtService.sign(payload),
                user: {
                    id: user.id,
                    email: user.email,
                    firstName: user.firstName,
                    lastName: user.lastName,
                    isActive: user.isActive,
                    lastLogin: user.lastLogin,
                    type: "client",
                    clientRole: user.clientRole,
                    organizationRole: user.organizationRole,
                    organizationId: user.organization.id,
                    organization: {
                        id: user.organization.id,
                        name: user.organization.name
                    }
                },
            };
        }
        catch (error) {
            console.error("[ClientAuthService] Login failed:", error);
            await em.rollback();
            throw error;
        }
    }
    async register(registerDto: RegisterDto) {
        console.log("[ClientAuthService] Registration attempt:", {
            email: registerDto.email,
            organizationId: registerDto.organizationId
        });
        // Fork EntityManager for transaction
        const em = this.em.fork();
        try {
            // Begin transaction
            await em.begin();
            const existingUser = await em.findOne(ClientUser, { email: registerDto.email });
            if (existingUser) {
                console.error("[ClientAuthService] Email already exists:", { email: registerDto.email });
                throw new UnauthorizedException("Email already exists");
            }
            const hashedPassword = await bcrypt.hash(registerDto.password, 10);
            const user = new ClientUser();
            user.email = registerDto.email;
            user.password = hashedPassword;
            user.firstName = registerDto.firstName;
            user.lastName = registerDto.lastName;
            user.isActive = true;
            // Set default roles for new client users
            user.clientRole = ClientRole.USER;
            user.organizationRole = null;
            await em.persist(user);
            let organization: Organization | null = null;
            if (registerDto.organizationId) {
                organization = await em.findOne(Organization, { id: registerDto.organizationId });
                if (organization) {
                    // Set organization on user
                    user.organization = organization;
                    await em.persist(user);
                    // Create UserOrganization relationship
                    const userOrg = new UserOrganization();
                    userOrg.clientUser = user;
                    userOrg.organization = organization;
                    userOrg.isActive = true;
                    await em.persist(userOrg);
                }
            }
            // Commit transaction
            await em.flush();
            await em.commit();
            const payload = {
                sub: user.id,
                email: user.email,
                type: "client",
                organizationId: organization?.id,
                clientRole: user.clientRole,
                organizationRole: user.organizationRole
            };
            console.log("[ClientAuthService] Registration successful:", {
                userId: user.id,
                organizationId: organization?.id
            });
            return {
                access_token: this.jwtService.sign(payload),
                user: {
                    id: user.id,
                    email: user.email,
                    firstName: user.firstName,
                    lastName: user.lastName,
                    isActive: user.isActive,
                    type: "client",
                    clientRole: user.clientRole,
                    organizationRole: user.organizationRole,
                    organization: organization ? {
                        id: organization.id,
                        name: organization.name
                    } : null
                },
            };
        }
        catch (error) {
            console.error("[ClientAuthService] Registration failed:", error);
            await em.rollback();
            throw error;
        }
    }
}

================
File: auth/decorators/client-roles.decorator.ts
================
import { SetMetadata } from '@nestjs/common';
import { ClientRole } from '../../common/enums/client-role.enum';
export const CLIENT_ROLES_KEY = "clientRoles";
export const ClientRoles = (...roles: ClientRole[]) => SetMetadata(CLIENT_ROLES_KEY, roles);
// Helper function to check if a role has specific permissions
export function hasPermission(userRole: ClientRole, requiredRole: ClientRole): boolean {
    // Role hierarchy from highest to lowest
    const roleHierarchy = [
        ClientRole.ADMIN, // Full control
        ClientRole.MANAGER, // Can edit org but not users
        ClientRole.PM, // View only all
        ClientRole.USER // View only specific
    ];
    const userRoleIndex = roleHierarchy.indexOf(userRole);
    const requiredRoleIndex = roleHierarchy.indexOf(requiredRole);
    // Lower index means higher permission level
    return userRoleIndex <= requiredRoleIndex;
}
// Example usage:
// @ClientRoles(ClientRole.ADMIN)                    // Only ADMIN
// @ClientRoles(ClientRole.ADMIN, ClientRole.MANAGER) // ADMIN or MANAGER
// @ClientRoles(ClientRole.PM)                       // ADMIN, MANAGER, or PM can access

================
File: auth/decorators/current-user.decorator.ts
================
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
export const CurrentUser = createParamDecorator((data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;
});

================
File: auth/decorators/roles.decorator.ts
================
import { SetMetadata } from '@nestjs/common';
import { SystemRole } from '../../common/enums/system-role.enum';
export const ROLES_KEY = "roles";
export const Roles = (...roles: SystemRole[]) => SetMetadata(ROLES_KEY, roles);

================
File: auth/dto/login.dto.ts
================
import { IsEmail, IsString } from 'class-validator';
export class LoginDto {
    @IsEmail()
    email!: string;
    @IsString()
    password!: string;
}

================
File: auth/dto/login.ts
================
import { IsEmail, IsString, MinLength } from 'class-validator';
export class LoginDto {
    @IsEmail()
    email: string;
    @IsString()
    @MinLength(6)
    password: string;
}

================
File: auth/dto/register.dto.ts
================
import { IsEmail, IsString, IsOptional, IsEnum, IsUUID } from 'class-validator';
import { SystemRole } from '../../common/enums/system-role.enum';
export class RegisterDto {
    @IsEmail()
    email!: string;
    @IsString()
    password!: string;
    @IsString()
    firstName!: string;
    @IsString()
    lastName!: string;
    @IsEnum(SystemRole)
    @IsOptional()
    role?: SystemRole;
    @IsUUID()
    @IsOptional()
    organizationId?: string;
}

================
File: auth/dto/register.ts
================
import { IsEmail, IsString, MinLength } from 'class-validator';
export class RegisterDto {
    @IsEmail()
    email: string;
    @IsString()
    @MinLength(6)
    password: string;
    @IsString()
    name: string;
}

================
File: auth/dto/update-user.dto.ts
================
import { IsEmail, IsString, MinLength, IsEnum, IsOptional } from 'class-validator';
import { SystemRole } from '../../common/enums/system-role.enum';
export class UpdateUserDto {
    @IsOptional()
    @IsEmail()
    email?: string;
    @IsOptional()
    @IsString()
    @MinLength(8)
    password?: string;
    @IsOptional()
    @IsString()
    name?: string;
    @IsOptional()
    @IsEnum(SystemRole)
    systemRole?: SystemRole;
}

================
File: auth/dto/update-user.ts
================
import { IsEmail, IsString, IsOptional } from 'class-validator';
export class UpdateUserDto {
    @IsEmail()
    @IsOptional()
    email?: string;
    @IsString()
    @IsOptional()
    name?: string;
    @IsOptional()
    isActive?: boolean;
}

================
File: auth/guards/client-auth.guard.ts
================
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
@Injectable()
export class ClientAuthGuard extends AuthGuard("client-jwt") {
}

================
File: auth/guards/client-roles.guard.ts
================
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ClientRole } from '../../common/enums/client-role.enum';
@Injectable()
export class ClientRolesGuard implements CanActivate {
    constructor(private reflector: Reflector) { }
    canActivate(context: ExecutionContext): boolean {
        const requiredRoles = this.reflector.get<ClientRole[]>("clientRoles", context.getHandler());
        if (!requiredRoles) {
            return true; // No roles required
        }
        const { user } = context.switchToHttp().getRequest();
        if (!user) {
            return false; // No user
        }
        // Allow system users through - they are handled by the RolesGuard
        if (user.type === "system") {
            return true;
        }
        // Handle client users
        if (user.type === "client") {
            // ADMIN role has full access
            if (user.clientRole === ClientRole.ADMIN) {
                return true;
            }
            // MANAGER can do everything except user management
            if (user.clientRole === ClientRole.MANAGER) {
                // Allow all operations except those requiring ADMIN
                return !requiredRoles.includes(ClientRole.ADMIN);
            }
            // PM and USER are view-only
            if (user.clientRole === ClientRole.PM || user.clientRole === ClientRole.USER) {
                // Only allow if the endpoint doesn't require ADMIN or MANAGER roles
                return !requiredRoles.some(role => [ClientRole.ADMIN, ClientRole.MANAGER].includes(role));
            }
        }
        return false;
    }
}

================
File: auth/guards/jwt-auth.guard.ts
================
import { Injectable, ExecutionContext, UnauthorizedException, Logger } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
@Injectable()
export class JwtAuthGuard extends AuthGuard(["system-jwt", "client-jwt"]) {
    private readonly logger = new Logger("JwtAuthGuard");
    canActivate(context: ExecutionContext) {
        const request = context.switchToHttp().getRequest();
        const route = `${request.method} ${request.url}`;
        console.log("[JwtAuthGuard] Authenticating request:", {
            route,
            headers: request.headers,
            timestamp: new Date().toISOString()
        });
        this.logger.debug(`JWT auth check for route: ${route}`);
        return super.canActivate(context);
    }
    handleRequest(err: any, user: any, info: any) {
        // Log authentication attempt details
        console.log("[JwtAuthGuard] Authentication attempt:", {
            success: !err && !!user,
            error: err?.message,
            info: info?.message,
            user: user ? {
                id: user.id,
                email: user.email,
                type: user.type,
                timestamp: new Date().toISOString()
            } : null
        });
        if (err || !user) {
            const errorMessage = err?.message || "User not found";
            console.log("[JwtAuthGuard] Authentication failed:", {
                error: errorMessage,
                stack: err?.stack,
                timestamp: new Date().toISOString()
            });
            this.logger.warn(`Authentication failed: ${errorMessage}`);
            throw err || new UnauthorizedException("Authentication required");
        }
        console.log("[JwtAuthGuard] Authentication successful:", {
            userId: user.id,
            userType: user.type,
            userEmail: user.email,
            timestamp: new Date().toISOString()
        });
        this.logger.log(`User authenticated successfully: ${user.email} (${user.type})`);
        return user;
    }
}

================
File: auth/guards/organization-auth.guard.ts
================
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException, Logger } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { CLIENT_ROLES_KEY } from '../decorators/client-roles.decorator';
@Injectable()
export class OrganizationAuthGuard implements CanActivate {
    private readonly logger = new Logger("OrganizationAuthGuard");
    constructor(private reflector: Reflector) { }
    canActivate(context: ExecutionContext): boolean {
        const request = context.switchToHttp().getRequest();
        const user = request.user;
        const params = request.params;
        this.logger.debug(`Auth check for route: ${request.method} ${request.url}`);
        this.logger.debug(`User attempting access: ${JSON.stringify({
            id: user?.id,
            type: user?.type,
            organizationId: user?.organizationId,
            clientRole: user?.clientRole,
            organizationRole: user?.organizationRole
        })}`);
        // System users can access all organizations
        if (user?.type === "system") {
            this.logger.log(`System user ${user.id} granted access to organization ${params.organizationId}`);
            return true;
        }
        // If no user or not a client user, deny access
        if (!user || user.type !== "client") {
            this.logger.warn(`Access denied - Invalid or missing user credentials`);
            throw new UnauthorizedException("Access denied");
        }
        // If organizationId from params doesn't match user's organization, deny access
        if (params.organizationId && params.organizationId !== user.organizationId) {
            this.logger.warn(`Access denied - User ${user.id} attempted to access organization ${params.organizationId} but belongs to ${user.organizationId}`);
            throw new UnauthorizedException("Access denied - Invalid organization");
        }
        // Check if user has required client role if specified
        const requiredRoles = this.reflector.get<string[]>(CLIENT_ROLES_KEY, context.getHandler());
        if (requiredRoles) {
            const hasRole = requiredRoles.some(role => role === user.clientRole || role === user.organizationRole);
            if (!hasRole) {
                this.logger.warn(`Access denied - User ${user.id} with roles [${user.clientRole}, ${user.organizationRole}] attempted to access route requiring roles [${requiredRoles.join(", ")}]`);
                throw new UnauthorizedException("Access denied - Insufficient permissions");
            }
            this.logger.log(`Role check passed for user ${user.id} with roles [${user.clientRole}, ${user.organizationRole}]`);
        }
        this.logger.log(`Access granted for user ${user.id} to organization ${params.organizationId}`);
        return true;
    }
}

================
File: auth/guards/organization-jwt.guard.ts
================
import { Injectable, ExecutionContext, UnauthorizedException, Logger } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
@Injectable()
export class OrganizationJwtGuard extends AuthGuard(["client-jwt", "system-jwt"]) {
    private readonly logger = new Logger("OrganizationJwtGuard");
    canActivate(context: ExecutionContext) {
        const request = context.switchToHttp().getRequest();
        const route = `${request.method} ${request.url}`;
        console.log("[OrganizationJwtGuard] Authenticating request:", {
            route,
            headers: request.headers,
            timestamp: new Date().toISOString()
        });
        this.logger.debug(`JWT auth check for route: ${route}`);
        return super.canActivate(context);
    }
    handleRequest(err: any, user: any, info: any) {
        // Log authentication attempt details
        console.log("[OrganizationJwtGuard] Authentication attempt:", {
            success: !err && !!user,
            error: err?.message,
            info: info?.message,
            user: user ? {
                id: user.id,
                email: user.email,
                type: user.type,
                organizationId: user.organizationId,
                timestamp: new Date().toISOString()
            } : null
        });
        if (err || !user) {
            const errorMessage = err?.message || "User not found";
            console.log("[OrganizationJwtGuard] Authentication failed:", {
                error: errorMessage,
                stack: err?.stack,
                timestamp: new Date().toISOString()
            });
            this.logger.warn(`Authentication failed: ${errorMessage}`);
            throw err || new UnauthorizedException("Authentication required");
        }
        // Allow system users through without requiring organizationId
        if (user.type === "system") {
            console.log("[OrganizationJwtGuard] System user authenticated:", {
                userId: user.id,
                userEmail: user.email,
                role: user.role,
                timestamp: new Date().toISOString()
            });
            this.logger.log(`System user authenticated: ${user.email} (${user.role})`);
            return user;
        }
        // Ensure organizationId is present for client users
        if (!user.organizationId) {
            const error = "Organization ID not found in token";
            console.log("[OrganizationJwtGuard] Authentication failed:", {
                error,
                userId: user.id,
                userType: user.type,
                timestamp: new Date().toISOString()
            });
            this.logger.warn(error);
            throw new UnauthorizedException(error);
        }
        console.log("[OrganizationJwtGuard] Authentication successful:", {
            userId: user.id,
            userType: user.type,
            userEmail: user.email,
            organizationId: user.organizationId,
            timestamp: new Date().toISOString()
        });
        this.logger.log(`User authenticated successfully: ${user.email} (${user.type})`);
        return user;
    }
}

================
File: auth/guards/roles.guard.ts
================
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { SystemRole } from '../../common/enums/system-role.enum';
import { ROLES_KEY } from '../decorators/roles.decorator';
@Injectable()
export class RolesGuard implements CanActivate {
    constructor(private reflector: Reflector) { }
    canActivate(context: ExecutionContext): boolean {
        const requiredRoles = this.reflector.getAllAndOverride<SystemRole[]>(ROLES_KEY, [
            context.getHandler(),
            context.getClass(),
        ]);
        if (!requiredRoles) {
            return true;
        }
        const { user } = context.switchToHttp().getRequest();
        return requiredRoles.some((role) => user?.role === role);
    }
}

================
File: auth/guards/system-auth.guard.ts
================
import { Injectable, ExecutionContext, UnauthorizedException, Logger } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
@Injectable()
export class SystemAuthGuard extends AuthGuard("system-jwt") {
    private readonly logger = new Logger("SystemAuthGuard");
    canActivate(context: ExecutionContext) {
        const request = context.switchToHttp().getRequest();
        this.logger.debug(`System auth check for route: ${request.method} ${request.url}`);
        return super.canActivate(context);
    }
    handleRequest(err: any, user: any, info: any) {
        if (err || !user) {
            this.logger.warn(`System authentication failed: ${err?.message || "User not found"}`);
            throw err || new UnauthorizedException("System authentication required");
        }
        if (user.type !== "system") {
            this.logger.warn(`Invalid user type attempting system access: ${user.type}`);
            throw new UnauthorizedException("System access denied");
        }
        this.logger.log(`System user authenticated successfully: ${user.email}`);
        return user;
    }
}

================
File: auth/strategies/client-jwt.strategy.ts
================
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, Logger, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
@Injectable()
export class ClientJwtStrategy extends PassportStrategy(Strategy, "client-jwt") {
    private readonly logger = new Logger("ClientJwtStrategy");
    constructor(private configService: ConfigService) {
        const jwtSecret = configService.get<string>("JWT_SECRET");
        if (!jwtSecret) {
            const error = "JWT_SECRET is not configured";
            console.error("[ClientJwtStrategy] Configuration error:", {
                error,
                timestamp: new Date().toISOString()
            });
            throw new Error(error);
        }
        console.log("[ClientJwtStrategy] Initializing with configuration:", {
            jwtFromRequest: "Bearer token from Authorization header",
            ignoreExpiration: false,
            secretConfigured: !!jwtSecret,
            timestamp: new Date().toISOString()
        });
        super({
            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
            ignoreExpiration: false,
            secretOrKey: jwtSecret,
        });
    }
    async validate(payload: any) {
        console.log("[ClientJwtStrategy] Validating JWT payload:", {
            sub: payload.sub,
            email: payload.email,
            type: payload.type,
            organizationId: payload.organizationId,
            timestamp: new Date().toISOString()
        });
        // Only process client user tokens
        if (payload.type !== "client") {
            const error = `Invalid token type: ${payload.type}`;
            console.warn("[ClientJwtStrategy] Validation failed:", {
                error,
                payload: {
                    sub: payload.sub,
                    type: payload.type,
                },
                timestamp: new Date().toISOString()
            });
            this.logger.warn(error);
            return null;
        }
        if (!payload.organizationId) {
            const error = "Token missing organizationId";
            console.warn("[ClientJwtStrategy] Validation failed:", {
                error,
                payload: {
                    sub: payload.sub,
                    type: payload.type,
                },
                timestamp: new Date().toISOString()
            });
            this.logger.warn(error);
            throw new UnauthorizedException("Invalid token structure");
        }
        const user = {
            id: payload.sub,
            email: payload.email,
            type: payload.type,
            organizationId: payload.organizationId,
            clientRole: payload.clientRole,
            organizationRole: payload.organizationRole
        };
        console.log("[ClientJwtStrategy] Successfully validated client user:", {
            userId: user.id,
            email: user.email,
            organizationId: user.organizationId,
            roles: {
                client: user.clientRole,
                organization: user.organizationRole
            },
            timestamp: new Date().toISOString()
        });
        this.logger.log(`Successfully validated client user: ${user.email}`);
        return user;
    }
}

================
File: auth/strategies/jwt.strategy.ts
================
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { SystemUsersService } from '../../system-users/system-users.service';
import { EntityManager } from '@mikro-orm/postgresql';
import { ClientUser } from '../../entities/client-user.entity';
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
    constructor(private readonly systemUsersService: SystemUsersService, private readonly em: EntityManager) {
        super({
            jwtFromRequest: (req) => {
                const token = ExtractJwt.fromAuthHeaderAsBearerToken()(req);
                console.log("Extracted Authorization header:", req.headers.authorization);
                console.log("Extracted token:", token);
                return token;
            },
            ignoreExpiration: false,
            secretOrKey: process.env.JWT_SECRET || "your-secret-key",
        });
    }
    async validate(payload: any) {
        // Handle client users
        console.log("JWT Payload:", payload);
        console.log("Validating JWT payload:", payload);
        if (payload.type === "client") {
            const user = await this.em.findOne(ClientUser, { id: payload.sub });
            if (!user) {
                throw new UnauthorizedException("User not found");
            }
            if (!user.isActive) {
                throw new UnauthorizedException("User is inactive");
            }
            return {
                id: user.id,
                email: user.email,
                firstName: user.firstName,
                lastName: user.lastName,
                isActive: user.isActive,
                type: "client"
            };
        }
        // Handle system users
        const user = await this.systemUsersService.findOne(payload.sub);
        if (!user) {
            throw new UnauthorizedException("User not found");
        }
        if (!user.isActive) {
            throw new UnauthorizedException("User is inactive");
        }
        // Verify that the user's role matches the one in the token
        if (user.role !== payload.role) {
            throw new UnauthorizedException("Invalid user role");
        }
        return {
            id: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            role: user.role,
            isActive: user.isActive,
            type: "system"
        };
    }
}

================
File: auth/strategies/system-jwt.strategy.ts
================
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, Logger, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
@Injectable()
export class SystemJwtStrategy extends PassportStrategy(Strategy, "system-jwt") {
    private readonly logger = new Logger("SystemJwtStrategy");
    constructor(private configService: ConfigService) {
        const jwtSecret = configService.get<string>("JWT_SECRET");
        if (!jwtSecret) {
            const error = "JWT_SECRET is not configured";
            console.error("[SystemJwtStrategy] Configuration error:", {
                error,
                timestamp: new Date().toISOString()
            });
            throw new Error(error);
        }
        console.log("[SystemJwtStrategy] Initializing with configuration:", {
            jwtFromRequest: "Bearer token from Authorization header",
            ignoreExpiration: false,
            secretConfigured: !!jwtSecret,
            timestamp: new Date().toISOString()
        });
        super({
            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
            ignoreExpiration: false,
            secretOrKey: jwtSecret,
        });
    }
    async validate(payload: any) {
        console.log("[SystemJwtStrategy] Validating JWT payload:", {
            sub: payload.sub,
            email: payload.email,
            type: payload.type,
            role: payload.role,
            timestamp: new Date().toISOString()
        });
        // Only process system user tokens
        if (payload.type !== "system") {
            const error = `Invalid token type: ${payload.type}`;
            console.warn("[SystemJwtStrategy] Validation failed:", {
                error,
                payload: {
                    sub: payload.sub,
                    type: payload.type,
                },
                timestamp: new Date().toISOString()
            });
            this.logger.warn(error);
            return null;
        }
        if (!payload.role) {
            const error = "Token missing system role";
            console.warn("[SystemJwtStrategy] Validation failed:", {
                error,
                payload: {
                    sub: payload.sub,
                    type: payload.type,
                },
                timestamp: new Date().toISOString()
            });
            this.logger.warn(error);
            throw new UnauthorizedException("Invalid token structure");
        }
        const user = {
            id: payload.sub,
            email: payload.email,
            type: payload.type,
            role: payload.role
        };
        console.log("[SystemJwtStrategy] Successfully validated system user:", {
            userId: user.id,
            email: user.email,
            role: user.role,
            timestamp: new Date().toISOString()
        });
        this.logger.log(`Successfully validated system user: ${user.email} with role ${user.role}`);
        return user;
    }
}

================
File: auth/system-auth.controller.ts
================
import { Controller, Post, Body, UseGuards } from '@nestjs/common';
import { SystemAuthService } from './system-auth.service';
import { LoginDto } from './dto/login.dto';
import { CreateSystemUserDto } from '../system-users/dto/create-system-user.dto';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
import { RolesGuard } from './guards/roles.guard';
import { Roles } from './decorators/roles.decorator';
import { SystemRole } from '../common/enums/system-role.enum';
@Controller("auth/system")
export class SystemAuthController {
    constructor(private readonly systemAuthService: SystemAuthService) { }
    @Post("login")
    async login(
    @Body()
    loginDto: LoginDto) {
        return this.systemAuthService.login(loginDto);
    }
    @Post("register")
    @UseGuards(JwtAuthGuard, RolesGuard)
    @Roles(SystemRole.GLOBAL_ADMIN)
    async register(
    @Body()
    createSystemUserDto: CreateSystemUserDto) {
        return this.systemAuthService.register(createSystemUserDto);
    }
}

================
File: auth/system-auth.service.ts
================
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { SystemUsersService } from '../system-users/system-users.service';
import { LoginDto } from './dto/login.dto';
import { CreateSystemUserDto } from '../system-users/dto/create-system-user.dto';
import { SystemRole } from '../common/enums/system-role.enum';
import { SystemUserLoginResponse } from '../system-users/types/system-user.types';
@Injectable()
export class SystemAuthService {
    constructor(private readonly systemUsersService: SystemUsersService, private readonly jwtService: JwtService) { }
    async validateSystemUser(email: string, password: string) {
        const user = await this.systemUsersService.validateCredentials(email, password);
        if (!user) {
            return null;
        }
        // Ensure the user is a system user (GLOBAL_ADMIN or ADMIN)
        if (![SystemRole.GLOBAL_ADMIN, SystemRole.ADMIN].includes(user.role)) {
            return null;
        }
        return user;
    }
    async login(loginDto: LoginDto): Promise<SystemUserLoginResponse> {
        const user = await this.validateSystemUser(loginDto.email, loginDto.password);
        if (!user) {
            throw new UnauthorizedException("Invalid credentials");
        }
        if (!user.isActive) {
            throw new UnauthorizedException("User account is inactive");
        }
        const payload = {
            sub: user.id,
            email: user.email,
            role: user.role,
            type: "system"
        };
        // Update last login
        await this.systemUsersService.updateLastLogin(user.id);
        // Get complete user data including organizations
        const userData = await this.systemUsersService.findOne(user.id);
        if (!userData) {
            throw new UnauthorizedException("User data not found");
        }
        return {
            access_token: this.jwtService.sign(payload),
            user: userData,
        };
    }
    async register(createDto: CreateSystemUserDto): Promise<SystemUserLoginResponse> {
        const user = await this.systemUsersService.create(createDto);
        const payload = {
            sub: user.id,
            email: user.email,
            role: user.role,
            type: "system"
        };
        return {
            access_token: this.jwtService.sign(payload),
            user: user,
        };
    }
}

================
File: client-users/client-users.controller.ts
================
import { Controller, Get, Post, Body, Param, UseGuards, Put, Delete, Logger } from '@nestjs/common';
import { ClientUsersService } from './client-users.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { OrganizationAuthGuard } from '../auth/guards/organization-auth.guard';
import { ClientRoles } from '../auth/decorators/client-roles.decorator';
import { ClientRole } from '../common/enums/client-role.enum';
import { CreateClientUserDto } from './dto/create-client-user.dto';
import { UpdateClientUserDto } from './dto/update-client-user.dto';
@Controller("organizations/:organizationId/client-users")
export class ClientUsersController {
    private readonly logger = new Logger("ClientUsersController");
    constructor(private readonly clientUsersService: ClientUsersService) { }
    @Get()
    @UseGuards(JwtAuthGuard, OrganizationAuthGuard)
    async findAll(
    @Param("organizationId")
    organizationId: string) {
        console.log("[ClientUsersController] Finding all client users:", {
            organizationId,
            timestamp: new Date().toISOString()
        });
        const result = await this.clientUsersService.findAll(organizationId);
        console.log("[ClientUsersController] Found client users:", {
            organizationId,
            count: result.length,
            timestamp: new Date().toISOString()
        });
        return result;
    }
    @Get(":id")
    @UseGuards(JwtAuthGuard, OrganizationAuthGuard)
    async findOne(
    @Param("organizationId")
    organizationId: string, 
    @Param("id")
    id: string) {
        console.log("[ClientUsersController] Finding client user:", {
            organizationId,
            userId: id,
            timestamp: new Date().toISOString()
        });
        const result = await this.clientUsersService.findOne(organizationId, id);
        console.log("[ClientUsersController] Found client user:", {
            organizationId,
            userId: id,
            found: !!result,
            timestamp: new Date().toISOString()
        });
        return result;
    }
    @Post()
    @UseGuards(JwtAuthGuard, OrganizationAuthGuard)
    @ClientRoles(ClientRole.ADMIN)
    async create(
    @Param("organizationId")
    organizationId: string, 
    @Body()
    createClientUserDto: CreateClientUserDto) {
        console.log("[ClientUsersController] Creating client user:", {
            organizationId,
            userData: { ...createClientUserDto, password: "[REDACTED]" },
            timestamp: new Date().toISOString()
        });
        const result = await this.clientUsersService.create(organizationId, createClientUserDto);
        console.log("[ClientUsersController] Created client user:", {
            organizationId,
            userId: result.id,
            timestamp: new Date().toISOString()
        });
        return result;
    }
    @Put(":id")
    @UseGuards(JwtAuthGuard, OrganizationAuthGuard)
    @ClientRoles(ClientRole.ADMIN)
    async update(
    @Param("organizationId")
    organizationId: string, 
    @Param("id")
    id: string, 
    @Body()
    updateClientUserDto: UpdateClientUserDto) {
        console.log("[ClientUsersController] Updating client user:", {
            organizationId,
            userId: id,
            updateData: { ...updateClientUserDto, password: updateClientUserDto.password ? "[REDACTED]" : undefined },
            timestamp: new Date().toISOString()
        });
        const result = await this.clientUsersService.update(organizationId, id, updateClientUserDto);
        console.log("[ClientUsersController] Updated client user:", {
            organizationId,
            userId: id,
            success: !!result,
            timestamp: new Date().toISOString()
        });
        return result;
    }
    @Delete(":id")
    @UseGuards(JwtAuthGuard, OrganizationAuthGuard)
    @ClientRoles(ClientRole.ADMIN)
    async remove(
    @Param("organizationId")
    organizationId: string, 
    @Param("id")
    id: string) {
        console.log("[ClientUsersController] Removing client user:", {
            organizationId,
            userId: id,
            timestamp: new Date().toISOString()
        });
        await this.clientUsersService.remove(organizationId, id);
        console.log("[ClientUsersController] Removed client user:", {
            organizationId,
            userId: id,
            timestamp: new Date().toISOString()
        });
        return { success: true };
    }
    @Put(":id/activate")
    @UseGuards(JwtAuthGuard, OrganizationAuthGuard)
    @ClientRoles(ClientRole.ADMIN)
    async activate(
    @Param("organizationId")
    organizationId: string, 
    @Param("id")
    id: string) {
        console.log("[ClientUsersController] Activating client user:", {
            organizationId,
            userId: id,
            timestamp: new Date().toISOString()
        });
        const result = await this.clientUsersService.activate(organizationId, id);
        console.log("[ClientUsersController] Activated client user:", {
            organizationId,
            userId: id,
            success: !!result,
            timestamp: new Date().toISOString()
        });
        return result;
    }
    @Put(":id/deactivate")
    @UseGuards(JwtAuthGuard, OrganizationAuthGuard)
    @ClientRoles(ClientRole.ADMIN)
    async deactivate(
    @Param("organizationId")
    organizationId: string, 
    @Param("id")
    id: string) {
        console.log("[ClientUsersController] Deactivating client user:", {
            organizationId,
            userId: id,
            timestamp: new Date().toISOString()
        });
        const result = await this.clientUsersService.deactivate(organizationId, id);
        console.log("[ClientUsersController] Deactivated client user:", {
            organizationId,
            userId: id,
            success: !!result,
            timestamp: new Date().toISOString()
        });
        return result;
    }
    @Put(":id/change-role")
    @UseGuards(JwtAuthGuard, OrganizationAuthGuard)
    @ClientRoles(ClientRole.ADMIN)
    async changeRole(
    @Param("organizationId")
    organizationId: string, 
    @Param("id")
    id: string, 
    @Body()
    roleData: {
        clientRole: ClientRole;
    }) {
        console.log("[ClientUsersController] Changing client user role:", {
            organizationId,
            userId: id,
            newRole: roleData.clientRole,
            timestamp: new Date().toISOString()
        });
        const result = await this.clientUsersService.changeRole(organizationId, id, roleData.clientRole);
        console.log("[ClientUsersController] Changed client user role:", {
            organizationId,
            userId: id,
            success: !!result,
            timestamp: new Date().toISOString()
        });
        return result;
    }
}

================
File: client-users/client-users.module.ts
================
import { Module } from '@nestjs/common';
import { ClientUsersService } from './client-users.service';
import { ClientUsersController } from './client-users.controller';
import { MikroOrmModule } from '@mikro-orm/nestjs';
import { ClientUser } from '../entities/client-user.entity';
import { Organization } from '../entities/organization.entity';
import { UserOrganization } from '../entities/user-organization.entity';
@Module({
    imports: [
        MikroOrmModule.forFeature([
            ClientUser,
            Organization,
            UserOrganization
        ])
    ],
    controllers: [ClientUsersController],
    providers: [ClientUsersService],
    exports: [ClientUsersService],
})
export class ClientUsersModule {
}

================
File: client-users/client-users.service.ts
================
import { Injectable, NotFoundException, ConflictException, BadRequestException, Logger, InternalServerErrorException } from '@nestjs/common';
import { EntityManager } from '@mikro-orm/core';
import { ClientUser } from '../entities/client-user.entity';
import { Organization } from '../entities/organization.entity';
import { CreateClientUserDto } from './dto/create-client-user.dto';
import { UpdateClientUserDto } from './dto/update-client-user.dto';
import * as bcrypt from 'bcrypt';
import { ClientRole } from '../common/enums/client-role.enum';
@Injectable()
export class ClientUsersService {
    private readonly logger = new Logger(ClientUsersService.name);
    constructor(private readonly em: EntityManager) { }
    async findAll(organizationId: string): Promise<ClientUser[]> {
        this.logger.log(`Finding all client users for organization: ${organizationId}`);
        try {
            const organization = await this.em.findOne(Organization, { id: organizationId });
            if (!organization) {
                this.logger.warn(`Organization not found: ${organizationId}`);
                throw new NotFoundException("Organization not found");
            }
            const users = await this.em.find(ClientUser, { organization }, {
                populate: ["organization"],
                filters: false
            });
            this.logger.log(`Found ${users.length} client users for organization: ${organizationId}`);
            const validUsers = users.filter(user => {
                try {
                    return user.validateRoleMapping();
                }
                catch (error) {
                    this.logger.warn(`Invalid role mapping for user ${user.id}: ${error.message}`);
                    return false;
                }
            });
            this.logger.log(`Returning ${validUsers.length} valid users out of ${users.length} total`);
            return validUsers;
        }
        catch (error) {
            this.logger.error(`Error in findAll: ${error.message}`, error.stack);
            if (error instanceof NotFoundException) {
                throw error;
            }
            throw new InternalServerErrorException("Failed to load client users");
        }
    }
    async create(organizationId: string, dto: CreateClientUserDto): Promise<ClientUser> {
        this.logger.log(`Creating client user with email: ${dto.email} for organization: ${organizationId}`);
        // Check if email already exists
        const existingUser = await this.em.findOne(ClientUser, { email: dto.email });
        if (existingUser) {
            this.logger.warn(`Email already exists: ${dto.email}`);
            throw new ConflictException("Email already exists");
        }
        // Get organization reference
        const organization = await this.em.findOne(Organization, { id: organizationId });
        if (!organization) {
            this.logger.warn(`Organization not found: ${organizationId}`);
            throw new NotFoundException("Organization not found");
        }
        // Handle USER role case
        if (dto.clientRole === ClientRole.USER && dto.organizationRole) {
            this.logger.warn("Attempted to assign organization role to USER client role");
            throw new BadRequestException("User role cannot have an organization role");
        }
        // Create new client user
        const clientUser = new ClientUser();
        clientUser.firstName = dto.firstName;
        clientUser.lastName = dto.lastName;
        clientUser.email = dto.email;
        clientUser.clientRole = dto.clientRole;
        clientUser.organizationRole = dto.organizationRole;
        clientUser.organization = organization;
        // Hash password
        const salt = await bcrypt.genSalt();
        clientUser.password = await bcrypt.hash(dto.password, salt);
        try {
            await this.em.persistAndFlush(clientUser);
            this.logger.log(`Successfully created client user: ${clientUser.id}`);
            return clientUser;
        }
        catch (error) {
            this.logger.error("Failed to create client user", error.stack);
            if (error.name === "ValidationError") {
                throw new BadRequestException(error.message);
            }
            throw error;
        }
    }
    async findOne(organizationId: string, id: string): Promise<ClientUser> {
        this.logger.log(`Finding client user by ID: ${id} in organization: ${organizationId}`);
        const clientUser = await this.em.findOne(ClientUser, {
            id,
            organization: { id: organizationId }
        }, {
            populate: ["organization"]
        });
        if (!clientUser) {
            this.logger.warn(`Client user not found: ${id} in organization: ${organizationId}`);
            throw new NotFoundException("Client user not found");
        }
        this.logger.log(`Found client user: ${id}`);
        return clientUser;
    }
    async update(organizationId: string, id: string, dto: UpdateClientUserDto): Promise<ClientUser> {
        this.logger.log(`Updating client user: ${id} in organization: ${organizationId}`);
        const clientUser = await this.findOne(organizationId, id);
        // If email is being updated, check for uniqueness
        if (dto.email && dto.email !== clientUser.email) {
            this.logger.log(`Checking email uniqueness for update: ${dto.email}`);
            const existingUser = await this.em.findOne(ClientUser, { email: dto.email });
            if (existingUser) {
                this.logger.warn(`Email already exists during update: ${dto.email}`);
                throw new ConflictException("Email already exists");
            }
        }
        // Handle role updates
        if (dto.clientRole === ClientRole.USER) {
            this.logger.log("Setting organization role to null for USER client role");
            clientUser.organizationRole = null;
        }
        // Update fields
        if (dto.firstName)
            clientUser.firstName = dto.firstName;
        if (dto.lastName)
            clientUser.lastName = dto.lastName;
        if (dto.email)
            clientUser.email = dto.email;
        if (dto.clientRole)
            clientUser.clientRole = dto.clientRole;
        if (dto.organizationRole)
            clientUser.organizationRole = dto.organizationRole;
        if (dto.password) {
            this.logger.log("Updating password");
            const salt = await bcrypt.genSalt();
            clientUser.password = await bcrypt.hash(dto.password, salt);
        }
        try {
            await this.em.persistAndFlush(clientUser);
            this.logger.log(`Successfully updated client user: ${id}`);
            return clientUser;
        }
        catch (error) {
            this.logger.error("Failed to update client user", error.stack);
            if (error.name === "ValidationError") {
                throw new BadRequestException(error.message);
            }
            throw error;
        }
    }
    async remove(organizationId: string, id: string): Promise<void> {
        this.logger.log(`Removing client user: ${id} from organization: ${organizationId}`);
        const clientUser = await this.findOne(organizationId, id);
        await this.em.removeAndFlush(clientUser);
        this.logger.log(`Successfully removed client user: ${id}`);
    }
    async activate(organizationId: string, id: string): Promise<ClientUser> {
        this.logger.log(`Activating client user: ${id} in organization: ${organizationId}`);
        const clientUser = await this.findOne(organizationId, id);
        clientUser.isActive = true;
        await this.em.persistAndFlush(clientUser);
        this.logger.log(`Successfully activated client user: ${id}`);
        return clientUser;
    }
    async deactivate(organizationId: string, id: string): Promise<ClientUser> {
        this.logger.log(`Deactivating client user: ${id} in organization: ${organizationId}`);
        const clientUser = await this.findOne(organizationId, id);
        clientUser.isActive = false;
        await this.em.persistAndFlush(clientUser);
        this.logger.log(`Successfully deactivated client user: ${id}`);
        return clientUser;
    }
    async changeRole(organizationId: string, id: string, clientRole: ClientRole): Promise<ClientUser> {
        this.logger.log(`Changing role for client user: ${id} in organization: ${organizationId} to ${clientRole}`);
        const clientUser = await this.findOne(organizationId, id);
        clientUser.clientRole = clientRole;
        // Clear organization role if changing to USER role
        if (clientRole === ClientRole.USER) {
            clientUser.organizationRole = null;
        }
        await this.em.persistAndFlush(clientUser);
        this.logger.log(`Successfully changed role for client user: ${id}`);
        return clientUser;
    }
    async findByEmail(email: string): Promise<ClientUser | null> {
        this.logger.log(`Finding client user by email: ${email}`);
        return this.em.findOne(ClientUser, { email }, {
            populate: ["organization"]
        });
    }
    async validatePassword(clientUser: ClientUser, password: string): Promise<boolean> {
        this.logger.log(`Validating password for client user: ${clientUser.id}`);
        return bcrypt.compare(password, clientUser.password);
    }
}

================
File: client-users/dto/create-client-user.dto.ts
================
import { IsEmail, IsEnum, IsNotEmpty, IsOptional, IsString, MinLength, ValidateIf } from 'class-validator';
import { ClientRole } from '../../common/enums/client-role.enum';
import { OrganizationRole } from '../../common/enums/organization-role.enum';
export class CreateClientUserDto {
    @IsNotEmpty()
    @IsString()
    firstName: string;
    @IsNotEmpty()
    @IsString()
    lastName: string;
    @IsNotEmpty()
    @IsEmail()
    email: string;
    @IsNotEmpty()
    @IsString()
    @MinLength(8)
    password: string;
    @IsNotEmpty()
    @IsEnum(ClientRole)
    clientRole: ClientRole;
    @ValidateIf(o => o.clientRole !== ClientRole.USER)
    @IsNotEmpty({ message: "Organization role is required for non-USER client roles" })
    @IsEnum(OrganizationRole)
    organizationRole?: OrganizationRole;
    @IsNotEmpty()
    @IsString()
    organizationId: string;
}

================
File: client-users/dto/update-client-user.dto.ts
================
import { IsEmail, IsEnum, IsOptional, IsString, MinLength, ValidateIf } from 'class-validator';
import { ClientRole } from '../../common/enums/client-role.enum';
import { OrganizationRole } from '../../common/enums/organization-role.enum';
export class UpdateClientUserDto {
    @IsOptional()
    @IsString()
    firstName?: string;
    @IsOptional()
    @IsString()
    lastName?: string;
    @IsOptional()
    @IsEmail()
    email?: string;
    @IsOptional()
    @IsString()
    @MinLength(8)
    password?: string;
    @IsOptional()
    @IsEnum(ClientRole)
    clientRole?: ClientRole;
    @ValidateIf(o => o.clientRole && o.clientRole !== ClientRole.USER)
    @IsEnum(OrganizationRole)
    organizationRole?: OrganizationRole;
    @IsOptional()
    @IsString()
    organizationId?: string;
    @IsOptional()
    @IsString()
    isActive?: boolean;
}

================
File: common/enums/client-role.enum.ts
================
export enum ClientRole {
    ADMIN = "ADMIN",// Maps to ISSM - Has full administrative control within client org
    MANAGER = "MANAGER",// Maps to ISSO - Can manage systems but not other users
    PM = "PM",// Program Manager - System security governance
    USER = "USER"
}

================
File: common/enums/organization-role.enum.ts
================
import { ClientRole } from './client-role.enum';
export enum OrganizationRole {
    // Service Provider Roles (Foxx Cyber only)
    AODR = "AODR",// Authorizing Official Designated Representative
    SCA = "SCA",// Security Control Assessor
    SCAR = "SCAR",// Security Control Assessor Representative
    AUDITOR = "AUDITOR",// Audit capabilities across client orgs
    // Client Organization Roles
    PM = "PM",// Program Manager - System security governance
    ISSM = "ISSM",// Information System Security Manager
    ISSO = "ISSO"
}
// Role mapping type for type safety when mapping between roles
export type RoleMapping = {
    CLIENT_ADMIN: OrganizationRole.ISSM; // Full client org management
    CLIENT_MANAGER: OrganizationRole.ISSO; // System-level management
    CLIENT_PM: OrganizationRole.PM; // Program management
    CLIENT_USER: null; // Basic user, no special org role
};
// Helper function to map client roles to organization roles
export function mapClientToOrgRole(clientRole: ClientRole): OrganizationRole | null {
    const roleMap: Record<ClientRole, OrganizationRole | null> = {
        [ClientRole.ADMIN]: OrganizationRole.ISSM,
        [ClientRole.MANAGER]: OrganizationRole.ISSO,
        [ClientRole.PM]: OrganizationRole.PM,
        [ClientRole.USER]: null,
    };
    return roleMap[clientRole];
}

================
File: common/enums/system-role.enum.ts
================
export enum SystemRole {
    GLOBAL_ADMIN = "GLOBAL_ADMIN",
    ADMIN = "ADMIN",
    USER = "USER"
}

================
File: common/pipes/zod-validation.pipe.ts
================
import { PipeTransform, Injectable, BadRequestException } from '@nestjs/common';
import { ZodSchema } from 'zod';

@Injectable()
export class ZodValidationPipe implements PipeTransform {
  constructor(private schema: ZodSchema) {}

  transform(value: unknown) {
    try {
      return this.schema.parse(value);
    } catch (error) {
      throw new BadRequestException('Validation failed');
    }
  }
}

================
File: domain/rmf/catalog.controller.ts
================
import { Controller, Get, Post, Param, NotFoundException, UseGuards, Logger, UseInterceptors, UploadedFile, Body, Query } from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { diskStorage } from 'multer';
import * as path from 'path';
import { CatalogService } from './catalog.service';
import { CatalogAuthGuard } from './guards/catalog-auth.guard';
import { CatalogDto, GroupDto, ControlDto, PaginationDto, PaginationSchema, ControlBasicDto } from './dto/catalog.dto';
import { ZodValidationPipe } from '../../common/pipes/zod-validation.pipe';

@Controller('catalogs')
@UseGuards(CatalogAuthGuard)
export class CatalogController {
  private readonly logger = new Logger(CatalogController.name);

  constructor(private readonly catalogService: CatalogService) {}

  @Post('upload')
  @UseInterceptors(FileInterceptor('file', {
    storage: diskStorage({
      destination: './frameworks',
      filename: (req, file, cb) => {
        const fileName = file.originalname.toLowerCase().replace(/[^a-z0-9\-\_\.]/g, '_');
        cb(null, fileName);
      }
    }),
    fileFilter: (req, file, cb) => {
      if (!file.originalname.match(/\.(json)$/)) {
        return cb(new Error('Only JSON files are allowed!'), false);
      }
      cb(null, true);
    }
  }))
  async uploadCatalog(
    @UploadedFile() file: Express.Multer.File,
    @Body('type') type: string
  ) {
    this.logger.log(`Uploading catalog file: ${file.originalname}`);
    const startTime = Date.now();

    try {
      const result = await this.catalogService.importCatalog(file.path);
      
      const duration = Date.now() - startTime;
      this.logger.log(`Successfully imported catalog in ${duration}ms`);
      
      return {
        success: true,
        message: 'Catalog imported successfully',
        details: result
      };
    } catch (error) {
      this.logger.error(`Error importing catalog: ${error.message}`, error.stack);
      throw error;
    }
  }

  @Get()
  async findAll(): Promise<CatalogDto[]> {
    this.logger.log('GET /catalogs - Retrieving all catalogs');
    const startTime = Date.now();

    try {
      const catalogs = await this.catalogService.findAll();
      const dtos = catalogs.map(catalog => {
        const groups = catalog.groups.getItems();
        return {
          id: catalog.id,
          title: catalog.title,
          version: catalog.version,
          lastModified: catalog.lastModified,
          groups: groups.map(group => ({
            id: group.id,
            title: group.title,
            class: group.class,
            controls: []
          }))
        };
      });

      const duration = Date.now() - startTime;
      this.logger.log(`Successfully retrieved ${dtos.length} catalogs in ${duration}ms`);
      
      return dtos;
    } catch (error) {
      this.logger.error(`Error retrieving catalogs: ${error.message}`, error.stack);
      throw error;
    }
  }

  @Get(':id')
  async findOne(
    @Param('id') id: string,
    @Query(new ZodValidationPipe(PaginationSchema)) pagination?: PaginationDto
  ): Promise<CatalogDto> {
    this.logger.log(`GET /catalogs/${id} - Retrieving catalog with pagination`);
    const startTime = Date.now();

    try {
      // If no pagination params provided, use findCatalogBasic
      if (!pagination?.page && !pagination?.limit) {
        const catalog = await this.catalogService.findCatalogBasic(id);
        if (!catalog) {
          this.logger.warn(`Catalog not found: ${id}`);
          throw new NotFoundException(`Catalog with ID ${id} not found`);
        }

        const groups = catalog.groups.getItems();
        return {
          id: catalog.id,
          title: catalog.title,
          version: catalog.version,
          lastModified: catalog.lastModified,
          groups: groups.map(group => ({
            id: group.id,
            title: group.title,
            class: group.class,
            controls: []
          }))
        };
      }

      // Otherwise use pagination
      const { catalog, totalGroups, hasMore } = await this.catalogService.findCatalogWithPagination(id, pagination);
      if (!catalog) {
        this.logger.warn(`Catalog not found: ${id}`);
        throw new NotFoundException(`Catalog with ID ${id} not found`);
      }

      const groups = catalog.groups.getItems();
      const dto: CatalogDto = {
        id: catalog.id,
        title: catalog.title,
        version: catalog.version,
        lastModified: catalog.lastModified,
        totalGroups,
        hasMore,
        groups: groups.map(group => ({
          id: group.id,
          title: group.title,
          class: group.class,
          controls: group.controls.getItems().map(control => ({
            id: control.id,
            title: control.title,
            class: control.class
          }))
        }))
      };

      const duration = Date.now() - startTime;
      this.logger.log(
        `Successfully retrieved catalog: ${catalog.title} (${catalog.version})\n` +
        `Statistics:\n` +
        `- Groups: ${groups.length}\n` +
        `Duration: ${duration}ms`
      );

      return dto;
    } catch (error) {
      this.logger.error(`Error retrieving catalog ${id}: ${error.message}`, error.stack);
      throw error;
    }
  }

  @Get('groups/:groupId')
  async findGroup(
    @Param('groupId') groupId: string,
    @Query(new ZodValidationPipe(PaginationSchema)) pagination?: PaginationDto
  ): Promise<GroupDto> {
    this.logger.log(`GET /catalogs/groups/${groupId} - Retrieving group`);
    const startTime = Date.now();

    try {
      // If no pagination params provided, use findGroup
      if (!pagination?.page && !pagination?.limit) {
        const group = await this.catalogService.findGroup(groupId);
        if (!group) {
          this.logger.warn(`Group not found: ${groupId}`);
          throw new NotFoundException(`Group with ID ${groupId} not found`);
        }

        return {
          id: group.id,
          title: group.title,
          class: group.class,
          controls: group.controls.getItems().map(control => ({
            id: control.id,
            title: control.title,
            class: control.class
          }))
        };
      }

      // Otherwise use pagination
      const { group, totalControls, hasMore } = await this.catalogService.findGroupWithPagination(groupId, pagination);
      if (!group) {
        this.logger.warn(`Group not found: ${groupId}`);
        throw new NotFoundException(`Group with ID ${groupId} not found`);
      }

      const dto: GroupDto = {
        id: group.id,
        title: group.title,
        class: group.class,
        totalControls,
        hasMore,
        controls: group.controls.getItems().map(control => ({
          id: control.id,
          title: control.title,
          class: control.class
        }))
      };

      const duration = Date.now() - startTime;
      this.logger.log(
        `Successfully retrieved group: ${group.title}\n` +
        `Duration: ${duration}ms`
      );

      return dto;
    } catch (error) {
      this.logger.error(`Error retrieving group ${groupId}: ${error.message}`, error.stack);
      throw error;
    }
  }

  @Get('controls/:controlId')
  async findControl(@Param('controlId') controlId: string): Promise<ControlDto> {
    this.logger.log(`GET /catalogs/controls/${controlId} - Retrieving control`);
    const startTime = Date.now();

    try {
      const control = await this.catalogService.findControl(controlId);
      if (!control) {
        this.logger.warn(`Control not found: ${controlId}`);
        throw new NotFoundException(`Control with ID ${controlId} not found`);
      }

      const parts = control.parts.getItems();
      const parameters = control.parameters.getItems();
      const enhancements = control.enhancements?.getItems() || [];
      const outgoingLinks = control.outgoingLinks?.getItems() || [];
      const incomingLinks = control.incomingLinks?.getItems() || [];

      const dto: ControlDto = {
        id: control.id,
        title: control.title,
        class: control.class,
        parts: parts.map(part => ({
          id: part.id,
          name: part.name,
          prose: part.prose
        })),
        parameters: parameters.map(param => ({
          id: param.id,
          label: param.label
        })),
        enhancements: enhancements.map(enhancement => ({
          id: enhancement.id,
          title: enhancement.title,
          class: enhancement.class,
          parts: enhancement.parts.getItems().map(part => ({
            id: part.id,
            name: part.name,
            prose: part.prose
          })),
          parameters: enhancement.parameters.getItems().map(param => ({
            id: param.id,
            label: param.label
          }))
        })),
        outgoingLinks: outgoingLinks.map(link => ({
          rel: link.rel,
          href: link.href,
          targetControl: link.targetControl ? {
            id: link.targetControl.id,
            title: link.targetControl.title,
            class: link.targetControl.class
          } : undefined
        })),
        incomingLinks: incomingLinks.map(link => ({
          rel: link.rel,
          href: link.href,
          sourceControl: link.sourceControl ? {
            id: link.sourceControl.id,
            title: link.sourceControl.title,
            class: link.sourceControl.class
          } : undefined
        }))
      };

      const duration = Date.now() - startTime;
      this.logger.log(
        `Successfully retrieved control: ${control.title}\n` +
        `- Parts: ${parts.length}\n` +
        `- Parameters: ${parameters.length}\n` +
        `- Enhancements: ${enhancements.length}\n` +
        `- Outgoing Links: ${outgoingLinks.length}\n` +
        `- Incoming Links: ${incomingLinks.length}\n` +
        `Duration: ${duration}ms`
      );

      return dto;
    } catch (error) {
      this.logger.error(`Error retrieving control ${controlId}: ${error.message}`, error.stack);
      throw error;
    }
  }

  @Get('controls/:controlId/related')
  async getRelatedControls(@Param('controlId') controlId: string): Promise<ControlBasicDto[]> {
    this.logger.log(`GET /catalogs/controls/${controlId}/related - Retrieving related controls`);
    const startTime = Date.now();

    try {
      const relatedControls = await this.catalogService.getRelatedControls(controlId);
      
      const dto = relatedControls.map(control => ({
        id: control.id,
        title: control.title,
        class: control.class
      }));

      const duration = Date.now() - startTime;
      this.logger.log(
        `Successfully retrieved related controls for ${controlId}\n` +
        `- Related Controls: ${dto.length}\n` +
        `Duration: ${duration}ms`
      );

      return dto;
    } catch (error) {
      this.logger.error(`Error retrieving related controls for ${controlId}: ${error.message}`, error.stack);
      throw error;
    }
  }
}

================
File: domain/rmf/catalog.module.ts
================
import { Module } from '@nestjs/common';
import { MikroOrmModule } from '@mikro-orm/nestjs';
import { Control } from '../../entities/control.entity';
import { ControlLink } from '../../entities/control-link.entity';
import { Part } from '../../entities/part.entity';
import { Parameter } from '../../entities/parameter.entity';
import { Group } from '../../entities/group.entity';
import { Catalog } from '../../entities/catalog.entity';
import { CatalogService } from './catalog.service';
import { CatalogController } from './catalog.controller';

@Module({
  imports: [
    MikroOrmModule.forFeature([
      Control,
      ControlLink,
      Part,
      Parameter,
      Group,
      Catalog,
    ]),
  ],
  providers: [CatalogService],
  controllers: [CatalogController],
  exports: [CatalogService],
})
export class CatalogModule {}

================
File: domain/rmf/catalog.service.ts
================
import { Injectable, Logger } from '@nestjs/common';
import { EntityManager, QueryOrder } from '@mikro-orm/core';
import { Catalog } from '../../entities/catalog.entity';
import { Group } from '../../entities/group.entity';
import { Control } from '../../entities/control.entity';
import { Parameter } from '../../entities/parameter.entity';
import { Part } from '../../entities/part.entity';
import { ControlLink } from '../../entities/control-link.entity';
import { PaginationDto } from './dto/catalog.dto';
import * as fs from 'fs';
import { z } from 'zod';
import { v4 as uuidv4 } from 'uuid';

// Validation schemas remain the same...
const ParameterSchema = z.object({
  id: z.string(),
  label: z.string().optional().default('')
});

const PartSchema = z.object({
  id: z.string().optional(),
  name: z.string(),
  prose: z.string().optional(),
  parts: z.array(z.lazy(() => PartSchema)).optional()
}).transform(part => ({
  ...part,
  id: part.id || uuidv4()
}));

const LinkSchema = z.object({
  href: z.string(),
  rel: z.string()
});

const EnhancementSchema = z.object({
  id: z.string(),
  class: z.literal('SP800-53-enhancement'),
  title: z.string(),
  params: z.array(ParameterSchema).optional(),
  parts: z.array(PartSchema).optional(),
  links: z.array(LinkSchema).optional()
});

const ControlSchema = z.object({
  id: z.string(),
  class: z.string(),
  title: z.string(),
  params: z.array(ParameterSchema).optional(),
  parts: z.array(PartSchema).optional(),
  controls: z.array(EnhancementSchema).optional(),
  links: z.array(LinkSchema).optional()
});

const GroupSchema = z.object({
  id: z.string(),
  class: z.string(),
  title: z.string(),
  controls: z.array(ControlSchema)
});

const CatalogSchema = z.object({
  catalog: z.object({
    uuid: z.string(),
    metadata: z.object({
      title: z.string(),
      version: z.string(),
      'last-modified': z.string()
    }),
    groups: z.array(GroupSchema)
  })
});

@Injectable()
export class CatalogService {
  private readonly logger = new Logger(CatalogService.name);

  constructor(private readonly em: EntityManager) {}

  async findAll(): Promise<Catalog[]> {
    this.logger.log('Finding all catalogs with basic info');
    try {
      const catalogs = await this.em.find(Catalog, {}, { 
        populate: ['groups'] 
      });
      
      const catalogSummary = catalogs.map(catalog => ({
        id: catalog.id,
        title: catalog.title,
        groupCount: catalog.groups.count()
      }));
      
      this.logger.log(`Found ${catalogs.length} catalogs. Summary: ${JSON.stringify(catalogSummary, null, 2)}`);
      return catalogs;
    } catch (error) {
      this.logger.error(`Error finding catalogs: ${error.message}`, error.stack);
      throw error;
    }
  }

  async findCatalogBasic(id: string): Promise<Catalog | null> {
    this.logger.log(`Finding basic catalog info with id: ${id}`);
    try {
      const catalog = await this.em.findOne(Catalog, { id }, { 
        populate: ['groups'] 
      });
      
      if (catalog) {
        const groupCount = catalog.groups.count();
        this.logger.log(
          `Found catalog: ${catalog.title} (${catalog.version}) ` +
          `with ${groupCount} groups`
        );
      } else {
        this.logger.warn(`No catalog found with id: ${id}`);
      }
      
      return catalog;
    } catch (error) {
      this.logger.error(`Error finding catalog ${id}: ${error.message}`, error.stack);
      throw error;
    }
  }

  async findGroup(groupId: string): Promise<Group | null> {
    this.logger.log(`Finding group with id: ${groupId}`);
    try {
      const group = await this.em.findOne(Group, { id: groupId }, { 
        populate: ['controls'] 
      });
      
      if (group) {
        this.logger.log(
          `Found group: ${group.title} with ${group.controls.count()} controls`
        );
      } else {
        this.logger.warn(`No group found with id: ${groupId}`);
      }
      
      return group;
    } catch (error) {
      this.logger.error(`Error finding group ${groupId}: ${error.message}`, error.stack);
      throw error;
    }
  }

  async findCatalogWithPagination(id: string, pagination: PaginationDto) {
    this.logger.log(`Finding catalog with pagination, id: ${id}, page: ${pagination.page}, limit: ${pagination.limit}`);
    try {
      const catalog = await this.em.findOne(Catalog, { id });
      if (!catalog) {
        return { catalog: null, totalGroups: 0, hasMore: false };
      }

      // Get total count of groups
      const totalGroups = await this.em.count(Group, { catalog });

      // Calculate offset
      const offset = (pagination.page - 1) * pagination.limit;

      // Load groups with pagination
      const groups = await this.em.find(Group, { catalog }, {
        orderBy: { title: QueryOrder.ASC },
        limit: pagination.limit,
        offset: offset
      });

      // Manually set the groups collection
      catalog.groups.set(groups);

      // Load basic control information for each group
      for (const group of groups) {
        const controls = await this.em.find(Control, { group });
        const controlRefs = controls.map(control => this.em.getReference(Control, control.id));
        group.controls.set(controlRefs);
      }

      const hasMore = offset + pagination.limit < totalGroups;

      this.logger.log(
        `Found catalog: ${catalog.title} (${catalog.version})\n` +
        `Page ${pagination.page}: ${groups.length} groups\n` +
        `Total groups: ${totalGroups}\n` +
        `Has more: ${hasMore}`
      );

      return { catalog, totalGroups, hasMore };
    } catch (error) {
      this.logger.error(`Error finding catalog ${id}: ${error.message}`, error.stack);
      throw error;
    }
  }

  async findGroupWithPagination(groupId: string, pagination: PaginationDto) {
    this.logger.log(`Finding group with pagination, id: ${groupId}, page: ${pagination.page}, limit: ${pagination.limit}`);
    try {
      const group = await this.em.findOne(Group, { id: groupId });
      if (!group) {
        return { group: null, totalControls: 0, hasMore: false };
      }

      // Get total count of controls
      const totalControls = await this.em.count(Control, { group });

      // Calculate offset
      const offset = (pagination.page - 1) * pagination.limit;

      // Load controls with pagination
      const controls = await this.em.find(Control, { group }, {
        orderBy: { id: QueryOrder.ASC },
        limit: pagination.limit,
        offset: offset
      });

      // Convert to references and set the collection
      const controlRefs = controls.map(control => this.em.getReference(Control, control.id));
      group.controls.set(controlRefs);

      const hasMore = offset + pagination.limit < totalControls;

      this.logger.log(
        `Found group: ${group.title}\n` +
        `Page ${pagination.page}: ${controls.length} controls\n` +
        `Total controls: ${totalControls}\n` +
        `Has more: ${hasMore}`
      );

      return { group, totalControls, hasMore };
    } catch (error) {
      this.logger.error(`Error finding group ${groupId}: ${error.message}`, error.stack);
      throw error;
    }
  }

  async findControl(controlId: string): Promise<Control | null> {
    this.logger.log(`Finding control with id: ${controlId}`);
    try {
      const control = await this.em.findOne(Control, { id: controlId }, { 
        populate: [
          'parts',
          'parameters',
          'enhancements',
          'enhancements.parts',
          'enhancements.parameters',
          'outgoingLinks',
          'outgoingLinks.targetControl',
          'incomingLinks',
          'incomingLinks.sourceControl'
        ] 
      });
      
      if (control) {
        this.logger.log(
          `Found control: ${control.title} with ` +
          `${control.parts.count()} parts, ${control.parameters.count()} parameters, ` +
          `${control.enhancements?.count() || 0} enhancements, ` +
          `${control.outgoingLinks?.count() || 0} outgoing links, and ` +
          `${control.incomingLinks?.count() || 0} incoming links`
        );
      } else {
        this.logger.warn(`No control found with id: ${controlId}`);
      }
      
      return control;
    } catch (error) {
      this.logger.error(`Error finding control ${controlId}: ${error.message}`, error.stack);
      throw error;
    }
  }

  async findCatalogWithFullHierarchy(id: string): Promise<Catalog | null> {
    this.logger.log(`Finding catalog with full hierarchy, id: ${id}`);
    try {
      const catalog = await this.em.findOne(Catalog, { id }, { 
        populate: [
          'groups',
          'groups.controls',
          'groups.controls.parts',
          'groups.controls.parameters',
          'groups.controls.enhancements',
          'groups.controls.enhancements.parts',
          'groups.controls.enhancements.parameters',
          'groups.controls.outgoingLinks',
          'groups.controls.outgoingLinks.targetControl',
          'groups.controls.incomingLinks',
          'groups.controls.incomingLinks.sourceControl'
        ]
      });
      
      if (catalog) {
        const groupCount = catalog.groups.count();
        const controlCount = catalog.groups.getItems().reduce(
          (sum, group) => sum + group.controls.count(), 
          0
        );
        this.logger.log(
          `Found catalog: ${catalog.title} (${catalog.version}) ` +
          `with ${groupCount} groups and ${controlCount} controls`
        );

        // Log detailed information about the first control to verify data
        const firstGroup = catalog.groups.getItems()[0];
        if (firstGroup) {
          const firstControl = firstGroup.controls.getItems()[0];
          if (firstControl) {
            this.logger.debug(
              `Sample control ${firstControl.id}:\n` +
              `- Parts: ${firstControl.parts.isInitialized() ? firstControl.parts.count() : 'not initialized'}\n` +
              `- Parameters: ${firstControl.parameters.isInitialized() ? firstControl.parameters.count() : 'not initialized'}\n` +
              `- Enhancements: ${firstControl.enhancements?.isInitialized() ? firstControl.enhancements.count() : 'not initialized'}\n` +
              `- OutgoingLinks: ${firstControl.outgoingLinks?.isInitialized() ? firstControl.outgoingLinks.count() : 'not initialized'}\n` +
              `- IncomingLinks: ${firstControl.incomingLinks?.isInitialized() ? firstControl.incomingLinks.count() : 'not initialized'}`
            );
          }
        }
      } else {
        this.logger.warn(`No catalog found with id: ${id}`);
      }
      
      return catalog;
    } catch (error) {
      this.logger.error(`Error finding catalog ${id}: ${error.message}`, error.stack);
      throw error;
    }
  }

  async getRelatedControls(controlId: string): Promise<Control[]> {
    this.logger.log(`Finding related controls for control: ${controlId}`);
    try {
      const links = await this.em.find(ControlLink, {
        $or: [
          { sourceControl: controlId, rel: 'related' },
          { targetControl: controlId, rel: 'related' },
        ],
      }, {
        populate: ['sourceControl', 'targetControl'],
      });

      const relatedControls = new Set<Control>();
      
      for (const link of links) {
        if (link.sourceControl.id === controlId) {
          relatedControls.add(link.targetControl);
        } else {
          relatedControls.add(link.sourceControl);
        }
      }

      this.logger.log(`Found ${relatedControls.size} related controls for ${controlId}`);
      return Array.from(relatedControls);
    } catch (error) {
      this.logger.error(`Error finding related controls for ${controlId}: ${error.message}`, error.stack);
      throw error;
    }
  }

  // importCatalog method remains the same...
  async importCatalog(filePath: string) {
    this.logger.log(`Importing catalog from file: ${filePath}`);
    const startTime = Date.now();

    try {
      // Read and validate OSCAL JSON file
      const rawData = fs.readFileSync(filePath, 'utf8');
      const parsedData = JSON.parse(rawData);
      const validatedData = CatalogSchema.parse(parsedData);

      const em = this.em.fork();
      const controlMap = new Map<string, Control>();

      // Create catalog
      const catalog = new Catalog(
        validatedData.catalog.uuid,
        validatedData.catalog.metadata.title,
        validatedData.catalog.metadata.version,
        new Date(validatedData.catalog.metadata['last-modified'])
      );
      await em.persistAndFlush(catalog);

      // Process groups and their controls
      const stats = {
        groups: 0,
        controls: 0,
        parts: 0,
        parameters: 0,
        enhancements: 0,
        links: 0
      };

      // First pass: Create all controls and store them in the map
      for (const groupData of validatedData.catalog.groups) {
        const group = new Group(
          groupData.id,
          groupData.title,
          groupData.class,
          catalog
        );
        em.persist(group);
        stats.groups++;

        for (const controlData of groupData.controls) {
          const control = new Control(
            controlData.id,
            controlData.title,
            controlData.class,
            group
          );
          em.persist(control);
          controlMap.set(controlData.id, control);
          stats.controls++;

          // Store enhancements in the map as well
          if (controlData.controls) {
            for (const enhancementData of controlData.controls) {
              const enhancement = new Control(
                enhancementData.id,
                enhancementData.title,
                enhancementData.class,
                group,
                control
              );
              em.persist(enhancement);
              controlMap.set(enhancementData.id, enhancement);
              stats.enhancements++;
            }
          }
        }
      }

      // Second pass: Process all controls with their components
      for (const groupData of validatedData.catalog.groups) {
        for (const controlData of groupData.controls) {
          const control = controlMap.get(controlData.id);
          if (!control) continue;

          // Process parameters
          if (controlData.params) {
            for (const paramData of controlData.params) {
              const parameter = new Parameter(
                paramData.id,
                paramData.label || '',
                control
              );
              em.persist(parameter);
              stats.parameters++;
            }
          }

          // Process parts
          if (controlData.parts) {
            await this.processPartsRecursively(controlData.parts, control, em, stats);
          }

          // Process links
          if (controlData.links) {
            await this.processControlLinks(controlData.links, control, em, controlMap, stats);
          }

          // Process enhancements
          if (controlData.controls) {
            for (const enhancementData of controlData.controls) {
              const enhancement = controlMap.get(enhancementData.id);
              if (!enhancement) continue;

              if (enhancementData.params) {
                for (const paramData of enhancementData.params) {
                  const parameter = new Parameter(
                    paramData.id,
                    paramData.label || '',
                    enhancement
                  );
                  em.persist(parameter);
                  stats.parameters++;
                }
              }

              if (enhancementData.parts) {
                await this.processPartsRecursively(enhancementData.parts, enhancement, em, stats);
              }

              if (enhancementData.links) {
                await this.processControlLinks(enhancementData.links, enhancement, em, controlMap, stats);
              }
            }
          }
        }

        // Flush after each group to avoid memory issues
        await em.flush();
      }

      const duration = Date.now() - startTime;
      const result = {
        success: true,
        duration,
        stats,
        catalog: {
          id: catalog.id,
          title: catalog.title,
          version: catalog.version
        }
      };

      this.logger.log(`Successfully imported catalog in ${duration}ms. Stats: ${JSON.stringify(stats, null, 2)}`);
      return result;

    } catch (error) {
      if (error instanceof z.ZodError) {
        this.logger.error('OSCAL validation failed:', error.errors);
        throw new Error('Invalid OSCAL format');
      }
      
      this.logger.error(`Error importing catalog: ${error.message}`, error.stack);
      throw error;
    }
  }

  private async processPartsRecursively(
    parts: z.infer<typeof PartSchema>[],
    control: Control,
    em: EntityManager,
    stats: { parts: number },
    parentPart?: Part
  ) {
    for (const partData of parts) {
      const part = new Part(
        partData.id,
        partData.name,
        partData.prose || '',
        control,
        parentPart
      );
      em.persist(part);
      stats.parts++;

      if (partData.parts) {
        await this.processPartsRecursively(partData.parts, control, em, stats, part);
      }
    }
  }

  private async processControlLinks(
    links: z.infer<typeof LinkSchema>[],
    sourceControl: Control,
    em: EntityManager,
    controlMap: Map<string, Control>,
    stats: { links: number }
  ) {
    for (const linkData of links) {
      // Extract control ID from href (remove '#' prefix)
      const targetId = linkData.href.startsWith('#') ? linkData.href.substring(1) : linkData.href;
      
      // For control-to-control relationships (like "related" or "incorporated-into")
      if (targetId.match(/^[a-z]{2}-\d+(\.\d+)?$/i)) {
        const targetControl = controlMap.get(targetId);
        if (targetControl) {
          const link = new ControlLink(
            uuidv4(),
            sourceControl,
            targetControl,
            linkData.rel,
            linkData.href
          );
          em.persist(link);
          stats.links++;
        }
      }
      // For other reference links (like external references)
      else {
        const link = new ControlLink(
          uuidv4(),
          sourceControl,
          sourceControl, // Self-reference for non-control links
          linkData.rel,
          linkData.href
        );
        em.persist(link);
        stats.links++;
      }
    }
  }
}

================
File: domain/rmf/dto/catalog.dto.ts
================
import { z } from 'zod';

export class PaginationDto {
  page: number = 1;
  limit: number = 10;
}

export class ControlBasicDto {
  id: string;
  title: string;
  class: string;
}

export class PartDto {
  id: string;
  name: string;
  prose: string;
}

export class ParameterDto {
  id: string;
  label: string;
}

export class EnhancementDto extends ControlBasicDto {
  parts: PartDto[];
  parameters: ParameterDto[];
}

export class LinkDto {
  rel: string;
  href: string;
  targetControl?: ControlBasicDto;
  sourceControl?: ControlBasicDto;
}

export class ControlDto extends ControlBasicDto {
  parts: PartDto[];
  parameters: ParameterDto[];
  enhancements: EnhancementDto[];
  outgoingLinks: LinkDto[];
  incomingLinks: LinkDto[];
}

export class GroupDto {
  id: string;
  title: string;
  class: string;
  controls: ControlBasicDto[];
  totalControls?: number;
  hasMore?: boolean;
}

export class CatalogDto {
  id: string;
  title: string;
  version: string;
  lastModified: Date;
  groups: GroupDto[];
  totalGroups?: number;
  hasMore?: boolean;
}

export const PaginationSchema = z.object({
  page: z.string().optional().transform(val => val ? parseInt(val, 10) : 1),
  limit: z.string().optional().transform(val => val ? parseInt(val, 10) : 10)
}).transform(val => ({
  page: Math.max(1, val.page),
  limit: Math.min(100, Math.max(1, val.limit))
}));

================
File: domain/rmf/dto/control-link.dto.ts
================
import { IsString, IsNotEmpty } from 'class-validator';

export class ControlLinkDto {
  @IsString()
  @IsNotEmpty()
  id: string;

  @IsString()
  @IsNotEmpty()
  sourceControlId: string;

  @IsString()
  @IsNotEmpty()
  targetControlId: string;

  @IsString()
  @IsNotEmpty()
  rel: string;

  @IsString()
  href: string;
}

export class CreateControlLinkDto {
  @IsString()
  @IsNotEmpty()
  sourceControlId: string;

  @IsString()
  @IsNotEmpty()
  targetControlId: string;

  @IsString()
  @IsNotEmpty()
  rel: string;

  @IsString()
  href: string;
}

export class UpdateControlLinkDto {
  @IsString()
  rel?: string;

  @IsString()
  href?: string;
}

================
File: domain/rmf/guards/catalog-auth.guard.ts
================
import { Injectable, ExecutionContext, Logger } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { Observable } from 'rxjs';

@Injectable()
export class CatalogAuthGuard extends AuthGuard(['system-jwt', 'client-jwt']) {
  private readonly logger = new Logger(CatalogAuthGuard.name);

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    this.logger.debug('Authenticating request for catalog access');
    return super.canActivate(context);
  }

  handleRequest(err: any, user: any, info: any, context: ExecutionContext) {
    this.logger.debug(`Authentication attempt: ${JSON.stringify({ success: !!user, error: err?.message, info })}`);
    
    if (err || !user) {
      this.logger.warn(`Authentication failed: ${err?.message || 'User not found'}`);
      return null;
    }

    this.logger.debug(`User authenticated successfully: ${user.email} (${user.type})`);
    return user;
  }
}

================
File: entities/approval.entity.ts
================
import { Entity, Property, Enum, ManyToOne } from '@mikro-orm/core';
import { ApprovalStatus } from '../enums/artifact.enum';
import { BaseEntity } from './base.entity';
import { ClientUser } from './client-user.entity';
import { Document } from './document.entity';
import { ControlAssessment } from './control-assessment.entity';
import { ATOPackage } from './ato-package.entity';
import { ContinuityPlan } from './continuity-plan.entity';
import { POAM } from './poam.entity';
@Entity()
export class Approval extends BaseEntity {
    @Property()
    entityType!: string; // Document, Control, Package, etc.
    @Property()
    entityId!: string; // ID of the entity being approved
    @ManyToOne(() => ClientUser)
    approver!: ClientUser;
    @Enum(() => ApprovalStatus)
    status: ApprovalStatus = ApprovalStatus.PENDING;
    @Property({ nullable: true })
    comments?: string;
    @Property({ nullable: true })
    approvedAt?: Date;
    // Relations to approvable entities
    @ManyToOne(() => Document, { nullable: true })
    document?: Document;
    @ManyToOne(() => ControlAssessment, { nullable: true })
    controlAssessment?: ControlAssessment;
    @ManyToOne(() => ATOPackage, { nullable: true })
    atoPackage?: ATOPackage;
    @ManyToOne(() => ContinuityPlan, { nullable: true })
    continuityPlan?: ContinuityPlan;
    @ManyToOne(() => POAM, { nullable: true })
    poam?: POAM;
}

================
File: entities/artifact-revision.entity.ts
================
import { Entity, Property, ManyToOne } from '@mikro-orm/core';
import { BaseEntity } from './base.entity';
import { Artifact } from './artifact.entity';
@Entity()
export class ArtifactRevision extends BaseEntity {
    @ManyToOne(() => Artifact)
    artifact!: Artifact;
    @Property()
    version!: string;
    @Property()
    fileUrl!: string;
    @Property({ nullable: true })
    changes?: string; // Description of changes
    @Property()
    createdBy!: string; // User ID reference
}

================
File: entities/artifact.entity.ts
================
import { Entity, Property, Enum, ManyToOne, OneToMany, Collection } from '@mikro-orm/core';
import { ArtifactType, ArtifactStatus } from '../enums/artifact.enum';
import { BaseEntity } from './base.entity';
import { Organization } from './organization.entity';
@Entity()
export class Artifact extends BaseEntity {
    @ManyToOne(() => Organization)
    organization!: Organization;
    @Property()
    name!: string;
    @Property({ nullable: true })
    description?: string;
    @Enum(() => ArtifactType)
    type!: ArtifactType;
    @Enum(() => ArtifactStatus)
    status: ArtifactStatus = ArtifactStatus.DRAFT;
    @Property()
    version!: string;
    @Property()
    fileUrl!: string; // S3 or file storage URL
    @Property()
    mimeType!: string;
    @Property()
    fileSize!: number;
    @Property({ type: "json", nullable: true })
    metadata?: any; // Additional metadata
    @Property({ nullable: true })
    lastReviewedAt?: Date;
    @Property({ nullable: true })
    expiresAt?: Date;
    // User references
    @Property()
    createdBy!: string;
    @Property({ nullable: true })
    lastReviewedBy?: string;
    @Property({ nullable: true })
    approvedBy?: string;
    // Relations
    @OneToMany("ControlArtifact", "artifact")
    controls = new Collection<any>(this);
    @OneToMany("ArtifactRevision", "artifact")
    revisions = new Collection<any>(this);
}

================
File: entities/asset.entity.ts
================
import { Entity, Property, ManyToOne, OneToMany, Collection, ManyToMany } from '@mikro-orm/core';
import { BaseEntity } from './base.entity';
import { System } from './system.entity';
import { ClientUser } from './client-user.entity';
@Entity()
export class Asset extends BaseEntity {
    @ManyToOne(() => System)
    system!: System;
    @Property()
    name!: string;
    @Property()
    type!: string; // Hardware, Software, Service
    @Property()
    status!: string; // Active, Inactive, Retired
    @ManyToOne(() => ClientUser)
    createdBy!: ClientUser;
    @Property({ nullable: true })
    description?: string;
    @Property({ nullable: true })
    version?: string;
    @Property({ nullable: true })
    location?: string;
    @Property({ nullable: true })
    purchaseDate?: Date;
    @Property({ nullable: true })
    endOfLife?: Date;
    // Relations
    @OneToMany("PortMapping", "asset")
    portMappings = new Collection<any>(this);
    @ManyToMany({ entity: "Incident", mappedBy: "affectedAssets" })
    incidents = new Collection<any>(this);
}

================
File: entities/ato-package.entity.ts
================
import { Entity, Property, Enum, ManyToOne, OneToMany, Collection } from '@mikro-orm/core';
import { ATOStatus, ATOPhase } from '../enums/ato.enum';
import { BaseEntity } from './base.entity';
import { System } from './system.entity';
@Entity()
export class ATOPackage extends BaseEntity {
    @ManyToOne(() => System)
    system!: System;
    @Property()
    name!: string;
    @Property({ nullable: true })
    description?: string;
    @Property()
    framework!: string; // e.g., "NIST 800-53 Rev 5"
    @Enum(() => ATOStatus)
    status: ATOStatus = ATOStatus.DRAFT;
    @Enum(() => ATOPhase)
    currentPhase: ATOPhase = ATOPhase.PREPARATION;
    // Timeline
    @Property({ nullable: true })
    validFrom?: Date;
    @Property({ nullable: true })
    validUntil?: Date;
    @Property({ nullable: true })
    lastAssessment?: Date;
    @Property({ nullable: true })
    nextAssessment?: Date;
    // Relations
    @OneToMany("ControlAssessment", "atoPackage")
    controls = new Collection<any>(this);
    @OneToMany("Approval", "atoPackage")
    approvals = new Collection<any>(this);
}

================
File: entities/audit-log.entity.ts
================
import { Entity, Property, ManyToOne } from '@mikro-orm/core';
import { BaseEntity } from './base.entity';
import { Organization } from './organization.entity';
import { SystemUser } from './system-user.entity';
import { ClientUser } from './client-user.entity';
@Entity()
export class AuditLog extends BaseEntity {
    @ManyToOne(() => Organization)
    organization!: Organization;
    @ManyToOne(() => SystemUser, { nullable: true })
    systemUser?: SystemUser;
    @ManyToOne(() => ClientUser, { nullable: true })
    clientUser?: ClientUser;
    @Property()
    action!: string; // Created, Updated, Deleted, Viewed
    @Property()
    entityType!: string; // The type of resource affected
    @Property()
    entityId!: string; // ID of the affected resource
    @Property({ type: "json" })
    details!: any; // Additional context about the action
    @Property({ nullable: true })
    ipAddress?: string;
    @Property({ nullable: true })
    userAgent?: string;
}

================
File: entities/base.entity.ts
================
import { PrimaryKey, Property } from '@mikro-orm/core';
import { v4 } from 'uuid';
export abstract class BaseEntity {
    @PrimaryKey()
    id: string = v4();
    @Property()
    createdAt: Date = new Date();
    @Property({ onUpdate: () => new Date() })
    updatedAt: Date = new Date();
}

================
File: entities/catalog.entity.ts
================
import { Entity, PrimaryKey, Property, OneToMany, Collection } from '@mikro-orm/core';
import { Group } from './group.entity';

@Entity()
export class Catalog {
  @PrimaryKey()
  id!: string;

  @Property({ length: 1000 })
  title!: string;

  @Property()
  version!: string;

  @Property()
  lastModified!: Date;

  @OneToMany(() => Group, g => g.catalog)
  groups = new Collection<Group>(this);

  constructor(id: string, title: string, version: string, lastModified: Date) {
    this.id = id;
    this.title = title;
    this.version = version;
    this.lastModified = lastModified;
  }
}

================
File: entities/client-user.entity.ts
================
import { Entity, Property, Collection, OneToMany, Enum, ManyToOne, BeforeUpdate, BeforeCreate, ValidationError } from '@mikro-orm/core';
import { BaseEntity } from './base.entity';
import { Asset } from './asset.entity';
import { Approval } from './approval.entity';
import { Incident } from './incident.entity';
import { AuditLog } from './audit-log.entity';
import { Organization } from './organization.entity';
import { ClientRole } from '../common/enums/client-role.enum';
import { OrganizationRole } from '../common/enums/organization-role.enum';
@Entity()
export class ClientUser extends BaseEntity {
    @Property({ unique: true })
    email!: string;
    @Property()
    password!: string;
    @Property()
    firstName!: string;
    @Property()
    lastName!: string;
    @Property()
    isActive: boolean = true;
    @Property({ nullable: true })
    lastLogin?: Date;
    @Enum(() => ClientRole)
    clientRole!: ClientRole;
    @Enum(() => OrganizationRole)
    organizationRole?: OrganizationRole;
    @ManyToOne(() => Organization)
    organization!: Organization;
    // Relations
    @OneToMany(() => Asset, asset => asset.createdBy)
    createdAssets = new Collection<Asset>(this);
    @OneToMany(() => Approval, approval => approval.approver)
    approvals = new Collection<Approval>(this);
    @OneToMany(() => Incident, incident => incident.reporter)
    reportedIncidents = new Collection<Incident>(this);
    @OneToMany(() => Incident, incident => incident.assignee)
    assignedIncidents = new Collection<Incident>(this);
    @OneToMany(() => AuditLog, auditLog => auditLog.clientUser)
    auditLogs = new Collection<AuditLog>(this);
    // Virtual property for full name
    @Property({ persist: false })
    get fullName(): string {
        return `${this.firstName} ${this.lastName}`;
    }
    // Helper method to validate role mapping
    validateRoleMapping(): boolean {
        const validMappings = {
            [ClientRole.ADMIN]: OrganizationRole.ISSM,
            [ClientRole.MANAGER]: OrganizationRole.ISSO,
            [ClientRole.PM]: OrganizationRole.PM,
            [ClientRole.USER]: null,
        };
        if (this.clientRole === ClientRole.USER) {
            return this.organizationRole === null;
        }
        return validMappings[this.clientRole] === this.organizationRole;
    }
    @BeforeCreate()
    @BeforeUpdate()
    validateRoles() {
        if (!this.validateRoleMapping()) {
            throw new ValidationError("Invalid role mapping. The client role and organization role combination is not allowed.");
        }
        if (this.clientRole === ClientRole.USER && this.organizationRole !== null) {
            throw new ValidationError("User role cannot have an organization role.");
        }
        if (this.clientRole !== ClientRole.USER && !this.organizationRole) {
            throw new ValidationError("Non-user roles must have an organization role.");
        }
    }
}

================
File: entities/continuity-plan.entity.ts
================
import { Entity, Property, ManyToOne, OneToMany, Collection } from '@mikro-orm/core';
import { BaseEntity } from './base.entity';
import { Organization } from './organization.entity';
@Entity()
export class ContinuityPlan extends BaseEntity {
    @ManyToOne(() => Organization)
    organization!: Organization;
    @Property()
    title!: string;
    @Property()
    version!: string;
    @Property()
    status!: string; // Draft, Active, Archived
    @Property()
    reviewDate!: Date;
    @Property()
    nextReviewDate!: Date;
    @Property({ type: "json" })
    content!: any; // Structured content
    // Relations
    @OneToMany("Approval", "continuityPlan")
    approvals = new Collection<any>(this);
}

================
File: entities/control-artifact.entity.ts
================
import { Entity, Property, ManyToOne, Unique } from '@mikro-orm/core';
import { BaseEntity } from './base.entity';
import { ControlAssessment } from './control-assessment.entity';
import { Artifact } from './artifact.entity';
@Entity()
@Unique({ properties: ["control", "artifact"] })
export class ControlArtifact extends BaseEntity {
    @ManyToOne(() => ControlAssessment)
    control!: ControlAssessment;
    @ManyToOne(() => Artifact)
    artifact!: Artifact;
    @Property()
    association!: string; // e.g., "primary", "supporting", "implementation", etc.
    @Property({ nullable: true })
    notes?: string;
}

================
File: entities/control-assessment.entity.ts
================
import { Entity, Property, Enum, ManyToOne, OneToMany, Collection } from '@mikro-orm/core';
import { ControlStatus } from '../enums/ato.enum';
import { BaseEntity } from './base.entity';
import { ATOPackage } from './ato-package.entity';
@Entity()
export class ControlAssessment extends BaseEntity {
    @ManyToOne(() => ATOPackage)
    atoPackage!: ATOPackage;
    @Property()
    controlId!: string; // e.g., AC-1, SC-7
    @Property()
    title!: string;
    @Property({ nullable: true })
    description?: string;
    @Enum(() => ControlStatus)
    status: ControlStatus = ControlStatus.NOT_IMPLEMENTED;
    @Property({ nullable: true })
    implementationStatus?: string;
    @Property({ type: "json", nullable: true })
    testResults?: any; // Structured test results
    @Property({ nullable: true })
    testedDate?: Date;
    // Relations
    @OneToMany("Document", "control")
    documents = new Collection<any>(this);
    @OneToMany("ControlArtifact", "control")
    artifacts = new Collection<any>(this);
    @OneToMany("Approval", "controlAssessment")
    approvals = new Collection<any>(this);
}

================
File: entities/control-link.entity.ts
================
import { Entity, PrimaryKey, Property, ManyToOne } from '@mikro-orm/core';
import { Control } from './control.entity';

@Entity()
export class ControlLink {
  @PrimaryKey()
  id!: string;

  @ManyToOne(() => Control)
  sourceControl!: Control;

  @ManyToOne(() => Control)
  targetControl!: Control;

  @Property()
  rel!: string;

  @Property({ nullable: true })
  href!: string;

  constructor(id: string, sourceControl: Control, targetControl: Control, rel: string, href: string) {
    this.id = id;
    this.sourceControl = sourceControl;
    this.targetControl = targetControl;
    this.rel = rel;
    this.href = href;
  }
}

================
File: entities/control.entity.ts
================
import { Entity, PrimaryKey, Property, ManyToOne, OneToMany, Collection } from '@mikro-orm/core';
import { Group } from './group.entity';
import { Part } from './part.entity';
import { Parameter } from './parameter.entity';
import { ControlLink } from './control-link.entity';

@Entity()
export class Control {
  @PrimaryKey()
  id!: string;

  @Property({ length: 1000 })
  title!: string;

  @Property({ length: 500 })
  class!: string;

  @ManyToOne(() => Group)
  group!: Group;

  @ManyToOne(() => Control, { nullable: true })
  baseControl?: Control;

  @OneToMany(() => Control, control => control.baseControl)
  enhancements = new Collection<Control>(this);

  @OneToMany(() => Part, p => p.control)
  parts = new Collection<Part>(this);

  @OneToMany(() => Parameter, p => p.control)
  parameters = new Collection<Parameter>(this);

  @OneToMany(() => ControlLink, link => link.sourceControl)
  outgoingLinks = new Collection<ControlLink>(this);

  @OneToMany(() => ControlLink, link => link.targetControl)
  incomingLinks = new Collection<ControlLink>(this);

  constructor(id: string, title: string, className: string, group: Group, baseControl?: Control) {
    this.id = id;
    this.title = title;
    this.class = className;
    this.group = group;
    if (baseControl) {
      this.baseControl = baseControl;
    }
  }
}

================
File: entities/document.entity.ts
================
import { Entity, Property, Enum, ManyToOne, OneToMany, Collection } from '@mikro-orm/core';
import { DocumentType } from '../enums/ato.enum';
import { ApprovalStatus } from '../enums/artifact.enum';
import { BaseEntity } from './base.entity';
import { ControlAssessment } from './control-assessment.entity';
@Entity()
export class Document extends BaseEntity {
    @ManyToOne(() => ControlAssessment)
    control!: ControlAssessment;
    @Enum(() => DocumentType)
    type!: DocumentType;
    @Property()
    title!: string;
    @Property({ nullable: true })
    description?: string;
    @Property()
    version!: string;
    @Property()
    fileUrl!: string; // S3 or file system URL
    @Property({ nullable: true })
    mimeType?: string;
    @Property({ nullable: true })
    fileSize?: number;
    @Enum(() => ApprovalStatus)
    status: ApprovalStatus = ApprovalStatus.PENDING;
    @Property({ type: "json", nullable: true })
    metadata?: any; // Additional metadata
    // Relations
    @OneToMany("Approval", "document")
    approvals = new Collection<any>(this);
}

================
File: entities/group.entity.ts
================
import { Entity, PrimaryKey, Property, ManyToOne, OneToMany, Collection } from '@mikro-orm/core';
import { Catalog } from './catalog.entity';
import { Control } from './control.entity';

@Entity()
export class Group {
  @PrimaryKey()
  id!: string;

  @Property({ length: 1000 })
  title!: string;

  @Property({ length: 500 })
  class!: string;

  @ManyToOne(() => Catalog)
  catalog!: Catalog;

  @OneToMany(() => Control, c => c.group)
  controls = new Collection<Control>(this);

  constructor(id: string, title: string, className: string, catalog: Catalog) {
    this.id = id;
    this.title = title;
    this.class = className;
    this.catalog = catalog;
  }
}

================
File: entities/incident.entity.ts
================
import { Entity, Property, Enum, ManyToOne, ManyToMany, Collection } from '@mikro-orm/core';
import { IncidentSeverity, IncidentStatus } from '../enums/incident.enum';
import { BaseEntity } from './base.entity';
import { Organization } from './organization.entity';
import { ClientUser } from './client-user.entity';
import { Asset } from './asset.entity';
@Entity()
export class Incident extends BaseEntity {
    @ManyToOne(() => Organization)
    organization!: Organization;
    @Property()
    title!: string;
    @Property()
    description!: string;
    @Enum(() => IncidentSeverity)
    severity!: IncidentSeverity;
    @Enum(() => IncidentStatus)
    status: IncidentStatus = IncidentStatus.OPEN;
    @ManyToOne(() => ClientUser)
    reporter!: ClientUser;
    @ManyToOne(() => ClientUser, { nullable: true })
    assignee?: ClientUser;
    @Property({ nullable: true })
    resolution?: string;
    @Property({ nullable: true })
    resolvedDate?: Date;
    // Relations
    @ManyToMany(() => Asset)
    affectedAssets = new Collection<Asset>(this);
}

================
File: entities/mitigation-priority.entity.ts
================
import { Entity, Property, ManyToOne, Enum } from '@mikro-orm/core';
import { BaseEntity } from './base.entity';
import { Organization } from './organization.entity';
import { TimeFrame } from '../enums/risk.enum';
@Entity()
export class MitigationPriority extends BaseEntity {
    @Property()
    risk!: string;
    @Property()
    priority!: number;
    @Property({ type: "text" })
    strategy!: string;
    @Property()
    timeline!: string;
    @Enum(() => TimeFrame)
    timeframe!: TimeFrame;
    @Property()
    riskArea!: string;
    @Property()
    successCriteria!: string;
    @Property()
    resources!: string;
    @Property()
    estimatedCost!: string;
    @Property()
    responsibleParty!: string;
    @ManyToOne(() => Organization)
    organization!: Organization;
}

================
File: entities/organization-audit-log.entity.ts
================
import { Entity, Property, ManyToOne, PrimaryKey, Enum } from '@mikro-orm/core';
import { Organization } from './organization.entity';
import { SystemUser } from './system-user.entity';
import { ClientUser } from './client-user.entity';
export enum OrganizationAction {
    CREATED = "created",
    UPDATED = "updated",
    DELETED = "deleted",
    USER_ADDED = "user_added",
    USER_REMOVED = "user_removed",
    STATUS_CHANGED = "status_changed"
}
@Entity()
export class OrganizationAuditLog {
    @PrimaryKey()
    id!: string;
    @ManyToOne(() => Organization, { nullable: true })
    organization?: Organization;
    @Property()
    organizationId: string;
    @Property()
    organizationName: string;
    @ManyToOne(() => SystemUser, { nullable: true })
    systemUser?: SystemUser;
    @ManyToOne(() => ClientUser, { nullable: true })
    clientUser?: ClientUser;
    @Property()
    performedById: string;
    @Property()
    performedByEmail: string;
    @Enum(() => OrganizationAction)
    action!: OrganizationAction;
    @Property({ type: "jsonb" })
    changes: Record<string, any>;
    @Property()
    ipAddress: string;
    @Property()
    userAgent: string;
    @Property()
    timestamp: Date = new Date();
}

================
File: entities/organization.entity.ts
================
import { Entity, Property, Enum, OneToMany, Collection, OneToOne } from '@mikro-orm/core';
import { OrgType } from '../enums/organization.enum';
import { BaseEntity } from './base.entity';
import { RiskProfile } from './risk-profile.entity';
import { QuantitativeRisk } from './quantitative-risk.entity';
import { RiskMatrixEntry } from './risk-matrix-entry.entity';
import { MitigationPriority } from './mitigation-priority.entity';
@Entity()
export class Organization extends BaseEntity {
    @Property()
    name!: string;
    @Enum(() => OrgType)
    type!: OrgType;
    @Property({ nullable: true })
    description?: string;
    @Property()
    isActive: boolean = true;
    @Property()
    isServiceProvider: boolean = false;
    // Contact Information
    @Property({ nullable: true })
    primaryContact?: string;
    @Property({ nullable: true })
    email?: string;
    @Property({ nullable: true })
    phone?: string;
    @Property({ nullable: true })
    address?: string;
    // Risk Management Relations
    @OneToOne(() => RiskProfile, rp => rp.organization, {
        nullable: true,
        orphanRemoval: true
    })
    riskProfile?: RiskProfile;
    @OneToMany(() => QuantitativeRisk, qr => qr.organization, {
        orphanRemoval: true
    })
    quantitativeRisks = new Collection<QuantitativeRisk>(this);
    @OneToMany(() => RiskMatrixEntry, rme => rme.organization, {
        orphanRemoval: true
    })
    riskMatrix = new Collection<RiskMatrixEntry>(this);
    @OneToMany(() => MitigationPriority, mp => mp.organization, {
        orphanRemoval: true
    })
    mitigationPriorities = new Collection<MitigationPriority>(this);
    // Other Relations
    @OneToMany("UserOrganization", "organization", {
        orphanRemoval: true
    })
    users = new Collection<any>(this);
    @OneToMany("ServiceProviderClient", "provider", {
        orphanRemoval: true
    })
    clients = new Collection<any>(this);
    @OneToMany("ServiceProviderClient", "client", {
        orphanRemoval: true
    })
    providers = new Collection<any>(this);
    @OneToMany("System", "organization", {
        orphanRemoval: true
    })
    systems = new Collection<any>(this);
    @OneToMany("Incident", "organization", {
        orphanRemoval: true
    })
    incidents = new Collection<any>(this);
    @OneToMany("ContinuityPlan", "organization", {
        orphanRemoval: true
    })
    continuityPlans = new Collection<any>(this);
    @OneToMany("POAM", "organization", {
        orphanRemoval: true
    })
    poams = new Collection<any>(this);
    @OneToMany("AuditLog", "organization", {
        orphanRemoval: true
    })
    auditLogs = new Collection<any>(this);
    @OneToMany("Artifact", "organization", {
        orphanRemoval: true
    })
    artifacts = new Collection<any>(this);
}

================
File: entities/parameter.entity.ts
================
import { Entity, PrimaryKey, Property, ManyToOne } from '@mikro-orm/core';
import { Control } from './control.entity';

@Entity()
export class Parameter {
  @PrimaryKey()
  id!: string;

  @Property({ length: 1000 })
  label!: string;

  @ManyToOne(() => Control)
  control!: Control;

  constructor(id: string, label: string, control: Control) {
    this.id = id;
    this.label = label;
    this.control = control;
  }
}

================
File: entities/part.entity.ts
================
import { Entity, PrimaryKey, Property, ManyToOne, OneToMany, Collection } from '@mikro-orm/core';
import { Control } from './control.entity';

@Entity()
export class Part {
  @PrimaryKey()
  id!: string;

  @Property()
  name!: string;

  @Property({ type: 'text', nullable: true })  // Use text type for unlimited length
  prose?: string;

  @ManyToOne(() => Control)
  control!: Control;

  @ManyToOne(() => Part, { nullable: true })
  parent?: Part;

  @OneToMany(() => Part, p => p.parent)
  children = new Collection<Part>(this);

  constructor(id: string, name: string, prose: string, control: Control, parent?: Part) {
    this.id = id;
    this.name = name;
    this.prose = prose;
    this.control = control;
    this.parent = parent;
  }
}

================
File: entities/poam.entity.ts
================
import { Entity, Property, ManyToOne, OneToMany, Collection } from '@mikro-orm/core';
import { BaseEntity } from './base.entity';
import { Organization } from './organization.entity';
@Entity()
export class POAM extends BaseEntity {
    @ManyToOne(() => Organization)
    organization!: Organization;
    @Property()
    finding!: string;
    @Property()
    recommendation!: string;
    @Property()
    priority!: string; // High, Medium, Low
    @Property()
    status!: string; // Open, In Progress, Completed
    @Property()
    targetDate!: Date;
    @Property({ nullable: true })
    completionDate?: Date;
    @Property()
    responsibleParty!: string;
    @Property()
    mitigationPlan!: string;
    @Property({ nullable: true })
    residualRisk?: string;
    // Relations
    @OneToMany("Approval", "poam")
    approvals = new Collection<any>(this);
}

================
File: entities/port-mapping.entity.ts
================
import { Entity, Property, ManyToOne } from '@mikro-orm/core';
import { BaseEntity } from './base.entity';
import { Asset } from './asset.entity';
@Entity()
export class PortMapping extends BaseEntity {
    @ManyToOne(() => Asset)
    asset!: Asset;
    @Property()
    port!: number;
    @Property()
    protocol!: string; // TCP, UDP
    @Property()
    service!: string;
    @Property({ nullable: true })
    description?: string;
    @Property()
    status!: string; // Active, Inactive
    @Property({ nullable: true })
    lastScan?: Date;
}

================
File: entities/quantitative-risk.entity.ts
================
import { Entity, Property, ManyToOne, Enum } from '@mikro-orm/core';
import { BaseEntity } from './base.entity';
import { Organization } from './organization.entity';
@Entity()
export class QuantitativeRisk extends BaseEntity {
    @Property()
    annualLoss!: number;
    @Property()
    probabilityOfOccurrence!: number;
    @Property()
    impactScore!: number;
    @Property()
    riskScore!: number;
    @ManyToOne(() => Organization)
    organization!: Organization;
}

================
File: entities/risk-matrix-entry.entity.ts
================
import { Entity, Property, ManyToOne, Enum } from '@mikro-orm/core';
import { BaseEntity } from './base.entity';
import { Organization } from './organization.entity';
@Entity()
export class RiskMatrixEntry extends BaseEntity {
    @Property()
    impact!: number;
    @Property()
    likelihood!: number;
    @Property()
    value!: number;
    @ManyToOne(() => Organization)
    organization!: Organization;
}

================
File: entities/risk-profile.entity.ts
================
import { Entity, Property, OneToOne, Enum } from '@mikro-orm/core';
import { BaseEntity } from './base.entity';
import { Organization } from './organization.entity';
import { RiskLevel } from '../enums/risk.enum';
@Entity()
export class RiskProfile extends BaseEntity {
    @Property({ type: "text" })
    businessFunctions!: string;
    @Property({ type: "text" })
    keyAssets!: string;
    @Property({ type: "array" })
    complianceFrameworks: string[] = [];
    @Property({ type: "array" })
    dataTypes: string[] = [];
    @Enum(() => RiskLevel)
    operationalRisk!: RiskLevel;
    @Enum(() => RiskLevel)
    dataSecurityRisk!: RiskLevel;
    @Enum(() => RiskLevel)
    complianceRisk!: RiskLevel;
    @Enum(() => RiskLevel)
    financialRisk!: RiskLevel;
    @OneToOne(() => Organization, org => org.riskProfile, { owner: true })
    organization!: Organization;
}

================
File: entities/service-provider-client.entity.ts
================
import { Entity, Property, ManyToOne, Unique } from '@mikro-orm/core';
import { BaseEntity } from './base.entity';
import { Organization } from './organization.entity';
@Entity()
@Unique({ properties: ["provider", "client"] })
export class ServiceProviderClient extends BaseEntity {
    @ManyToOne(() => Organization, { mapToPk: true })
    provider!: Organization;
    @ManyToOne(() => Organization, { mapToPk: true })
    client!: Organization;
    @Property()
    status!: string; // Active, Pending, Terminated
    @Property()
    startDate: Date = new Date();
    @Property({ nullable: true })
    endDate?: Date;
    @Property({ nullable: true })
    contractDetails?: string;
}

================
File: entities/system-user.entity.ts
================
import { Entity, Property, Enum, Collection, OneToMany } from '@mikro-orm/core';
import { SystemRole } from '../common/enums/system-role.enum';
import { BaseEntity } from './base.entity';
import { AuditLog } from './audit-log.entity';
import { UserOrganization } from './user-organization.entity';
@Entity()
export class SystemUser extends BaseEntity {
    @Property({ unique: true })
    email!: string;
    @Property()
    password!: string;
    @Property()
    firstName!: string;
    @Property()
    lastName!: string;
    @Enum(() => SystemRole)
    role: SystemRole = SystemRole.ADMIN;
    @Property()
    isActive: boolean = true;
    @Property({ nullable: true })
    lastLogin?: Date;
    // Relations
    @OneToMany(() => AuditLog, auditLog => auditLog.systemUser)
    auditLogs = new Collection<AuditLog>(this);
    @OneToMany(() => UserOrganization, userOrg => userOrg.systemUser)
    organizations = new Collection<UserOrganization>(this);
    // Helper methods
    isGlobalAdmin(): boolean {
        return this.role === SystemRole.GLOBAL_ADMIN;
    }
    isAdmin(): boolean {
        return this.role === SystemRole.ADMIN;
    }
}

================
File: entities/system.entity.ts
================
import { Entity, Property, Enum, ManyToOne, OneToMany, Collection } from '@mikro-orm/core';
import { SystemType, SystemCriticality, SystemStatus } from '../enums/system.enum';
import { BaseEntity } from './base.entity';
import { Organization } from './organization.entity';
@Entity()
export class System extends BaseEntity {
    @ManyToOne(() => Organization)
    organization!: Organization;
    @Property()
    name!: string;
    @Property({ nullable: true })
    description?: string;
    @Enum(() => SystemType)
    systemType!: SystemType;
    @Enum(() => SystemCriticality)
    criticality!: SystemCriticality;
    @Enum(() => SystemStatus)
    status: SystemStatus = SystemStatus.ACTIVE;
    // System Details
    @Property({ nullable: true })
    owner?: string;
    @Property({ nullable: true })
    custodian?: string;
    @Property({ nullable: true })
    boundaries?: string;
    @Property({ nullable: true })
    location?: string;
    // Relations
    @OneToMany("ATOPackage", "system")
    atoPackages = new Collection<any>(this);
    @OneToMany("Asset", "system")
    assets = new Collection<any>(this);
}

================
File: entities/user-organization.entity.ts
================
import { Entity, ManyToOne, Property } from '@mikro-orm/core';
import { BaseEntity } from './base.entity';
import { Organization } from './organization.entity';
import { SystemUser } from './system-user.entity';
import { ClientUser } from './client-user.entity';
@Entity()
export class UserOrganization extends BaseEntity {
    @ManyToOne(() => Organization)
    organization!: Organization;
    @ManyToOne(() => SystemUser, { nullable: true })
    systemUser?: SystemUser;
    @ManyToOne(() => ClientUser, { nullable: true })
    clientUser?: ClientUser;
    @Property()
    isActive: boolean = true;
    // Helper method to get the associated user (either system or client)
    getUser(): SystemUser | ClientUser | undefined {
        return this.systemUser || this.clientUser;
    }
    // Helper method to get the user's email
    getUserEmail(): string | undefined {
        const user = this.getUser();
        return user?.email;
    }
    // Helper method to get the user's full name
    getUserFullName(): string | undefined {
        const user = this.getUser();
        if (!user)
            return undefined;
        return `${user.firstName} ${user.lastName}`;
    }
}

================
File: enums/artifact.enum.ts
================
export enum ArtifactType {
    POLICY = "POLICY",
    PROCEDURE = "PROCEDURE",
    DOCUMENTATION = "DOCUMENTATION",
    SCAN_RESULT = "SCAN_RESULT",
    CONFIGURATION = "CONFIGURATION",
    TRAINING = "TRAINING",
    AUDIT_LOG = "AUDIT_LOG",
    EVIDENCE = "EVIDENCE",
    OTHER = "OTHER"
}
export enum ArtifactStatus {
    DRAFT = "DRAFT",
    IN_REVIEW = "IN_REVIEW",
    APPROVED = "APPROVED",
    ARCHIVED = "ARCHIVED",
    REJECTED = "REJECTED"
}
export enum ApprovalStatus {
    PENDING = "PENDING",
    APPROVED = "APPROVED",
    REJECTED = "REJECTED",
    NEEDS_WORK = "NEEDS_WORK"
}

================
File: enums/ato.enum.ts
================
export enum ATOStatus {
    DRAFT = "DRAFT",
    IN_PROGRESS = "IN_PROGRESS",
    UNDER_REVIEW = "UNDER_REVIEW",
    APPROVED = "APPROVED",
    REJECTED = "REJECTED",
    EXPIRED = "EXPIRED"
}
export enum ATOPhase {
    PREPARATION = "PREPARATION",
    INITIAL_ASSESSMENT = "INITIAL_ASSESSMENT",
    CONTROL_IMPLEMENTATION = "CONTROL_IMPLEMENTATION",
    TESTING = "TESTING",
    VALIDATION = "VALIDATION",
    FINAL_REVIEW = "FINAL_REVIEW",
    AUTHORIZATION = "AUTHORIZATION",
    MONITORING = "MONITORING"
}
export enum DocumentType {
    SSP = "SSP",// System Security Plan
    RAR = "RAR",// Risk Assessment Report
    SAR = "SAR",// Security Assessment Report
    SAP = "SAP",// Security Assessment Plan
    POA_M = "POA_M",// Plan of Action & Milestones
    EVIDENCE = "EVIDENCE",// Control Implementation Evidence
    POLICY = "POLICY",
    PROCEDURE = "PROCEDURE",
    CONFIGURATION = "CONFIGURATION",
    TEST_RESULT = "TEST_RESULT",
    OTHER = "OTHER"
}
export enum ControlStatus {
    NOT_IMPLEMENTED = "NOT_IMPLEMENTED",
    PLANNED = "PLANNED",
    PARTIALLY_IMPLEMENTED = "PARTIALLY_IMPLEMENTED",
    IMPLEMENTED = "IMPLEMENTED",
    NOT_APPLICABLE = "NOT_APPLICABLE"
}

================
File: enums/incident.enum.ts
================
export enum IncidentSeverity {
    CRITICAL = "CRITICAL",
    HIGH = "HIGH",
    MEDIUM = "MEDIUM",
    LOW = "LOW"
}
export enum IncidentStatus {
    OPEN = "OPEN",
    INVESTIGATING = "INVESTIGATING",
    MITIGATING = "MITIGATING",
    RESOLVED = "RESOLVED",
    CLOSED = "CLOSED"
}

================
File: enums/organization.enum.ts
================
export enum OrgType {
    SERVICE_PROVIDER = "PROVIDER",
    CLIENT = "CLIENT"
}

================
File: enums/risk.enum.ts
================
export enum RiskLevel {
    LOW = "LOW",
    MEDIUM = "MEDIUM",
    HIGH = "HIGH",
    CRITICAL = "CRITICAL"
}
export enum TimeFrame {
    IMMEDIATE = "IMMEDIATE",
    SHORT_TERM = "SHORT_TERM",
    MEDIUM_TERM = "MEDIUM_TERM",
    LONG_TERM = "LONG_TERM"
}

================
File: enums/system.enum.ts
================
export enum SystemType {
    WEB_APPLICATION = "WEB_APPLICATION",
    NETWORK_SYSTEM = "NETWORK_SYSTEM",
    DATABASE_SYSTEM = "DATABASE_SYSTEM",
    CLOUD_SERVICE = "CLOUD_SERVICE",
    LEGACY_SYSTEM = "LEGACY_SYSTEM",
    OTHER = "OTHER"
}
export enum SystemCriticality {
    HIGH = "HIGH",
    MODERATE = "MODERATE",
    LOW = "LOW"
}
export enum SystemStatus {
    ACTIVE = "ACTIVE",
    INACTIVE = "INACTIVE",
    DECOMMISSIONED = "DECOMMISSIONED",
    UNDER_DEVELOPMENT = "UNDER_DEVELOPMENT"
}

================
File: main.ts
================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import * as compression from 'compression';
import helmet from 'helmet';
import { ValidationPipe } from '@nestjs/common';
async function bootstrap() {
    const app = await NestFactory.create(AppModule);
    // Enable CORS with explicit headers
    app.enableCors({
        origin: ["http://localhost:3000"],
        credentials: true,
        allowedHeaders: ["Content-Type", "Authorization", "Accept"],
        methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"],
        exposedHeaders: ["Authorization"],
        preflightContinue: false,
        optionsSuccessStatus: 204,
    });
    // Security middleware
    app.use(helmet());
    app.use(compression());
    // Global validation pipe
    app.useGlobalPipes(new ValidationPipe({
        whitelist: true,
        transform: true,
        forbidNonWhitelisted: true,
    }));
    // Global prefix for all routes
    app.setGlobalPrefix("api");
    await app.listen(process.env.PORT ?? 3001);
}
bootstrap();

================
File: migrations/.snapshot-securecenter_v1.json
================
{
  "namespaces": [
    "public"
  ],
  "name": "public",
  "tables": [
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "title": {
          "name": "title",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "version": {
          "name": "version",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "last_modified": {
          "name": "last_modified",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        }
      },
      "name": "catalog",
      "schema": "public",
      "indexes": [
        {
          "keyName": "catalog_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {},
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "title": {
          "name": "title",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "class": {
          "name": "class",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "catalog_id": {
          "name": "catalog_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "group",
      "schema": "public",
      "indexes": [
        {
          "keyName": "group_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "group_catalog_id_foreign": {
          "constraintName": "group_catalog_id_foreign",
          "columnNames": [
            "catalog_id"
          ],
          "localTableName": "public.group",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.catalog",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "title": {
          "name": "title",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "class": {
          "name": "class",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "group_id": {
          "name": "group_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "control",
      "schema": "public",
      "indexes": [
        {
          "keyName": "control_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "control_group_id_foreign": {
          "constraintName": "control_group_id_foreign",
          "columnNames": [
            "group_id"
          ],
          "localTableName": "public.control",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.group",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "name": {
          "name": "name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "type": {
          "name": "type",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "PROVIDER",
            "CLIENT"
          ],
          "mappedType": "enum"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "is_active": {
          "name": "is_active",
          "type": "boolean",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "true",
          "mappedType": "boolean"
        },
        "is_service_provider": {
          "name": "is_service_provider",
          "type": "boolean",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "false",
          "mappedType": "boolean"
        },
        "primary_contact": {
          "name": "primary_contact",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "phone": {
          "name": "phone",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "address": {
          "name": "address",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "organization",
      "schema": "public",
      "indexes": [
        {
          "keyName": "organization_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {},
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "risk": {
          "name": "risk",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "priority": {
          "name": "priority",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "strategy": {
          "name": "strategy",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "text"
        },
        "timeline": {
          "name": "timeline",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "timeframe": {
          "name": "timeframe",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "IMMEDIATE",
            "SHORT_TERM",
            "MEDIUM_TERM",
            "LONG_TERM"
          ],
          "mappedType": "enum"
        },
        "risk_area": {
          "name": "risk_area",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "success_criteria": {
          "name": "success_criteria",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "resources": {
          "name": "resources",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "estimated_cost": {
          "name": "estimated_cost",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "responsible_party": {
          "name": "responsible_party",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "mitigation_priority",
      "schema": "public",
      "indexes": [
        {
          "keyName": "mitigation_priority_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "mitigation_priority_organization_id_foreign": {
          "constraintName": "mitigation_priority_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.mitigation_priority",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "title": {
          "name": "title",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "version": {
          "name": "version",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "status": {
          "name": "status",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "review_date": {
          "name": "review_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "next_review_date": {
          "name": "next_review_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "content": {
          "name": "content",
          "type": "jsonb",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "json"
        }
      },
      "name": "continuity_plan",
      "schema": "public",
      "indexes": [
        {
          "keyName": "continuity_plan_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "continuity_plan_organization_id_foreign": {
          "constraintName": "continuity_plan_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.continuity_plan",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "password": {
          "name": "password",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "first_name": {
          "name": "first_name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "last_name": {
          "name": "last_name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "is_active": {
          "name": "is_active",
          "type": "boolean",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "true",
          "mappedType": "boolean"
        },
        "last_login": {
          "name": "last_login",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "client_role": {
          "name": "client_role",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "ADMIN",
            "MANAGER",
            "PM",
            "USER"
          ],
          "mappedType": "enum"
        },
        "organization_role": {
          "name": "organization_role",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "enumItems": [
            "AODR",
            "SCA",
            "SCAR",
            "AUDITOR",
            "PM",
            "ISSM",
            "ISSO"
          ],
          "mappedType": "enum"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "client_user",
      "schema": "public",
      "indexes": [
        {
          "columnNames": [
            "email"
          ],
          "composite": false,
          "keyName": "client_user_email_unique",
          "constraint": true,
          "primary": false,
          "unique": true
        },
        {
          "keyName": "client_user_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "client_user_organization_id_foreign": {
          "constraintName": "client_user_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.client_user",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "title": {
          "name": "title",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "severity": {
          "name": "severity",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "CRITICAL",
            "HIGH",
            "MEDIUM",
            "LOW"
          ],
          "mappedType": "enum"
        },
        "status": {
          "name": "status",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'OPEN'",
          "enumItems": [
            "OPEN",
            "INVESTIGATING",
            "MITIGATING",
            "RESOLVED",
            "CLOSED"
          ],
          "mappedType": "enum"
        },
        "reporter_id": {
          "name": "reporter_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "assignee_id": {
          "name": "assignee_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "resolution": {
          "name": "resolution",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "resolved_date": {
          "name": "resolved_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        }
      },
      "name": "incident",
      "schema": "public",
      "indexes": [
        {
          "keyName": "incident_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "incident_organization_id_foreign": {
          "constraintName": "incident_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.incident",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        },
        "incident_reporter_id_foreign": {
          "constraintName": "incident_reporter_id_foreign",
          "columnNames": [
            "reporter_id"
          ],
          "localTableName": "public.incident",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.client_user",
          "updateRule": "cascade"
        },
        "incident_assignee_id_foreign": {
          "constraintName": "incident_assignee_id_foreign",
          "columnNames": [
            "assignee_id"
          ],
          "localTableName": "public.incident",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.client_user",
          "deleteRule": "set null",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "name": {
          "name": "name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "type": {
          "name": "type",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "POLICY",
            "PROCEDURE",
            "DOCUMENTATION",
            "SCAN_RESULT",
            "CONFIGURATION",
            "TRAINING",
            "AUDIT_LOG",
            "EVIDENCE",
            "OTHER"
          ],
          "mappedType": "enum"
        },
        "status": {
          "name": "status",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'DRAFT'",
          "enumItems": [
            "DRAFT",
            "IN_REVIEW",
            "APPROVED",
            "ARCHIVED",
            "REJECTED"
          ],
          "mappedType": "enum"
        },
        "version": {
          "name": "version",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "file_url": {
          "name": "file_url",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "mime_type": {
          "name": "mime_type",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "file_size": {
          "name": "file_size",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "metadata": {
          "name": "metadata",
          "type": "jsonb",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "mappedType": "json"
        },
        "last_reviewed_at": {
          "name": "last_reviewed_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "expires_at": {
          "name": "expires_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "created_by": {
          "name": "created_by",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "last_reviewed_by": {
          "name": "last_reviewed_by",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "approved_by": {
          "name": "approved_by",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "artifact",
      "schema": "public",
      "indexes": [
        {
          "keyName": "artifact_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "artifact_organization_id_foreign": {
          "constraintName": "artifact_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.artifact",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "artifact_id": {
          "name": "artifact_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "version": {
          "name": "version",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "file_url": {
          "name": "file_url",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "changes": {
          "name": "changes",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "created_by": {
          "name": "created_by",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "artifact_revision",
      "schema": "public",
      "indexes": [
        {
          "keyName": "artifact_revision_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "artifact_revision_artifact_id_foreign": {
          "constraintName": "artifact_revision_artifact_id_foreign",
          "columnNames": [
            "artifact_id"
          ],
          "localTableName": "public.artifact_revision",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.artifact",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "label": {
          "name": "label",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "control_id": {
          "name": "control_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "parameter",
      "schema": "public",
      "indexes": [
        {
          "keyName": "parameter_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "parameter_control_id_foreign": {
          "constraintName": "parameter_control_id_foreign",
          "columnNames": [
            "control_id"
          ],
          "localTableName": "public.parameter",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.control",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "name": {
          "name": "name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "prose": {
          "name": "prose",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "control_id": {
          "name": "control_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "parent_id": {
          "name": "parent_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "part",
      "schema": "public",
      "indexes": [
        {
          "keyName": "part_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "part_control_id_foreign": {
          "constraintName": "part_control_id_foreign",
          "columnNames": [
            "control_id"
          ],
          "localTableName": "public.part",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.control",
          "updateRule": "cascade"
        },
        "part_parent_id_foreign": {
          "constraintName": "part_parent_id_foreign",
          "columnNames": [
            "parent_id"
          ],
          "localTableName": "public.part",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.part",
          "deleteRule": "set null",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "finding": {
          "name": "finding",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "recommendation": {
          "name": "recommendation",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "priority": {
          "name": "priority",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "status": {
          "name": "status",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "target_date": {
          "name": "target_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "completion_date": {
          "name": "completion_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "responsible_party": {
          "name": "responsible_party",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "mitigation_plan": {
          "name": "mitigation_plan",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "residual_risk": {
          "name": "residual_risk",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "poam",
      "schema": "public",
      "indexes": [
        {
          "keyName": "poam_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "poam_organization_id_foreign": {
          "constraintName": "poam_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.poam",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "annual_loss": {
          "name": "annual_loss",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "probability_of_occurrence": {
          "name": "probability_of_occurrence",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "impact_score": {
          "name": "impact_score",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "risk_score": {
          "name": "risk_score",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "quantitative_risk",
      "schema": "public",
      "indexes": [
        {
          "keyName": "quantitative_risk_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "quantitative_risk_organization_id_foreign": {
          "constraintName": "quantitative_risk_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.quantitative_risk",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "impact": {
          "name": "impact",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "likelihood": {
          "name": "likelihood",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "value": {
          "name": "value",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "risk_matrix_entry",
      "schema": "public",
      "indexes": [
        {
          "keyName": "risk_matrix_entry_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "risk_matrix_entry_organization_id_foreign": {
          "constraintName": "risk_matrix_entry_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.risk_matrix_entry",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "business_functions": {
          "name": "business_functions",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "text"
        },
        "key_assets": {
          "name": "key_assets",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "text"
        },
        "compliance_frameworks": {
          "name": "compliance_frameworks",
          "type": "text[]",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "array"
        },
        "data_types": {
          "name": "data_types",
          "type": "text[]",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "array"
        },
        "operational_risk": {
          "name": "operational_risk",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "LOW",
            "MEDIUM",
            "HIGH",
            "CRITICAL"
          ],
          "mappedType": "enum"
        },
        "data_security_risk": {
          "name": "data_security_risk",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "LOW",
            "MEDIUM",
            "HIGH",
            "CRITICAL"
          ],
          "mappedType": "enum"
        },
        "compliance_risk": {
          "name": "compliance_risk",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "LOW",
            "MEDIUM",
            "HIGH",
            "CRITICAL"
          ],
          "mappedType": "enum"
        },
        "financial_risk": {
          "name": "financial_risk",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "LOW",
            "MEDIUM",
            "HIGH",
            "CRITICAL"
          ],
          "mappedType": "enum"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "risk_profile",
      "schema": "public",
      "indexes": [
        {
          "columnNames": [
            "organization_id"
          ],
          "composite": false,
          "keyName": "risk_profile_organization_id_unique",
          "constraint": true,
          "primary": false,
          "unique": true
        },
        {
          "keyName": "risk_profile_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "risk_profile_organization_id_foreign": {
          "constraintName": "risk_profile_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.risk_profile",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "provider_id": {
          "name": "provider_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "client_id": {
          "name": "client_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "status": {
          "name": "status",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "start_date": {
          "name": "start_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "end_date": {
          "name": "end_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "contract_details": {
          "name": "contract_details",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "service_provider_client",
      "schema": "public",
      "indexes": [
        {
          "keyName": "service_provider_client_provider_id_client_id_unique",
          "columnNames": [
            "provider_id",
            "client_id"
          ],
          "composite": true,
          "constraint": true,
          "primary": false,
          "unique": true
        },
        {
          "keyName": "service_provider_client_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "service_provider_client_provider_id_foreign": {
          "constraintName": "service_provider_client_provider_id_foreign",
          "columnNames": [
            "provider_id"
          ],
          "localTableName": "public.service_provider_client",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        },
        "service_provider_client_client_id_foreign": {
          "constraintName": "service_provider_client_client_id_foreign",
          "columnNames": [
            "client_id"
          ],
          "localTableName": "public.service_provider_client",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "name": {
          "name": "name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "system_type": {
          "name": "system_type",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "WEB_APPLICATION",
            "NETWORK_SYSTEM",
            "DATABASE_SYSTEM",
            "CLOUD_SERVICE",
            "LEGACY_SYSTEM",
            "OTHER"
          ],
          "mappedType": "enum"
        },
        "criticality": {
          "name": "criticality",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "HIGH",
            "MODERATE",
            "LOW"
          ],
          "mappedType": "enum"
        },
        "status": {
          "name": "status",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'ACTIVE'",
          "enumItems": [
            "ACTIVE",
            "INACTIVE",
            "DECOMMISSIONED",
            "UNDER_DEVELOPMENT"
          ],
          "mappedType": "enum"
        },
        "owner": {
          "name": "owner",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "custodian": {
          "name": "custodian",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "boundaries": {
          "name": "boundaries",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "location": {
          "name": "location",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "system",
      "schema": "public",
      "indexes": [
        {
          "keyName": "system_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "system_organization_id_foreign": {
          "constraintName": "system_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.system",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "system_id": {
          "name": "system_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "name": {
          "name": "name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "framework": {
          "name": "framework",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "status": {
          "name": "status",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'DRAFT'",
          "enumItems": [
            "DRAFT",
            "IN_PROGRESS",
            "UNDER_REVIEW",
            "APPROVED",
            "REJECTED",
            "EXPIRED"
          ],
          "mappedType": "enum"
        },
        "current_phase": {
          "name": "current_phase",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'PREPARATION'",
          "enumItems": [
            "PREPARATION",
            "INITIAL_ASSESSMENT",
            "CONTROL_IMPLEMENTATION",
            "TESTING",
            "VALIDATION",
            "FINAL_REVIEW",
            "AUTHORIZATION",
            "MONITORING"
          ],
          "mappedType": "enum"
        },
        "valid_from": {
          "name": "valid_from",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "valid_until": {
          "name": "valid_until",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "last_assessment": {
          "name": "last_assessment",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "next_assessment": {
          "name": "next_assessment",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        }
      },
      "name": "atopackage",
      "schema": "public",
      "indexes": [
        {
          "keyName": "atopackage_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "atopackage_system_id_foreign": {
          "constraintName": "atopackage_system_id_foreign",
          "columnNames": [
            "system_id"
          ],
          "localTableName": "public.atopackage",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.system",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "ato_package_id": {
          "name": "ato_package_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "control_id": {
          "name": "control_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "title": {
          "name": "title",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "status": {
          "name": "status",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'NOT_IMPLEMENTED'",
          "enumItems": [
            "NOT_IMPLEMENTED",
            "PLANNED",
            "PARTIALLY_IMPLEMENTED",
            "IMPLEMENTED",
            "NOT_APPLICABLE"
          ],
          "mappedType": "enum"
        },
        "implementation_status": {
          "name": "implementation_status",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "test_results": {
          "name": "test_results",
          "type": "jsonb",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "mappedType": "json"
        },
        "tested_date": {
          "name": "tested_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        }
      },
      "name": "control_assessment",
      "schema": "public",
      "indexes": [
        {
          "keyName": "control_assessment_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "control_assessment_ato_package_id_foreign": {
          "constraintName": "control_assessment_ato_package_id_foreign",
          "columnNames": [
            "ato_package_id"
          ],
          "localTableName": "public.control_assessment",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.atopackage",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "control_id": {
          "name": "control_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "type": {
          "name": "type",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "SSP",
            "RAR",
            "SAR",
            "SAP",
            "POA_M",
            "EVIDENCE",
            "POLICY",
            "PROCEDURE",
            "CONFIGURATION",
            "TEST_RESULT",
            "OTHER"
          ],
          "mappedType": "enum"
        },
        "title": {
          "name": "title",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "version": {
          "name": "version",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "file_url": {
          "name": "file_url",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "mime_type": {
          "name": "mime_type",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "file_size": {
          "name": "file_size",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "mappedType": "integer"
        },
        "status": {
          "name": "status",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'PENDING'",
          "enumItems": [
            "PENDING",
            "APPROVED",
            "REJECTED",
            "NEEDS_WORK"
          ],
          "mappedType": "enum"
        },
        "metadata": {
          "name": "metadata",
          "type": "jsonb",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "mappedType": "json"
        }
      },
      "name": "document",
      "schema": "public",
      "indexes": [
        {
          "keyName": "document_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "document_control_id_foreign": {
          "constraintName": "document_control_id_foreign",
          "columnNames": [
            "control_id"
          ],
          "localTableName": "public.document",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.control_assessment",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "control_id": {
          "name": "control_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "artifact_id": {
          "name": "artifact_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "association": {
          "name": "association",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "notes": {
          "name": "notes",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "control_artifact",
      "schema": "public",
      "indexes": [
        {
          "keyName": "control_artifact_control_id_artifact_id_unique",
          "columnNames": [
            "control_id",
            "artifact_id"
          ],
          "composite": true,
          "constraint": true,
          "primary": false,
          "unique": true
        },
        {
          "keyName": "control_artifact_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "control_artifact_control_id_foreign": {
          "constraintName": "control_artifact_control_id_foreign",
          "columnNames": [
            "control_id"
          ],
          "localTableName": "public.control_artifact",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.control_assessment",
          "updateRule": "cascade"
        },
        "control_artifact_artifact_id_foreign": {
          "constraintName": "control_artifact_artifact_id_foreign",
          "columnNames": [
            "artifact_id"
          ],
          "localTableName": "public.control_artifact",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.artifact",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "entity_type": {
          "name": "entity_type",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "entity_id": {
          "name": "entity_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "approver_id": {
          "name": "approver_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "status": {
          "name": "status",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'PENDING'",
          "enumItems": [
            "PENDING",
            "APPROVED",
            "REJECTED",
            "NEEDS_WORK"
          ],
          "mappedType": "enum"
        },
        "comments": {
          "name": "comments",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "approved_at": {
          "name": "approved_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "document_id": {
          "name": "document_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "control_assessment_id": {
          "name": "control_assessment_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "ato_package_id": {
          "name": "ato_package_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "continuity_plan_id": {
          "name": "continuity_plan_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "poam_id": {
          "name": "poam_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "approval",
      "schema": "public",
      "indexes": [
        {
          "keyName": "approval_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "approval_approver_id_foreign": {
          "constraintName": "approval_approver_id_foreign",
          "columnNames": [
            "approver_id"
          ],
          "localTableName": "public.approval",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.client_user",
          "updateRule": "cascade"
        },
        "approval_document_id_foreign": {
          "constraintName": "approval_document_id_foreign",
          "columnNames": [
            "document_id"
          ],
          "localTableName": "public.approval",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.document",
          "deleteRule": "set null",
          "updateRule": "cascade"
        },
        "approval_control_assessment_id_foreign": {
          "constraintName": "approval_control_assessment_id_foreign",
          "columnNames": [
            "control_assessment_id"
          ],
          "localTableName": "public.approval",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.control_assessment",
          "deleteRule": "set null",
          "updateRule": "cascade"
        },
        "approval_ato_package_id_foreign": {
          "constraintName": "approval_ato_package_id_foreign",
          "columnNames": [
            "ato_package_id"
          ],
          "localTableName": "public.approval",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.atopackage",
          "deleteRule": "set null",
          "updateRule": "cascade"
        },
        "approval_continuity_plan_id_foreign": {
          "constraintName": "approval_continuity_plan_id_foreign",
          "columnNames": [
            "continuity_plan_id"
          ],
          "localTableName": "public.approval",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.continuity_plan",
          "deleteRule": "set null",
          "updateRule": "cascade"
        },
        "approval_poam_id_foreign": {
          "constraintName": "approval_poam_id_foreign",
          "columnNames": [
            "poam_id"
          ],
          "localTableName": "public.approval",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.poam",
          "deleteRule": "set null",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "system_id": {
          "name": "system_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "name": {
          "name": "name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "type": {
          "name": "type",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "status": {
          "name": "status",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_by_id": {
          "name": "created_by_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "version": {
          "name": "version",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "location": {
          "name": "location",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "purchase_date": {
          "name": "purchase_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "end_of_life": {
          "name": "end_of_life",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        }
      },
      "name": "asset",
      "schema": "public",
      "indexes": [
        {
          "keyName": "asset_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "asset_system_id_foreign": {
          "constraintName": "asset_system_id_foreign",
          "columnNames": [
            "system_id"
          ],
          "localTableName": "public.asset",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.system",
          "updateRule": "cascade"
        },
        "asset_created_by_id_foreign": {
          "constraintName": "asset_created_by_id_foreign",
          "columnNames": [
            "created_by_id"
          ],
          "localTableName": "public.asset",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.client_user",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "asset_id": {
          "name": "asset_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "port": {
          "name": "port",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "protocol": {
          "name": "protocol",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "service": {
          "name": "service",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "status": {
          "name": "status",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "last_scan": {
          "name": "last_scan",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        }
      },
      "name": "port_mapping",
      "schema": "public",
      "indexes": [
        {
          "keyName": "port_mapping_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "port_mapping_asset_id_foreign": {
          "constraintName": "port_mapping_asset_id_foreign",
          "columnNames": [
            "asset_id"
          ],
          "localTableName": "public.port_mapping",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.asset",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "incident_id": {
          "name": "incident_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "asset_id": {
          "name": "asset_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "incident_affected_assets",
      "schema": "public",
      "indexes": [
        {
          "keyName": "incident_affected_assets_pkey",
          "columnNames": [
            "incident_id",
            "asset_id"
          ],
          "composite": true,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "incident_affected_assets_incident_id_foreign": {
          "constraintName": "incident_affected_assets_incident_id_foreign",
          "columnNames": [
            "incident_id"
          ],
          "localTableName": "public.incident_affected_assets",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.incident",
          "deleteRule": "cascade",
          "updateRule": "cascade"
        },
        "incident_affected_assets_asset_id_foreign": {
          "constraintName": "incident_affected_assets_asset_id_foreign",
          "columnNames": [
            "asset_id"
          ],
          "localTableName": "public.incident_affected_assets",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.asset",
          "deleteRule": "cascade",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "password": {
          "name": "password",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "first_name": {
          "name": "first_name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "last_name": {
          "name": "last_name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "role": {
          "name": "role",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'ADMIN'",
          "enumItems": [
            "GLOBAL_ADMIN",
            "ADMIN",
            "USER"
          ],
          "mappedType": "enum"
        },
        "is_active": {
          "name": "is_active",
          "type": "boolean",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "true",
          "mappedType": "boolean"
        },
        "last_login": {
          "name": "last_login",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        }
      },
      "name": "system_user",
      "schema": "public",
      "indexes": [
        {
          "columnNames": [
            "email"
          ],
          "composite": false,
          "keyName": "system_user_email_unique",
          "constraint": true,
          "primary": false,
          "unique": true
        },
        {
          "keyName": "system_user_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {},
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "system_user_id": {
          "name": "system_user_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "client_user_id": {
          "name": "client_user_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "action": {
          "name": "action",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "entity_type": {
          "name": "entity_type",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "entity_id": {
          "name": "entity_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "details": {
          "name": "details",
          "type": "jsonb",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "json"
        },
        "ip_address": {
          "name": "ip_address",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "user_agent": {
          "name": "user_agent",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "audit_log",
      "schema": "public",
      "indexes": [
        {
          "keyName": "audit_log_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "audit_log_organization_id_foreign": {
          "constraintName": "audit_log_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.audit_log",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        },
        "audit_log_system_user_id_foreign": {
          "constraintName": "audit_log_system_user_id_foreign",
          "columnNames": [
            "system_user_id"
          ],
          "localTableName": "public.audit_log",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.system_user",
          "deleteRule": "set null",
          "updateRule": "cascade"
        },
        "audit_log_client_user_id_foreign": {
          "constraintName": "audit_log_client_user_id_foreign",
          "columnNames": [
            "client_user_id"
          ],
          "localTableName": "public.audit_log",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.client_user",
          "deleteRule": "set null",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "system_user_id": {
          "name": "system_user_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "client_user_id": {
          "name": "client_user_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "is_active": {
          "name": "is_active",
          "type": "boolean",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "true",
          "mappedType": "boolean"
        }
      },
      "name": "user_organization",
      "schema": "public",
      "indexes": [
        {
          "keyName": "user_organization_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "user_organization_organization_id_foreign": {
          "constraintName": "user_organization_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.user_organization",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        },
        "user_organization_system_user_id_foreign": {
          "constraintName": "user_organization_system_user_id_foreign",
          "columnNames": [
            "system_user_id"
          ],
          "localTableName": "public.user_organization",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.system_user",
          "deleteRule": "set null",
          "updateRule": "cascade"
        },
        "user_organization_client_user_id_foreign": {
          "constraintName": "user_organization_client_user_id_foreign",
          "columnNames": [
            "client_user_id"
          ],
          "localTableName": "public.user_organization",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.client_user",
          "deleteRule": "set null",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    }
  ],
  "nativeEnums": {}
}

================
File: migrations/backup/Migration20241211202532.ts
================
import { Migration } from '@mikro-orm/migrations';
export class Migration20241211202532 extends Migration {
    override async up(): Promise<void> {
        this.addSql(`create table "organization" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "name" varchar(255) not null, "type" text check ("type" in ('SERVICE_PROVIDER', 'CLIENT')) not null, "description" varchar(255) null, "is_active" boolean not null default true, "is_service_provider" boolean not null default false, "primary_contact" varchar(255) null, "email" varchar(255) null, "phone" varchar(255) null, "address" varchar(255) null, constraint "organization_pkey" primary key ("id"));`);
        this.addSql(`create table "continuity_plan" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "organization_id" varchar(255) not null, "title" varchar(255) not null, "version" varchar(255) not null, "status" varchar(255) not null, "review_date" timestamptz not null, "next_review_date" timestamptz not null, "content" jsonb not null, constraint "continuity_plan_pkey" primary key ("id"));`);
        this.addSql(`create table "artifact" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "organization_id" varchar(255) not null, "name" varchar(255) not null, "description" varchar(255) null, "type" text check ("type" in ('POLICY', 'PROCEDURE', 'DOCUMENTATION', 'SCAN_RESULT', 'CONFIGURATION', 'TRAINING', 'AUDIT_LOG', 'EVIDENCE', 'OTHER')) not null, "status" text check ("status" in ('DRAFT', 'IN_REVIEW', 'APPROVED', 'ARCHIVED', 'REJECTED')) not null default 'DRAFT', "version" varchar(255) not null, "file_url" varchar(255) not null, "mime_type" varchar(255) not null, "file_size" int not null, "metadata" jsonb null, "last_reviewed_at" timestamptz null, "expires_at" timestamptz null, "created_by" varchar(255) not null, "last_reviewed_by" varchar(255) null, "approved_by" varchar(255) null, constraint "artifact_pkey" primary key ("id"));`);
        this.addSql(`create table "artifact_revision" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "artifact_id" varchar(255) not null, "version" varchar(255) not null, "file_url" varchar(255) not null, "changes" varchar(255) null, "created_by" varchar(255) not null, constraint "artifact_revision_pkey" primary key ("id"));`);
        this.addSql(`create table "poam" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "organization_id" varchar(255) not null, "finding" varchar(255) not null, "recommendation" varchar(255) not null, "priority" varchar(255) not null, "status" varchar(255) not null, "target_date" timestamptz not null, "completion_date" timestamptz null, "responsible_party" varchar(255) not null, "mitigation_plan" varchar(255) not null, "residual_risk" varchar(255) null, constraint "poam_pkey" primary key ("id"));`);
        this.addSql(`create table "service_provider_client" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "provider_id" varchar(255) not null, "client_id" varchar(255) not null, "status" varchar(255) not null, "start_date" timestamptz not null, "end_date" timestamptz null, "contract_details" varchar(255) null, constraint "service_provider_client_pkey" primary key ("id"));`);
        this.addSql(`alter table "service_provider_client" add constraint "service_provider_client_provider_id_client_id_unique" unique ("provider_id", "client_id");`);
        this.addSql(`create table "system" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "organization_id" varchar(255) not null, "name" varchar(255) not null, "description" varchar(255) null, "system_type" text check ("system_type" in ('WEB_APPLICATION', 'NETWORK_SYSTEM', 'DATABASE_SYSTEM', 'CLOUD_SERVICE', 'LEGACY_SYSTEM', 'OTHER')) not null, "criticality" text check ("criticality" in ('HIGH', 'MODERATE', 'LOW')) not null, "status" text check ("status" in ('ACTIVE', 'INACTIVE', 'DECOMMISSIONED', 'UNDER_DEVELOPMENT')) not null default 'ACTIVE', "owner" varchar(255) null, "custodian" varchar(255) null, "boundaries" varchar(255) null, "location" varchar(255) null, constraint "system_pkey" primary key ("id"));`);
        this.addSql(`create table "atopackage" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "system_id" varchar(255) not null, "name" varchar(255) not null, "description" varchar(255) null, "framework" varchar(255) not null, "status" text check ("status" in ('DRAFT', 'IN_PROGRESS', 'UNDER_REVIEW', 'APPROVED', 'REJECTED', 'EXPIRED')) not null default 'DRAFT', "current_phase" text check ("current_phase" in ('PREPARATION', 'INITIAL_ASSESSMENT', 'CONTROL_IMPLEMENTATION', 'TESTING', 'VALIDATION', 'FINAL_REVIEW', 'AUTHORIZATION', 'MONITORING')) not null default 'PREPARATION', "valid_from" timestamptz null, "valid_until" timestamptz null, "last_assessment" timestamptz null, "next_assessment" timestamptz null, constraint "atopackage_pkey" primary key ("id"));`);
        this.addSql(`create table "control_assessment" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "ato_package_id" varchar(255) not null, "control_id" varchar(255) not null, "title" varchar(255) not null, "description" varchar(255) null, "status" text check ("status" in ('NOT_IMPLEMENTED', 'PLANNED', 'PARTIALLY_IMPLEMENTED', 'IMPLEMENTED', 'NOT_APPLICABLE')) not null default 'NOT_IMPLEMENTED', "implementation_status" varchar(255) null, "test_results" jsonb null, "tested_date" timestamptz null, constraint "control_assessment_pkey" primary key ("id"));`);
        this.addSql(`create table "document" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "control_id" varchar(255) not null, "type" text check ("type" in ('SSP', 'RAR', 'SAR', 'SAP', 'POA_M', 'EVIDENCE', 'POLICY', 'PROCEDURE', 'CONFIGURATION', 'TEST_RESULT', 'OTHER')) not null, "title" varchar(255) not null, "description" varchar(255) null, "version" varchar(255) not null, "file_url" varchar(255) not null, "mime_type" varchar(255) null, "file_size" int null, "status" text check ("status" in ('PENDING', 'APPROVED', 'REJECTED', 'NEEDS_WORK')) not null default 'PENDING', "metadata" jsonb null, constraint "document_pkey" primary key ("id"));`);
        this.addSql(`create table "control_artifact" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "control_id" varchar(255) not null, "artifact_id" varchar(255) not null, "association" varchar(255) not null, "notes" varchar(255) null, constraint "control_artifact_pkey" primary key ("id"));`);
        this.addSql(`alter table "control_artifact" add constraint "control_artifact_control_id_artifact_id_unique" unique ("control_id", "artifact_id");`);
        this.addSql(`create table "user" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "email" varchar(255) not null, "password" varchar(255) not null, "name" varchar(255) not null, "system_role" text check ("system_role" in ('GLOBAL_ADMIN', 'ADMIN', 'USER')) not null default 'USER', "is_active" boolean not null default true, "last_login" timestamptz null, constraint "user_pkey" primary key ("id"));`);
        this.addSql(`alter table "user" add constraint "user_email_unique" unique ("email");`);
        this.addSql(`create table "incident" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "organization_id" varchar(255) not null, "title" varchar(255) not null, "description" varchar(255) not null, "severity" text check ("severity" in ('CRITICAL', 'HIGH', 'MEDIUM', 'LOW')) not null, "status" text check ("status" in ('OPEN', 'INVESTIGATING', 'MITIGATING', 'RESOLVED', 'CLOSED')) not null default 'OPEN', "reporter_id" varchar(255) not null, "assignee_id" varchar(255) null, "resolution" varchar(255) null, "resolved_date" timestamptz null, constraint "incident_pkey" primary key ("id"));`);
        this.addSql(`create table "audit_log" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "organization_id" varchar(255) not null, "user_id" varchar(255) not null, "action" varchar(255) not null, "entity_type" varchar(255) not null, "entity_id" varchar(255) not null, "details" jsonb not null, "ip_address" varchar(255) null, "user_agent" varchar(255) null, constraint "audit_log_pkey" primary key ("id"));`);
        this.addSql(`create table "asset" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "system_id" varchar(255) not null, "name" varchar(255) not null, "type" varchar(255) not null, "status" varchar(255) not null, "created_by_id" varchar(255) not null, "description" varchar(255) null, "version" varchar(255) null, "location" varchar(255) null, "purchase_date" timestamptz null, "end_of_life" timestamptz null, constraint "asset_pkey" primary key ("id"));`);
        this.addSql(`create table "port_mapping" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "asset_id" varchar(255) not null, "port" int not null, "protocol" varchar(255) not null, "service" varchar(255) not null, "description" varchar(255) null, "status" varchar(255) not null, "last_scan" timestamptz null, constraint "port_mapping_pkey" primary key ("id"));`);
        this.addSql(`create table "incident_affected_assets" ("incident_id" varchar(255) not null, "asset_id" varchar(255) not null, constraint "incident_affected_assets_pkey" primary key ("incident_id", "asset_id"));`);
        this.addSql(`create table "approval" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "entity_type" varchar(255) not null, "entity_id" varchar(255) not null, "approver_id" varchar(255) not null, "status" text check ("status" in ('PENDING', 'APPROVED', 'REJECTED', 'NEEDS_WORK')) not null default 'PENDING', "comments" varchar(255) null, "approved_at" timestamptz null, "document_id" varchar(255) null, "control_assessment_id" varchar(255) null, "ato_package_id" varchar(255) null, "continuity_plan_id" varchar(255) null, "poam_id" varchar(255) null, constraint "approval_pkey" primary key ("id"));`);
        this.addSql(`create table "user_organization" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "user_id" varchar(255) not null, "organization_id" varchar(255) not null, "org_role" text check ("org_role" in ('AODR', 'SCA', 'SCAR', 'AUDITOR', 'ISSM', 'ISSO')) not null, "is_active" boolean not null default true, constraint "user_organization_pkey" primary key ("id"));`);
        this.addSql(`alter table "user_organization" add constraint "user_organization_user_id_organization_id_unique" unique ("user_id", "organization_id");`);
        this.addSql(`alter table "continuity_plan" add constraint "continuity_plan_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "artifact" add constraint "artifact_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "artifact_revision" add constraint "artifact_revision_artifact_id_foreign" foreign key ("artifact_id") references "artifact" ("id") on update cascade;`);
        this.addSql(`alter table "poam" add constraint "poam_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "service_provider_client" add constraint "service_provider_client_provider_id_foreign" foreign key ("provider_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "service_provider_client" add constraint "service_provider_client_client_id_foreign" foreign key ("client_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "system" add constraint "system_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "atopackage" add constraint "atopackage_system_id_foreign" foreign key ("system_id") references "system" ("id") on update cascade;`);
        this.addSql(`alter table "control_assessment" add constraint "control_assessment_ato_package_id_foreign" foreign key ("ato_package_id") references "atopackage" ("id") on update cascade;`);
        this.addSql(`alter table "document" add constraint "document_control_id_foreign" foreign key ("control_id") references "control_assessment" ("id") on update cascade;`);
        this.addSql(`alter table "control_artifact" add constraint "control_artifact_control_id_foreign" foreign key ("control_id") references "control_assessment" ("id") on update cascade;`);
        this.addSql(`alter table "control_artifact" add constraint "control_artifact_artifact_id_foreign" foreign key ("artifact_id") references "artifact" ("id") on update cascade;`);
        this.addSql(`alter table "incident" add constraint "incident_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "incident" add constraint "incident_reporter_id_foreign" foreign key ("reporter_id") references "user" ("id") on update cascade;`);
        this.addSql(`alter table "incident" add constraint "incident_assignee_id_foreign" foreign key ("assignee_id") references "user" ("id") on update cascade on delete set null;`);
        this.addSql(`alter table "audit_log" add constraint "audit_log_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "audit_log" add constraint "audit_log_user_id_foreign" foreign key ("user_id") references "user" ("id") on update cascade;`);
        this.addSql(`alter table "asset" add constraint "asset_system_id_foreign" foreign key ("system_id") references "system" ("id") on update cascade;`);
        this.addSql(`alter table "asset" add constraint "asset_created_by_id_foreign" foreign key ("created_by_id") references "user" ("id") on update cascade;`);
        this.addSql(`alter table "port_mapping" add constraint "port_mapping_asset_id_foreign" foreign key ("asset_id") references "asset" ("id") on update cascade;`);
        this.addSql(`alter table "incident_affected_assets" add constraint "incident_affected_assets_incident_id_foreign" foreign key ("incident_id") references "incident" ("id") on update cascade on delete cascade;`);
        this.addSql(`alter table "incident_affected_assets" add constraint "incident_affected_assets_asset_id_foreign" foreign key ("asset_id") references "asset" ("id") on update cascade on delete cascade;`);
        this.addSql(`alter table "approval" add constraint "approval_approver_id_foreign" foreign key ("approver_id") references "user" ("id") on update cascade;`);
        this.addSql(`alter table "approval" add constraint "approval_document_id_foreign" foreign key ("document_id") references "document" ("id") on update cascade on delete set null;`);
        this.addSql(`alter table "approval" add constraint "approval_control_assessment_id_foreign" foreign key ("control_assessment_id") references "control_assessment" ("id") on update cascade on delete set null;`);
        this.addSql(`alter table "approval" add constraint "approval_ato_package_id_foreign" foreign key ("ato_package_id") references "atopackage" ("id") on update cascade on delete set null;`);
        this.addSql(`alter table "approval" add constraint "approval_continuity_plan_id_foreign" foreign key ("continuity_plan_id") references "continuity_plan" ("id") on update cascade on delete set null;`);
        this.addSql(`alter table "approval" add constraint "approval_poam_id_foreign" foreign key ("poam_id") references "poam" ("id") on update cascade on delete set null;`);
        this.addSql(`alter table "user_organization" add constraint "user_organization_user_id_foreign" foreign key ("user_id") references "user" ("id") on update cascade;`);
        this.addSql(`alter table "user_organization" add constraint "user_organization_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    }
}

================
File: migrations/backup/Migration20241212053500.ts
================
import { Migration } from '@mikro-orm/migrations';
export class Migration20241212053500 extends Migration {
    override async up(): Promise<void> {
        this.addSql(`create table "risk_profile" (
      "id" varchar(255) not null, 
      "created_at" timestamptz not null, 
      "updated_at" timestamptz not null, 
      "business_functions" varchar(255) not null,
      "key_assets" varchar(255) not null,
      "compliance_frameworks" text[] not null,
      "data_types" text[] not null,
      "operational_risk" text check ("operational_risk" in ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')) not null,
      "data_security_risk" text check ("data_security_risk" in ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')) not null,
      "compliance_risk" text check ("compliance_risk" in ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')) not null,
      "financial_risk" text check ("financial_risk" in ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')) not null,
      "organization_id" varchar(255) not null,
      constraint "risk_profile_pkey" primary key ("id")
    );`);
        this.addSql(`create table "quantitative_risk" (
      "id" varchar(255) not null,
      "created_at" timestamptz not null,
      "updated_at" timestamptz not null,
      "annual_loss" int not null,
      "probability_of_occurrence" float not null,
      "impact_score" float not null,
      "risk_score" float not null,
      "organization_id" varchar(255) not null,
      constraint "quantitative_risk_pkey" primary key ("id")
    );`);
        this.addSql(`create table "risk_matrix_entry" (
      "id" varchar(255) not null,
      "created_at" timestamptz not null,
      "updated_at" timestamptz not null,
      "impact" int not null,
      "likelihood" int not null,
      "value" int not null,
      "organization_id" varchar(255) not null,
      constraint "risk_matrix_entry_pkey" primary key ("id")
    );`);
        this.addSql(`create table "mitigation_priority" (
      "id" varchar(255) not null,
      "created_at" timestamptz not null,
      "updated_at" timestamptz not null,
      "risk" varchar(255) not null,
      "priority" int not null,
      "strategy" varchar(255) not null,
      "timeline" varchar(255) not null,
      "timeframe" text check ("timeframe" in ('IMMEDIATE', 'SHORT_TERM', 'MEDIUM_TERM', 'LONG_TERM')) not null,
      "risk_area" varchar(255) not null,
      "success_criteria" varchar(255) not null,
      "resources" varchar(255) not null,
      "estimated_cost" varchar(255) not null,
      "responsible_party" varchar(255) not null,
      "organization_id" varchar(255) not null,
      constraint "mitigation_priority_pkey" primary key ("id")
    );`);
        this.addSql(`alter table "risk_profile" add constraint "risk_profile_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "quantitative_risk" add constraint "quantitative_risk_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "risk_matrix_entry" add constraint "risk_matrix_entry_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "mitigation_priority" add constraint "mitigation_priority_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    }
}

================
File: migrations/backup/Migration20241212063915.ts
================
import { Migration } from '@mikro-orm/migrations';
export class Migration20241212063915 extends Migration {
    override async up(): Promise<void> {
        // Drop existing foreign key constraints
        this.addSql(`alter table "user_organization" drop constraint if exists "user_organization_organization_id_foreign";`);
        this.addSql(`alter table "service_provider_client" drop constraint if exists "service_provider_client_provider_id_foreign";`);
        this.addSql(`alter table "service_provider_client" drop constraint if exists "service_provider_client_client_id_foreign";`);
        this.addSql(`alter table "system" drop constraint if exists "system_organization_id_foreign";`);
        this.addSql(`alter table "incident" drop constraint if exists "incident_organization_id_foreign";`);
        this.addSql(`alter table "continuity_plan" drop constraint if exists "continuity_plan_organization_id_foreign";`);
        this.addSql(`alter table "poam" drop constraint if exists "poam_organization_id_foreign";`);
        this.addSql(`alter table "audit_log" drop constraint if exists "audit_log_organization_id_foreign";`);
        this.addSql(`alter table "artifact" drop constraint if exists "artifact_organization_id_foreign";`);
        this.addSql(`alter table "mitigation_priority" drop constraint if exists "mitigation_priority_organization_id_foreign";`);
        this.addSql(`alter table "quantitative_risk" drop constraint if exists "quantitative_risk_organization_id_foreign";`);
        this.addSql(`alter table "risk_matrix_entry" drop constraint if exists "risk_matrix_entry_organization_id_foreign";`);
        this.addSql(`alter table "risk_profile" drop constraint if exists "risk_profile_organization_id_foreign";`);
        // Add constraints back with ON DELETE CASCADE
        this.addSql(`alter table "user_organization" add constraint "user_organization_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
        this.addSql(`alter table "service_provider_client" add constraint "service_provider_client_provider_id_foreign" foreign key ("provider_id") references "organization" ("id") on update cascade on delete cascade;`);
        this.addSql(`alter table "service_provider_client" add constraint "service_provider_client_client_id_foreign" foreign key ("client_id") references "organization" ("id") on update cascade on delete cascade;`);
        this.addSql(`alter table "system" add constraint "system_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
        this.addSql(`alter table "incident" add constraint "incident_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
        this.addSql(`alter table "continuity_plan" add constraint "continuity_plan_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
        this.addSql(`alter table "poam" add constraint "poam_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
        this.addSql(`alter table "audit_log" add constraint "audit_log_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
        this.addSql(`alter table "artifact" add constraint "artifact_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
        this.addSql(`alter table "mitigation_priority" add constraint "mitigation_priority_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
        this.addSql(`alter table "quantitative_risk" add constraint "quantitative_risk_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
        this.addSql(`alter table "risk_matrix_entry" add constraint "risk_matrix_entry_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
        this.addSql(`alter table "risk_profile" add constraint "risk_profile_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
    }
    override async down(): Promise<void> {
        // Remove cascade delete constraints
        this.addSql(`alter table "user_organization" drop constraint if exists "user_organization_organization_id_foreign";`);
        this.addSql(`alter table "service_provider_client" drop constraint if exists "service_provider_client_provider_id_foreign";`);
        this.addSql(`alter table "service_provider_client" drop constraint if exists "service_provider_client_client_id_foreign";`);
        this.addSql(`alter table "system" drop constraint if exists "system_organization_id_foreign";`);
        this.addSql(`alter table "incident" drop constraint if exists "incident_organization_id_foreign";`);
        this.addSql(`alter table "continuity_plan" drop constraint if exists "continuity_plan_organization_id_foreign";`);
        this.addSql(`alter table "poam" drop constraint if exists "poam_organization_id_foreign";`);
        this.addSql(`alter table "audit_log" drop constraint if exists "audit_log_organization_id_foreign";`);
        this.addSql(`alter table "artifact" drop constraint if exists "artifact_organization_id_foreign";`);
        this.addSql(`alter table "mitigation_priority" drop constraint if exists "mitigation_priority_organization_id_foreign";`);
        this.addSql(`alter table "quantitative_risk" drop constraint if exists "quantitative_risk_organization_id_foreign";`);
        this.addSql(`alter table "risk_matrix_entry" drop constraint if exists "risk_matrix_entry_organization_id_foreign";`);
        this.addSql(`alter table "risk_profile" drop constraint if exists "risk_profile_organization_id_foreign";`);
        // Add back constraints without cascade delete
        this.addSql(`alter table "user_organization" add constraint "user_organization_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "service_provider_client" add constraint "service_provider_client_provider_id_foreign" foreign key ("provider_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "service_provider_client" add constraint "service_provider_client_client_id_foreign" foreign key ("client_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "system" add constraint "system_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "incident" add constraint "incident_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "continuity_plan" add constraint "continuity_plan_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "poam" add constraint "poam_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "audit_log" add constraint "audit_log_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "artifact" add constraint "artifact_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "mitigation_priority" add constraint "mitigation_priority_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "quantitative_risk" add constraint "quantitative_risk_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "risk_matrix_entry" add constraint "risk_matrix_entry_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        this.addSql(`alter table "risk_profile" add constraint "risk_profile_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    }
}

================
File: migrations/backup/Migration20241212175619.ts
================
import { Migration } from '@mikro-orm/migrations';
export class Migration20241212175619 extends Migration {
    override async up(): Promise<void> {
        // Add last_name as nullable first
        this.addSql(`alter table "user" add column "last_name" varchar(255);`);
        // Update existing records with a default value
        this.addSql(`update "user" set "last_name" = '' where "last_name" is null;`);
        // Make last_name non-nullable
        this.addSql(`alter table "user" alter column "last_name" set not null;`);
        // Rename existing columns
        this.addSql(`alter table "user" rename column "name" to "first_name";`);
        this.addSql(`alter table "user" rename column "system_role" to "role";`);
    }
    override async down(): Promise<void> {
        this.addSql(`alter table "user" drop column "last_name";`);
        this.addSql(`alter table "user" rename column "first_name" to "name";`);
        this.addSql(`alter table "user" rename column "role" to "system_role";`);
    }
}

================
File: migrations/backup/Migration20241212180400.ts
================
import { Migration } from '@mikro-orm/migrations';
export class Migration20241212180400 extends Migration {
    async up(): Promise<void> {
        this.addSql("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";");
    }
    async down(): Promise<void> {
        this.addSql("DROP EXTENSION IF EXISTS \"uuid-ossp\";");
    }
}

================
File: migrations/backup/Migration20241212183455.ts
================
import { Migration } from '@mikro-orm/migrations';
export class Migration20241212183455 extends Migration {
    async up(): Promise<void> {
        // Create client_user table
        this.addSql(`create table "client_user" (
      "id" uuid not null default uuid_generate_v4(),
      "created_at" timestamptz(0) not null default now(),
      "updated_at" timestamptz(0) not null default now(),
      "email" varchar(255) not null,
      "password" varchar(255) not null,
      "first_name" varchar(255) not null,
      "last_name" varchar(255) not null,
      "is_active" boolean not null default true,
      "last_login" timestamptz(0) null,
      constraint "client_user_pkey" primary key ("id"),
      constraint "client_user_email_unique" unique ("email")
    );`);
        // Create system_user table
        this.addSql(`create table "system_user" (
      "id" uuid not null default uuid_generate_v4(),
      "created_at" timestamptz(0) not null default now(),
      "updated_at" timestamptz(0) not null default now(),
      "email" varchar(255) not null,
      "password" varchar(255) not null,
      "first_name" varchar(255) not null,
      "last_name" varchar(255) not null,
      "role" text check ("role" in ('GLOBAL_ADMIN', 'ADMIN')) not null default 'ADMIN',
      "is_active" boolean not null default true,
      "last_login" timestamptz(0) null,
      constraint "system_user_pkey" primary key ("id"),
      constraint "system_user_email_unique" unique ("email")
    );`);
        // Create incident table if it doesn't exist
        this.addSql(`create table if not exists "incident" (
      "id" uuid not null default uuid_generate_v4(),
      "created_at" timestamptz(0) not null default now(),
      "updated_at" timestamptz(0) not null default now(),
      "organization_id" uuid not null,
      "title" varchar(255) not null,
      "description" text not null,
      "severity" text check ("severity" in ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')) not null,
      "status" text check ("status" in ('OPEN', 'IN_PROGRESS', 'RESOLVED', 'CLOSED')) not null default 'OPEN',
      "reporter_id" uuid not null references "client_user" ("id") on update cascade,
      "assignee_id" uuid null references "client_user" ("id") on update cascade on delete set null,
      "resolution" text null,
      "resolved_date" timestamptz(0) null,
      constraint "incident_pkey" primary key ("id")
    );`);
        // Create approval table if it doesn't exist
        this.addSql(`create table if not exists "approval" (
      "id" uuid not null default uuid_generate_v4(),
      "created_at" timestamptz(0) not null default now(),
      "updated_at" timestamptz(0) not null default now(),
      "entity_type" varchar(255) not null,
      "entity_id" varchar(255) not null,
      "approver_id" uuid not null references "client_user" ("id") on update cascade,
      "status" text check ("status" in ('PENDING', 'APPROVED', 'REJECTED')) not null default 'PENDING',
      "comments" text null,
      "approved_at" timestamptz(0) null,
      constraint "approval_pkey" primary key ("id")
    );`);
        // Create asset table if it doesn't exist
        this.addSql(`create table if not exists "asset" (
      "id" uuid not null default uuid_generate_v4(),
      "created_at" timestamptz(0) not null default now(),
      "updated_at" timestamptz(0) not null default now(),
      "system_id" uuid not null,
      "name" varchar(255) not null,
      "type" varchar(255) not null,
      "status" varchar(255) not null,
      "created_by_id" uuid not null references "client_user" ("id") on update cascade,
      "description" text null,
      "version" varchar(255) null,
      "location" varchar(255) null,
      "purchase_date" timestamptz(0) null,
      "end_of_life" timestamptz(0) null,
      constraint "asset_pkey" primary key ("id")
    );`);
        // Update audit_log table
        this.addSql(`alter table if exists "audit_log" 
      add column if not exists "system_user_id" uuid null references "system_user" ("id") on update cascade on delete set null,
      add column if not exists "client_user_id" uuid null references "client_user" ("id") on update cascade on delete set null;`);
        // Update user_organization table
        this.addSql(`alter table if exists "user_organization" 
      add column if not exists "system_user_id" uuid null references "system_user" ("id") on update cascade on delete set null,
      add column if not exists "client_user_id" uuid null references "client_user" ("id") on update cascade on delete set null;`);
    }
    async down(): Promise<void> {
        // Drop foreign key constraints
        this.addSql(`alter table "incident" drop constraint if exists "incident_reporter_id_foreign";`);
        this.addSql(`alter table "incident" drop constraint if exists "incident_assignee_id_foreign";`);
        this.addSql(`alter table "approval" drop constraint if exists "approval_approver_id_foreign";`);
        this.addSql(`alter table "asset" drop constraint if exists "asset_created_by_id_foreign";`);
        this.addSql(`alter table "audit_log" drop constraint if exists "audit_log_system_user_id_foreign";`);
        this.addSql(`alter table "audit_log" drop constraint if exists "audit_log_client_user_id_foreign";`);
        this.addSql(`alter table "user_organization" drop constraint if exists "user_organization_system_user_id_foreign";`);
        this.addSql(`alter table "user_organization" drop constraint if exists "user_organization_client_user_id_foreign";`);
        // Drop columns from audit_log
        this.addSql(`alter table "audit_log" drop column if exists "system_user_id";`);
        this.addSql(`alter table "audit_log" drop column if exists "client_user_id";`);
        // Drop columns from user_organization
        this.addSql(`alter table "user_organization" drop column if exists "system_user_id";`);
        this.addSql(`alter table "user_organization" drop column if exists "client_user_id";`);
        // Drop tables
        this.addSql(`drop table if exists "client_user" cascade;`);
        this.addSql(`drop table if exists "system_user" cascade;`);
    }
}

================
File: migrations/backup/Migration20241212183500.ts
================
import { Migration } from '@mikro-orm/migrations';
export class Migration20241212183500 extends Migration {
    async up(): Promise<void> {
        this.addSql("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";");
    }
    async down(): Promise<void> {
        this.addSql("DROP EXTENSION IF EXISTS \"uuid-ossp\";");
    }
}

================
File: migrations/backup/Migration20241213035500.ts
================
import { Migration } from '@mikro-orm/migrations';
export class Migration20241213035500 extends Migration {
    async up(): Promise<void> {
        // Make user_id column nullable in audit_log table
        this.addSql("ALTER TABLE \"audit_log\" ALTER COLUMN \"user_id\" DROP NOT NULL;");
    }
    async down(): Promise<void> {
        // Revert changes - make user_id column not null again
        this.addSql("ALTER TABLE \"audit_log\" ALTER COLUMN \"user_id\" SET NOT NULL;");
    }
}

================
File: migrations/backup/Migration20241213171045.ts
================
import { Migration } from '@mikro-orm/migrations';
export class Migration20241213171045 extends Migration {
    override async up(): Promise<void> {
        this.addSql(`alter table "client_user" add column "client_role" text check ("client_role" in ('ADMIN', 'MANAGER', 'PM', 'USER')) not null;`);
        this.addSql(`alter table "client_user" add column "organization_role" text check ("organization_role" in ('AODR', 'SCA', 'SCAR', 'AUDITOR', 'PM', 'ISSM', 'ISSO')) null;`);
        this.addSql(`alter table "client_user" add column "organization_id" varchar(255) not null;`);
        this.addSql(`alter table "client_user" add constraint "client_user_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
        // Add validation check to ensure organization_role is not null when client_role is not USER
        this.addSql(`
      alter table "client_user" add constraint "client_user_role_validation"
      check (
        (client_role = 'USER' and organization_role is null) or
        (client_role != 'USER' and organization_role is not null)
      );
    `);
    }
    override async down(): Promise<void> {
        this.addSql(`alter table "client_user" drop constraint "client_user_role_validation";`);
        this.addSql(`alter table "client_user" drop constraint "client_user_organization_id_foreign";`);
        this.addSql(`alter table "client_user" drop column "client_role", drop column "organization_role", drop column "organization_id";`);
    }
}

================
File: migrations/backup/Migration20241214040117.ts
================
import { Migration } from '@mikro-orm/migrations';

export class Migration20241214040117 extends Migration {

  override async up(): Promise<void> {
    this.addSql(`create table "catalog" ("id" varchar(255) not null, "title" varchar(255) not null, "version" varchar(255) not null, "last_modified" timestamptz not null, constraint "catalog_pkey" primary key ("id"));`);

    this.addSql(`create table "group" ("id" varchar(255) not null, "title" varchar(255) not null, "class" varchar(255) not null, "catalog_id" varchar(255) not null, constraint "group_pkey" primary key ("id"));`);

    this.addSql(`create table "control" ("id" varchar(255) not null, "title" varchar(255) not null, "class" varchar(255) not null, "group_id" varchar(255) not null, constraint "control_pkey" primary key ("id"));`);

    this.addSql(`create table "parameter" ("id" varchar(255) not null, "label" varchar(255) not null, "control_id" varchar(255) not null, constraint "parameter_pkey" primary key ("id"));`);

    this.addSql(`create table "part" ("id" varchar(255) not null, "name" varchar(255) not null, "prose" varchar(255) null, "control_id" varchar(255) not null, "parent_id" varchar(255) null, constraint "part_pkey" primary key ("id"));`);

    this.addSql(`alter table "group" add constraint "group_catalog_id_foreign" foreign key ("catalog_id") references "catalog" ("id") on update cascade;`);

    this.addSql(`alter table "control" add constraint "control_group_id_foreign" foreign key ("group_id") references "group" ("id") on update cascade;`);

    this.addSql(`alter table "parameter" add constraint "parameter_control_id_foreign" foreign key ("control_id") references "control" ("id") on update cascade;`);

    this.addSql(`alter table "part" add constraint "part_control_id_foreign" foreign key ("control_id") references "control" ("id") on update cascade;`);
    this.addSql(`alter table "part" add constraint "part_parent_id_foreign" foreign key ("parent_id") references "part" ("id") on update cascade on delete set null;`);

    this.addSql(`alter table "organization" drop constraint if exists "organization_type_check";`);

    this.addSql(`alter table "organization" add constraint "organization_type_check" check("type" in ('PROVIDER', 'CLIENT'));`);

    this.addSql(`alter table "client_user" drop column "role";`);

    this.addSql(`alter table "client_user" add column "client_role" text check ("client_role" in ('ADMIN', 'MANAGER', 'PM', 'USER')) not null, add column "organization_role" text check ("organization_role" in ('AODR', 'SCA', 'SCAR', 'AUDITOR', 'PM', 'ISSM', 'ISSO')) null;`);
  }

  override async down(): Promise<void> {
    this.addSql(`alter table "group" drop constraint "group_catalog_id_foreign";`);

    this.addSql(`alter table "control" drop constraint "control_group_id_foreign";`);

    this.addSql(`alter table "parameter" drop constraint "parameter_control_id_foreign";`);

    this.addSql(`alter table "part" drop constraint "part_control_id_foreign";`);

    this.addSql(`alter table "part" drop constraint "part_parent_id_foreign";`);

    this.addSql(`drop table if exists "catalog" cascade;`);

    this.addSql(`drop table if exists "group" cascade;`);

    this.addSql(`drop table if exists "control" cascade;`);

    this.addSql(`drop table if exists "parameter" cascade;`);

    this.addSql(`drop table if exists "part" cascade;`);

    this.addSql(`alter table "organization" drop constraint if exists "organization_type_check";`);

    this.addSql(`alter table "organization" add constraint "organization_type_check" check("type" in ('SERVICE_PROVIDER', 'CLIENT'));`);

    this.addSql(`alter table "client_user" drop column "client_role", drop column "organization_role";`);

    this.addSql(`alter table "client_user" add column "role" text check ("role" in ('ADMIN', 'MANAGER', 'USER', 'AUDITOR')) not null;`);
  }

}

================
File: migrations/Migration20241215000000.ts
================
import { Migration } from '@mikro-orm/migrations';

export class Migration20241215000000 extends Migration {
  async up(): Promise<void> {
    // Drop all existing tables in reverse order of dependencies
    this.addSql('DROP TABLE IF EXISTS "incident_affected_assets" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "port_mapping" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "asset" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "approval" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "audit_log" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "control_artifact" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "document" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "control_assessment" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "atopackage" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "system" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "artifact_revision" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "artifact" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "poam" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "continuity_plan" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "service_provider_client" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "user_organization" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "incident" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "client_user" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "system_user" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "organization" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "part" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "parameter" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "control" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "group" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "catalog" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "risk_matrix_entry" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "quantitative_risk" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "risk_profile" CASCADE;');
    this.addSql('DROP TABLE IF EXISTS "mitigation_priority" CASCADE;');

    // Create tables in order of dependencies

    // Core entities
    this.addSql(`CREATE TABLE "organization" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "name" varchar(255) NOT NULL,
      "type" text CHECK ("type" IN ('PROVIDER', 'CLIENT')) NOT NULL,
      "description" varchar(255),
      "is_active" boolean NOT NULL DEFAULT true,
      "is_service_provider" boolean NOT NULL DEFAULT false,
      "primary_contact" varchar(255),
      "email" varchar(255),
      "phone" varchar(255),
      "address" varchar(255),
      CONSTRAINT "organization_pkey" PRIMARY KEY ("id")
    );`);

    this.addSql(`CREATE TABLE "system_user" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "email" varchar(255) NOT NULL,
      "password" varchar(255) NOT NULL,
      "first_name" varchar(255) NOT NULL,
      "last_name" varchar(255) NOT NULL,
      "role" text CHECK ("role" IN ('GLOBAL_ADMIN', 'ADMIN', 'USER')) NOT NULL DEFAULT 'ADMIN',
      "is_active" boolean NOT NULL DEFAULT true,
      "last_login" timestamptz,
      CONSTRAINT "system_user_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "system_user_email_unique" UNIQUE ("email")
    );`);

    this.addSql(`CREATE TABLE "client_user" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "email" varchar(255) NOT NULL,
      "password" varchar(255) NOT NULL,
      "first_name" varchar(255) NOT NULL,
      "last_name" varchar(255) NOT NULL,
      "is_active" boolean NOT NULL DEFAULT true,
      "last_login" timestamptz,
      "client_role" text CHECK ("client_role" IN ('ADMIN', 'MANAGER', 'PM', 'USER')) NOT NULL,
      "organization_role" text CHECK ("organization_role" IN ('AODR', 'SCA', 'SCAR', 'AUDITOR', 'PM', 'ISSM', 'ISSO')),
      "organization_id" varchar(255) NOT NULL,
      CONSTRAINT "client_user_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "client_user_email_unique" UNIQUE ("email"),
      CONSTRAINT "client_user_organization_id_foreign" FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON UPDATE CASCADE
    );`);

    // OSCAL entities
    this.addSql(`CREATE TABLE "catalog" (
      "id" varchar(255) NOT NULL,
      "title" varchar(255) NOT NULL,
      "version" varchar(255) NOT NULL,
      "last_modified" timestamptz NOT NULL,
      CONSTRAINT "catalog_pkey" PRIMARY KEY ("id")
    );`);

    this.addSql(`CREATE TABLE "group" (
      "id" varchar(255) NOT NULL,
      "title" varchar(255) NOT NULL,
      "class" varchar(255) NOT NULL,
      "catalog_id" varchar(255) NOT NULL,
      CONSTRAINT "group_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "group_catalog_id_foreign" FOREIGN KEY ("catalog_id") REFERENCES "catalog"("id") ON UPDATE CASCADE
    );`);

    this.addSql(`CREATE TABLE "control" (
      "id" varchar(255) NOT NULL,
      "title" varchar(255) NOT NULL,
      "class" varchar(255) NOT NULL,
      "group_id" varchar(255) NOT NULL,
      CONSTRAINT "control_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "control_group_id_foreign" FOREIGN KEY ("group_id") REFERENCES "group"("id") ON UPDATE CASCADE
    );`);

    this.addSql(`CREATE TABLE "parameter" (
      "id" varchar(255) NOT NULL,
      "label" varchar(255) NOT NULL,
      "control_id" varchar(255) NOT NULL,
      CONSTRAINT "parameter_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "parameter_control_id_foreign" FOREIGN KEY ("control_id") REFERENCES "control"("id") ON UPDATE CASCADE
    );`);

    this.addSql(`CREATE TABLE "part" (
      "id" varchar(255) NOT NULL,
      "name" varchar(255) NOT NULL,
      "prose" varchar(255),
      "control_id" varchar(255) NOT NULL,
      "parent_id" varchar(255),
      CONSTRAINT "part_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "part_control_id_foreign" FOREIGN KEY ("control_id") REFERENCES "control"("id") ON UPDATE CASCADE,
      CONSTRAINT "part_parent_id_foreign" FOREIGN KEY ("parent_id") REFERENCES "part"("id") ON DELETE SET NULL ON UPDATE CASCADE
    );`);

    // Risk Management entities
    this.addSql(`CREATE TABLE "risk_profile" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "business_functions" text NOT NULL,
      "key_assets" text NOT NULL,
      "compliance_frameworks" text[] NOT NULL,
      "data_types" text[] NOT NULL,
      "operational_risk" text CHECK ("operational_risk" IN ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')) NOT NULL,
      "data_security_risk" text CHECK ("data_security_risk" IN ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')) NOT NULL,
      "compliance_risk" text CHECK ("compliance_risk" IN ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')) NOT NULL,
      "financial_risk" text CHECK ("financial_risk" IN ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')) NOT NULL,
      "organization_id" varchar(255) NOT NULL,
      CONSTRAINT "risk_profile_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "risk_profile_organization_id_unique" UNIQUE ("organization_id"),
      CONSTRAINT "risk_profile_organization_id_foreign" FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON UPDATE CASCADE
    );`);

    this.addSql(`CREATE TABLE "risk_matrix_entry" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "impact" int NOT NULL,
      "likelihood" int NOT NULL,
      "value" int NOT NULL,
      "organization_id" varchar(255) NOT NULL,
      CONSTRAINT "risk_matrix_entry_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "risk_matrix_entry_organization_id_foreign" FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON UPDATE CASCADE
    );`);

    this.addSql(`CREATE TABLE "quantitative_risk" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "annual_loss" int NOT NULL,
      "probability_of_occurrence" int NOT NULL,
      "impact_score" int NOT NULL,
      "risk_score" int NOT NULL,
      "organization_id" varchar(255) NOT NULL,
      CONSTRAINT "quantitative_risk_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "quantitative_risk_organization_id_foreign" FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON UPDATE CASCADE
    );`);

    // System entities
    this.addSql(`CREATE TABLE "system" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "organization_id" varchar(255) NOT NULL,
      "name" varchar(255) NOT NULL,
      "description" varchar(255),
      "system_type" text CHECK ("system_type" IN ('WEB_APPLICATION', 'NETWORK_SYSTEM', 'DATABASE_SYSTEM', 'CLOUD_SERVICE', 'LEGACY_SYSTEM', 'OTHER')) NOT NULL,
      "criticality" text CHECK ("criticality" IN ('HIGH', 'MODERATE', 'LOW')) NOT NULL,
      "status" text CHECK ("status" IN ('ACTIVE', 'INACTIVE', 'DECOMMISSIONED', 'UNDER_DEVELOPMENT')) NOT NULL DEFAULT 'ACTIVE',
      "owner" varchar(255),
      "custodian" varchar(255),
      "boundaries" varchar(255),
      "location" varchar(255),
      CONSTRAINT "system_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "system_organization_id_foreign" FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON UPDATE CASCADE
    );`);

    // Asset Management
    this.addSql(`CREATE TABLE "asset" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "system_id" varchar(255) NOT NULL,
      "name" varchar(255) NOT NULL,
      "type" varchar(255) NOT NULL,
      "status" varchar(255) NOT NULL,
      "created_by_id" varchar(255) NOT NULL,
      "description" varchar(255),
      "version" varchar(255),
      "location" varchar(255),
      "purchase_date" timestamptz,
      "end_of_life" timestamptz,
      CONSTRAINT "asset_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "asset_system_id_foreign" FOREIGN KEY ("system_id") REFERENCES "system"("id") ON UPDATE CASCADE,
      CONSTRAINT "asset_created_by_id_foreign" FOREIGN KEY ("created_by_id") REFERENCES "client_user"("id") ON UPDATE CASCADE
    );`);

    this.addSql(`CREATE TABLE "port_mapping" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "asset_id" varchar(255) NOT NULL,
      "port" int NOT NULL,
      "protocol" varchar(255) NOT NULL,
      "service" varchar(255) NOT NULL,
      "description" varchar(255),
      "status" varchar(255) NOT NULL,
      "last_scan" timestamptz,
      CONSTRAINT "port_mapping_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "port_mapping_asset_id_foreign" FOREIGN KEY ("asset_id") REFERENCES "asset"("id") ON UPDATE CASCADE
    );`);

    // Compliance entities
    this.addSql(`CREATE TABLE "atopackage" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "system_id" varchar(255) NOT NULL,
      "name" varchar(255) NOT NULL,
      "description" varchar(255),
      "framework" varchar(255) NOT NULL,
      "status" text CHECK ("status" IN ('DRAFT', 'IN_PROGRESS', 'UNDER_REVIEW', 'APPROVED', 'REJECTED', 'EXPIRED')) NOT NULL DEFAULT 'DRAFT',
      "current_phase" text CHECK ("current_phase" IN ('PREPARATION', 'INITIAL_ASSESSMENT', 'CONTROL_IMPLEMENTATION', 'TESTING', 'VALIDATION', 'FINAL_REVIEW', 'AUTHORIZATION', 'MONITORING')) NOT NULL DEFAULT 'PREPARATION',
      "valid_from" timestamptz,
      "valid_until" timestamptz,
      "last_assessment" timestamptz,
      "next_assessment" timestamptz,
      CONSTRAINT "atopackage_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "atopackage_system_id_foreign" FOREIGN KEY ("system_id") REFERENCES "system"("id") ON UPDATE CASCADE
    );`);

    this.addSql(`CREATE TABLE "control_assessment" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "ato_package_id" varchar(255) NOT NULL,
      "control_id" varchar(255) NOT NULL,
      "title" varchar(255) NOT NULL,
      "description" varchar(255),
      "status" text CHECK ("status" IN ('NOT_IMPLEMENTED', 'PLANNED', 'PARTIALLY_IMPLEMENTED', 'IMPLEMENTED', 'NOT_APPLICABLE')) NOT NULL DEFAULT 'NOT_IMPLEMENTED',
      "implementation_status" varchar(255),
      "test_results" jsonb,
      "tested_date" timestamptz,
      CONSTRAINT "control_assessment_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "control_assessment_ato_package_id_foreign" FOREIGN KEY ("ato_package_id") REFERENCES "atopackage"("id") ON UPDATE CASCADE
    );`);

    // Document Management
    this.addSql(`CREATE TABLE "artifact" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "organization_id" varchar(255) NOT NULL,
      "name" varchar(255) NOT NULL,
      "description" varchar(255),
      "type" text CHECK ("type" IN ('POLICY', 'PROCEDURE', 'DOCUMENTATION', 'SCAN_RESULT', 'CONFIGURATION', 'TRAINING', 'AUDIT_LOG', 'EVIDENCE', 'OTHER')) NOT NULL,
      "status" text CHECK ("status" IN ('DRAFT', 'IN_REVIEW', 'APPROVED', 'ARCHIVED', 'REJECTED')) NOT NULL DEFAULT 'DRAFT',
      "version" varchar(255) NOT NULL,
      "file_url" varchar(255) NOT NULL,
      "mime_type" varchar(255) NOT NULL,
      "file_size" int NOT NULL,
      "metadata" jsonb,
      "last_reviewed_at" timestamptz,
      "expires_at" timestamptz,
      "created_by" varchar(255) NOT NULL,
      "last_reviewed_by" varchar(255),
      "approved_by" varchar(255),
      CONSTRAINT "artifact_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "artifact_organization_id_foreign" FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON UPDATE CASCADE
    );`);

    this.addSql(`CREATE TABLE "artifact_revision" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "artifact_id" varchar(255) NOT NULL,
      "version" varchar(255) NOT NULL,
      "file_url" varchar(255) NOT NULL,
      "changes" varchar(255),
      "created_by" varchar(255) NOT NULL,
      CONSTRAINT "artifact_revision_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "artifact_revision_artifact_id_foreign" FOREIGN KEY ("artifact_id") REFERENCES "artifact"("id") ON UPDATE CASCADE
    );`);

    // Relationship and Junction Tables
    this.addSql(`CREATE TABLE "service_provider_client" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "provider_id" varchar(255) NOT NULL,
      "client_id" varchar(255) NOT NULL,
      "status" varchar(255) NOT NULL,
      "start_date" timestamptz NOT NULL,
      "end_date" timestamptz,
      "contract_details" varchar(255),
      CONSTRAINT "service_provider_client_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "service_provider_client_provider_id_client_id_unique" UNIQUE ("provider_id", "client_id"),
      CONSTRAINT "service_provider_client_provider_id_foreign" FOREIGN KEY ("provider_id") REFERENCES "organization"("id") ON UPDATE CASCADE,
      CONSTRAINT "service_provider_client_client_id_foreign" FOREIGN KEY ("client_id") REFERENCES "organization"("id") ON UPDATE CASCADE
    );`);

    this.addSql(`CREATE TABLE "user_organization" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "organization_id" varchar(255) NOT NULL,
      "system_user_id" varchar(255),
      "client_user_id" varchar(255),
      "is_active" boolean NOT NULL DEFAULT true,
      CONSTRAINT "user_organization_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "user_organization_organization_id_foreign" FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON UPDATE CASCADE,
      CONSTRAINT "user_organization_system_user_id_foreign" FOREIGN KEY ("system_user_id") REFERENCES "system_user"("id") ON DELETE SET NULL ON UPDATE CASCADE,
      CONSTRAINT "user_organization_client_user_id_foreign" FOREIGN KEY ("client_user_id") REFERENCES "client_user"("id") ON DELETE SET NULL ON UPDATE CASCADE
    );`);

    // Tracking and Audit
    this.addSql(`CREATE TABLE "audit_log" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "organization_id" varchar(255) NOT NULL,
      "system_user_id" varchar(255),
      "client_user_id" varchar(255),
      "action" varchar(255) NOT NULL,
      "entity_type" varchar(255) NOT NULL,
      "entity_id" varchar(255) NOT NULL,
      "details" jsonb NOT NULL,
      "ip_address" varchar(255),
      "user_agent" varchar(255),
      CONSTRAINT "audit_log_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "audit_log_organization_id_foreign" FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON UPDATE CASCADE,
      CONSTRAINT "audit_log_system_user_id_foreign" FOREIGN KEY ("system_user_id") REFERENCES "system_user"("id") ON DELETE SET NULL ON UPDATE CASCADE,
      CONSTRAINT "audit_log_client_user_id_foreign" FOREIGN KEY ("client_user_id") REFERENCES "client_user"("id") ON DELETE SET NULL ON UPDATE CASCADE
    );`);

    // Incident Management
    this.addSql(`CREATE TABLE "incident" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "organization_id" varchar(255) NOT NULL,
      "title" varchar(255) NOT NULL,
      "description" varchar(255) NOT NULL,
      "severity" text CHECK ("severity" IN ('CRITICAL', 'HIGH', 'MEDIUM', 'LOW')) NOT NULL,
      "status" text CHECK ("status" IN ('OPEN', 'INVESTIGATING', 'MITIGATING', 'RESOLVED', 'CLOSED')) NOT NULL DEFAULT 'OPEN',
      "reporter_id" varchar(255) NOT NULL,
      "assignee_id" varchar(255),
      "resolution" varchar(255),
      "resolved_date" timestamptz,
      CONSTRAINT "incident_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "incident_organization_id_foreign" FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON UPDATE CASCADE,
      CONSTRAINT "incident_reporter_id_foreign" FOREIGN KEY ("reporter_id") REFERENCES "client_user"("id") ON UPDATE CASCADE,
      CONSTRAINT "incident_assignee_id_foreign" FOREIGN KEY ("assignee_id") REFERENCES "client_user"("id") ON DELETE SET NULL ON UPDATE CASCADE
    );`);

    this.addSql(`CREATE TABLE "incident_affected_assets" (
      "incident_id" varchar(255) NOT NULL,
      "asset_id" varchar(255) NOT NULL,
      CONSTRAINT "incident_affected_assets_pkey" PRIMARY KEY ("incident_id", "asset_id"),
      CONSTRAINT "incident_affected_assets_incident_id_foreign" FOREIGN KEY ("incident_id") REFERENCES "incident"("id") ON DELETE CASCADE ON UPDATE CASCADE,
      CONSTRAINT "incident_affected_assets_asset_id_foreign" FOREIGN KEY ("asset_id") REFERENCES "asset"("id") ON DELETE CASCADE ON UPDATE CASCADE
    );`);

    // Plan Management
    this.addSql(`CREATE TABLE "continuity_plan" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "organization_id" varchar(255) NOT NULL,
      "title" varchar(255) NOT NULL,
      "version" varchar(255) NOT NULL,
      "status" varchar(255) NOT NULL,
      "review_date" timestamptz NOT NULL,
      "next_review_date" timestamptz NOT NULL,
      "content" jsonb NOT NULL,
      CONSTRAINT "continuity_plan_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "continuity_plan_organization_id_foreign" FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON UPDATE CASCADE
    );`);

    this.addSql(`CREATE TABLE "poam" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "organization_id" varchar(255) NOT NULL,
      "finding" varchar(255) NOT NULL,
      "recommendation" varchar(255) NOT NULL,
      "priority" varchar(255) NOT NULL,
      "status" varchar(255) NOT NULL,
      "target_date" timestamptz NOT NULL,
      "completion_date" timestamptz,
      "responsible_party" varchar(255) NOT NULL,
      "mitigation_plan" varchar(255) NOT NULL,
      "residual_risk" varchar(255),
      CONSTRAINT "poam_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "poam_organization_id_foreign" FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON UPDATE CASCADE
    );`);

    this.addSql(`CREATE TABLE "mitigation_priority" (
      "id" varchar(255) NOT NULL,
      "created_at" timestamptz NOT NULL,
      "updated_at" timestamptz NOT NULL,
      "risk" varchar(255) NOT NULL,
      "priority" int NOT NULL,
      "strategy" text NOT NULL,
      "timeline" varchar(255) NOT NULL,
      "timeframe" text CHECK ("timeframe" IN ('IMMEDIATE', 'SHORT_TERM', 'MEDIUM_TERM', 'LONG_TERM')) NOT NULL,
      "risk_area" varchar(255) NOT NULL,
      "success_criteria" varchar(255) NOT NULL,
      "resources" varchar(255) NOT NULL,
      "estimated_cost" varchar(255) NOT NULL,
      "responsible_party" varchar(255) NOT NULL,
      "organization_id" varchar(255) NOT NULL,
      CONSTRAINT "mitigation_priority_pkey" PRIMARY KEY ("id"),
      CONSTRAINT "mitigation_priority_organization_id_foreign" FOREIGN KEY ("organization_id") REFERENCES "organization"("id") ON UPDATE CASCADE
    );`);
  }
}

================
File: migrations/Migration20241215000001.ts
================
import { Migration } from '@mikro-orm/migrations';

export class Migration20241215000001 extends Migration {
  async up(): Promise<void> {
    this.addSql('alter table "control" add column "base_control_id" varchar(255) null;');
    this.addSql('alter table "control" add constraint "control_base_control_id_foreign" foreign key ("base_control_id") references "control" ("id") on update cascade on delete set null;');
  }

  async down(): Promise<void> {
    this.addSql('alter table "control" drop constraint "control_base_control_id_foreign";');
    this.addSql('alter table "control" drop column "base_control_id";');
  }
}

================
File: migrations/Migration20241215000002.ts
================
import { Migration } from '@mikro-orm/migrations';

export class Migration20241215000002 extends Migration {
  async up(): Promise<void> {
    this.addSql('create table "control_link" ("id" varchar(255) not null, "source_control_id" varchar(255) not null, "target_control_id" varchar(255) not null, "rel" varchar(255) not null, "href" varchar(255) null, constraint "control_link_pkey" primary key ("id"));');
    
    this.addSql('alter table "control_link" add constraint "control_link_source_control_id_foreign" foreign key ("source_control_id") references "control" ("id") on update cascade;');
    this.addSql('alter table "control_link" add constraint "control_link_target_control_id_foreign" foreign key ("target_control_id") references "control" ("id") on update cascade;');
  }

  async down(): Promise<void> {
    this.addSql('drop table if exists "control_link" cascade;');
  }
}

================
File: migrations/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-12T18:41:02.366Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.snapshot-securecenter_v1.json
Migration20241211202532.ts
Migration20241212053500.ts
Migration20241212063915.ts
Migration20241212175619.ts
Migration20241212180400.ts
Migration20241212183455.ts
Migration20241212183500.ts

================================================================
Repository Files
================================================================

================
File: .snapshot-securecenter_v1.json
================
{
  "namespaces": [
    "public"
  ],
  "name": "public",
  "tables": [
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "password": {
          "name": "password",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "first_name": {
          "name": "first_name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "last_name": {
          "name": "last_name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "is_active": {
          "name": "is_active",
          "type": "boolean",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "true",
          "mappedType": "boolean"
        },
        "last_login": {
          "name": "last_login",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        }
      },
      "name": "client_user",
      "schema": "public",
      "indexes": [
        {
          "columnNames": [
            "email"
          ],
          "composite": false,
          "keyName": "client_user_email_unique",
          "constraint": true,
          "primary": false,
          "unique": true
        },
        {
          "keyName": "client_user_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {},
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "name": {
          "name": "name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "type": {
          "name": "type",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "SERVICE_PROVIDER",
            "CLIENT"
          ],
          "mappedType": "enum"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "is_active": {
          "name": "is_active",
          "type": "boolean",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "true",
          "mappedType": "boolean"
        },
        "is_service_provider": {
          "name": "is_service_provider",
          "type": "boolean",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "false",
          "mappedType": "boolean"
        },
        "primary_contact": {
          "name": "primary_contact",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "phone": {
          "name": "phone",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "address": {
          "name": "address",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "organization",
      "schema": "public",
      "indexes": [
        {
          "keyName": "organization_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {},
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "risk": {
          "name": "risk",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "priority": {
          "name": "priority",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "strategy": {
          "name": "strategy",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "text"
        },
        "timeline": {
          "name": "timeline",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "timeframe": {
          "name": "timeframe",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "IMMEDIATE",
            "SHORT_TERM",
            "MEDIUM_TERM",
            "LONG_TERM"
          ],
          "mappedType": "enum"
        },
        "risk_area": {
          "name": "risk_area",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "success_criteria": {
          "name": "success_criteria",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "resources": {
          "name": "resources",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "estimated_cost": {
          "name": "estimated_cost",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "responsible_party": {
          "name": "responsible_party",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "mitigation_priority",
      "schema": "public",
      "indexes": [
        {
          "keyName": "mitigation_priority_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "mitigation_priority_organization_id_foreign": {
          "constraintName": "mitigation_priority_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.mitigation_priority",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "title": {
          "name": "title",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "severity": {
          "name": "severity",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "CRITICAL",
            "HIGH",
            "MEDIUM",
            "LOW"
          ],
          "mappedType": "enum"
        },
        "status": {
          "name": "status",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'OPEN'",
          "enumItems": [
            "OPEN",
            "INVESTIGATING",
            "MITIGATING",
            "RESOLVED",
            "CLOSED"
          ],
          "mappedType": "enum"
        },
        "reporter_id": {
          "name": "reporter_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "assignee_id": {
          "name": "assignee_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "resolution": {
          "name": "resolution",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "resolved_date": {
          "name": "resolved_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        }
      },
      "name": "incident",
      "schema": "public",
      "indexes": [
        {
          "keyName": "incident_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "incident_organization_id_foreign": {
          "constraintName": "incident_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.incident",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        },
        "incident_reporter_id_foreign": {
          "constraintName": "incident_reporter_id_foreign",
          "columnNames": [
            "reporter_id"
          ],
          "localTableName": "public.incident",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.client_user",
          "updateRule": "cascade"
        },
        "incident_assignee_id_foreign": {
          "constraintName": "incident_assignee_id_foreign",
          "columnNames": [
            "assignee_id"
          ],
          "localTableName": "public.incident",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.client_user",
          "deleteRule": "set null",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "title": {
          "name": "title",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "version": {
          "name": "version",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "status": {
          "name": "status",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "review_date": {
          "name": "review_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "next_review_date": {
          "name": "next_review_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "content": {
          "name": "content",
          "type": "jsonb",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "json"
        }
      },
      "name": "continuity_plan",
      "schema": "public",
      "indexes": [
        {
          "keyName": "continuity_plan_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "continuity_plan_organization_id_foreign": {
          "constraintName": "continuity_plan_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.continuity_plan",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "name": {
          "name": "name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "type": {
          "name": "type",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "POLICY",
            "PROCEDURE",
            "DOCUMENTATION",
            "SCAN_RESULT",
            "CONFIGURATION",
            "TRAINING",
            "AUDIT_LOG",
            "EVIDENCE",
            "OTHER"
          ],
          "mappedType": "enum"
        },
        "status": {
          "name": "status",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'DRAFT'",
          "enumItems": [
            "DRAFT",
            "IN_REVIEW",
            "APPROVED",
            "ARCHIVED",
            "REJECTED"
          ],
          "mappedType": "enum"
        },
        "version": {
          "name": "version",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "file_url": {
          "name": "file_url",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "mime_type": {
          "name": "mime_type",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "file_size": {
          "name": "file_size",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "metadata": {
          "name": "metadata",
          "type": "jsonb",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "mappedType": "json"
        },
        "last_reviewed_at": {
          "name": "last_reviewed_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "expires_at": {
          "name": "expires_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "created_by": {
          "name": "created_by",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "last_reviewed_by": {
          "name": "last_reviewed_by",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "approved_by": {
          "name": "approved_by",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "artifact",
      "schema": "public",
      "indexes": [
        {
          "keyName": "artifact_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "artifact_organization_id_foreign": {
          "constraintName": "artifact_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.artifact",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "artifact_id": {
          "name": "artifact_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "version": {
          "name": "version",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "file_url": {
          "name": "file_url",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "changes": {
          "name": "changes",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "created_by": {
          "name": "created_by",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "artifact_revision",
      "schema": "public",
      "indexes": [
        {
          "keyName": "artifact_revision_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "artifact_revision_artifact_id_foreign": {
          "constraintName": "artifact_revision_artifact_id_foreign",
          "columnNames": [
            "artifact_id"
          ],
          "localTableName": "public.artifact_revision",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.artifact",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "finding": {
          "name": "finding",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "recommendation": {
          "name": "recommendation",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "priority": {
          "name": "priority",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "status": {
          "name": "status",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "target_date": {
          "name": "target_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "completion_date": {
          "name": "completion_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "responsible_party": {
          "name": "responsible_party",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "mitigation_plan": {
          "name": "mitigation_plan",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "residual_risk": {
          "name": "residual_risk",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "poam",
      "schema": "public",
      "indexes": [
        {
          "keyName": "poam_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "poam_organization_id_foreign": {
          "constraintName": "poam_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.poam",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "annual_loss": {
          "name": "annual_loss",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "probability_of_occurrence": {
          "name": "probability_of_occurrence",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "impact_score": {
          "name": "impact_score",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "risk_score": {
          "name": "risk_score",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "quantitative_risk",
      "schema": "public",
      "indexes": [
        {
          "keyName": "quantitative_risk_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "quantitative_risk_organization_id_foreign": {
          "constraintName": "quantitative_risk_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.quantitative_risk",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "impact": {
          "name": "impact",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "likelihood": {
          "name": "likelihood",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "value": {
          "name": "value",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "risk_matrix_entry",
      "schema": "public",
      "indexes": [
        {
          "keyName": "risk_matrix_entry_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "risk_matrix_entry_organization_id_foreign": {
          "constraintName": "risk_matrix_entry_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.risk_matrix_entry",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "business_functions": {
          "name": "business_functions",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "text"
        },
        "key_assets": {
          "name": "key_assets",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "text"
        },
        "compliance_frameworks": {
          "name": "compliance_frameworks",
          "type": "text[]",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "array"
        },
        "data_types": {
          "name": "data_types",
          "type": "text[]",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "array"
        },
        "operational_risk": {
          "name": "operational_risk",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "LOW",
            "MEDIUM",
            "HIGH",
            "CRITICAL"
          ],
          "mappedType": "enum"
        },
        "data_security_risk": {
          "name": "data_security_risk",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "LOW",
            "MEDIUM",
            "HIGH",
            "CRITICAL"
          ],
          "mappedType": "enum"
        },
        "compliance_risk": {
          "name": "compliance_risk",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "LOW",
            "MEDIUM",
            "HIGH",
            "CRITICAL"
          ],
          "mappedType": "enum"
        },
        "financial_risk": {
          "name": "financial_risk",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "LOW",
            "MEDIUM",
            "HIGH",
            "CRITICAL"
          ],
          "mappedType": "enum"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "risk_profile",
      "schema": "public",
      "indexes": [
        {
          "columnNames": [
            "organization_id"
          ],
          "composite": false,
          "keyName": "risk_profile_organization_id_unique",
          "constraint": true,
          "primary": false,
          "unique": true
        },
        {
          "keyName": "risk_profile_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "risk_profile_organization_id_foreign": {
          "constraintName": "risk_profile_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.risk_profile",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "provider_id": {
          "name": "provider_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "client_id": {
          "name": "client_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "status": {
          "name": "status",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "start_date": {
          "name": "start_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "end_date": {
          "name": "end_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "contract_details": {
          "name": "contract_details",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "service_provider_client",
      "schema": "public",
      "indexes": [
        {
          "keyName": "service_provider_client_provider_id_client_id_unique",
          "columnNames": [
            "provider_id",
            "client_id"
          ],
          "composite": true,
          "constraint": true,
          "primary": false,
          "unique": true
        },
        {
          "keyName": "service_provider_client_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "service_provider_client_provider_id_foreign": {
          "constraintName": "service_provider_client_provider_id_foreign",
          "columnNames": [
            "provider_id"
          ],
          "localTableName": "public.service_provider_client",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        },
        "service_provider_client_client_id_foreign": {
          "constraintName": "service_provider_client_client_id_foreign",
          "columnNames": [
            "client_id"
          ],
          "localTableName": "public.service_provider_client",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "name": {
          "name": "name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "system_type": {
          "name": "system_type",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "WEB_APPLICATION",
            "NETWORK_SYSTEM",
            "DATABASE_SYSTEM",
            "CLOUD_SERVICE",
            "LEGACY_SYSTEM",
            "OTHER"
          ],
          "mappedType": "enum"
        },
        "criticality": {
          "name": "criticality",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "HIGH",
            "MODERATE",
            "LOW"
          ],
          "mappedType": "enum"
        },
        "status": {
          "name": "status",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'ACTIVE'",
          "enumItems": [
            "ACTIVE",
            "INACTIVE",
            "DECOMMISSIONED",
            "UNDER_DEVELOPMENT"
          ],
          "mappedType": "enum"
        },
        "owner": {
          "name": "owner",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "custodian": {
          "name": "custodian",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "boundaries": {
          "name": "boundaries",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "location": {
          "name": "location",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "system",
      "schema": "public",
      "indexes": [
        {
          "keyName": "system_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "system_organization_id_foreign": {
          "constraintName": "system_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.system",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "system_id": {
          "name": "system_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "name": {
          "name": "name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "framework": {
          "name": "framework",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "status": {
          "name": "status",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'DRAFT'",
          "enumItems": [
            "DRAFT",
            "IN_PROGRESS",
            "UNDER_REVIEW",
            "APPROVED",
            "REJECTED",
            "EXPIRED"
          ],
          "mappedType": "enum"
        },
        "current_phase": {
          "name": "current_phase",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'PREPARATION'",
          "enumItems": [
            "PREPARATION",
            "INITIAL_ASSESSMENT",
            "CONTROL_IMPLEMENTATION",
            "TESTING",
            "VALIDATION",
            "FINAL_REVIEW",
            "AUTHORIZATION",
            "MONITORING"
          ],
          "mappedType": "enum"
        },
        "valid_from": {
          "name": "valid_from",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "valid_until": {
          "name": "valid_until",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "last_assessment": {
          "name": "last_assessment",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "next_assessment": {
          "name": "next_assessment",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        }
      },
      "name": "atopackage",
      "schema": "public",
      "indexes": [
        {
          "keyName": "atopackage_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "atopackage_system_id_foreign": {
          "constraintName": "atopackage_system_id_foreign",
          "columnNames": [
            "system_id"
          ],
          "localTableName": "public.atopackage",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.system",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "ato_package_id": {
          "name": "ato_package_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "control_id": {
          "name": "control_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "title": {
          "name": "title",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "status": {
          "name": "status",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'NOT_IMPLEMENTED'",
          "enumItems": [
            "NOT_IMPLEMENTED",
            "PLANNED",
            "PARTIALLY_IMPLEMENTED",
            "IMPLEMENTED",
            "NOT_APPLICABLE"
          ],
          "mappedType": "enum"
        },
        "implementation_status": {
          "name": "implementation_status",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "test_results": {
          "name": "test_results",
          "type": "jsonb",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "mappedType": "json"
        },
        "tested_date": {
          "name": "tested_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        }
      },
      "name": "control_assessment",
      "schema": "public",
      "indexes": [
        {
          "keyName": "control_assessment_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "control_assessment_ato_package_id_foreign": {
          "constraintName": "control_assessment_ato_package_id_foreign",
          "columnNames": [
            "ato_package_id"
          ],
          "localTableName": "public.control_assessment",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.atopackage",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "control_id": {
          "name": "control_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "type": {
          "name": "type",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "enumItems": [
            "SSP",
            "RAR",
            "SAR",
            "SAP",
            "POA_M",
            "EVIDENCE",
            "POLICY",
            "PROCEDURE",
            "CONFIGURATION",
            "TEST_RESULT",
            "OTHER"
          ],
          "mappedType": "enum"
        },
        "title": {
          "name": "title",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "version": {
          "name": "version",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "file_url": {
          "name": "file_url",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "mime_type": {
          "name": "mime_type",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "file_size": {
          "name": "file_size",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "mappedType": "integer"
        },
        "status": {
          "name": "status",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'PENDING'",
          "enumItems": [
            "PENDING",
            "APPROVED",
            "REJECTED",
            "NEEDS_WORK"
          ],
          "mappedType": "enum"
        },
        "metadata": {
          "name": "metadata",
          "type": "jsonb",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "mappedType": "json"
        }
      },
      "name": "document",
      "schema": "public",
      "indexes": [
        {
          "keyName": "document_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "document_control_id_foreign": {
          "constraintName": "document_control_id_foreign",
          "columnNames": [
            "control_id"
          ],
          "localTableName": "public.document",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.control_assessment",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "control_id": {
          "name": "control_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "artifact_id": {
          "name": "artifact_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "association": {
          "name": "association",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "notes": {
          "name": "notes",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "control_artifact",
      "schema": "public",
      "indexes": [
        {
          "keyName": "control_artifact_control_id_artifact_id_unique",
          "columnNames": [
            "control_id",
            "artifact_id"
          ],
          "composite": true,
          "constraint": true,
          "primary": false,
          "unique": true
        },
        {
          "keyName": "control_artifact_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "control_artifact_control_id_foreign": {
          "constraintName": "control_artifact_control_id_foreign",
          "columnNames": [
            "control_id"
          ],
          "localTableName": "public.control_artifact",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.control_assessment",
          "updateRule": "cascade"
        },
        "control_artifact_artifact_id_foreign": {
          "constraintName": "control_artifact_artifact_id_foreign",
          "columnNames": [
            "artifact_id"
          ],
          "localTableName": "public.control_artifact",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.artifact",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "entity_type": {
          "name": "entity_type",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "entity_id": {
          "name": "entity_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "approver_id": {
          "name": "approver_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "status": {
          "name": "status",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'PENDING'",
          "enumItems": [
            "PENDING",
            "APPROVED",
            "REJECTED",
            "NEEDS_WORK"
          ],
          "mappedType": "enum"
        },
        "comments": {
          "name": "comments",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "approved_at": {
          "name": "approved_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "document_id": {
          "name": "document_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "control_assessment_id": {
          "name": "control_assessment_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "ato_package_id": {
          "name": "ato_package_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "continuity_plan_id": {
          "name": "continuity_plan_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "poam_id": {
          "name": "poam_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "approval",
      "schema": "public",
      "indexes": [
        {
          "keyName": "approval_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "approval_approver_id_foreign": {
          "constraintName": "approval_approver_id_foreign",
          "columnNames": [
            "approver_id"
          ],
          "localTableName": "public.approval",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.client_user",
          "updateRule": "cascade"
        },
        "approval_document_id_foreign": {
          "constraintName": "approval_document_id_foreign",
          "columnNames": [
            "document_id"
          ],
          "localTableName": "public.approval",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.document",
          "deleteRule": "set null",
          "updateRule": "cascade"
        },
        "approval_control_assessment_id_foreign": {
          "constraintName": "approval_control_assessment_id_foreign",
          "columnNames": [
            "control_assessment_id"
          ],
          "localTableName": "public.approval",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.control_assessment",
          "deleteRule": "set null",
          "updateRule": "cascade"
        },
        "approval_ato_package_id_foreign": {
          "constraintName": "approval_ato_package_id_foreign",
          "columnNames": [
            "ato_package_id"
          ],
          "localTableName": "public.approval",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.atopackage",
          "deleteRule": "set null",
          "updateRule": "cascade"
        },
        "approval_continuity_plan_id_foreign": {
          "constraintName": "approval_continuity_plan_id_foreign",
          "columnNames": [
            "continuity_plan_id"
          ],
          "localTableName": "public.approval",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.continuity_plan",
          "deleteRule": "set null",
          "updateRule": "cascade"
        },
        "approval_poam_id_foreign": {
          "constraintName": "approval_poam_id_foreign",
          "columnNames": [
            "poam_id"
          ],
          "localTableName": "public.approval",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.poam",
          "deleteRule": "set null",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "system_id": {
          "name": "system_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "name": {
          "name": "name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "type": {
          "name": "type",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "status": {
          "name": "status",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_by_id": {
          "name": "created_by_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "version": {
          "name": "version",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "location": {
          "name": "location",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "purchase_date": {
          "name": "purchase_date",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        },
        "end_of_life": {
          "name": "end_of_life",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        }
      },
      "name": "asset",
      "schema": "public",
      "indexes": [
        {
          "keyName": "asset_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "asset_system_id_foreign": {
          "constraintName": "asset_system_id_foreign",
          "columnNames": [
            "system_id"
          ],
          "localTableName": "public.asset",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.system",
          "updateRule": "cascade"
        },
        "asset_created_by_id_foreign": {
          "constraintName": "asset_created_by_id_foreign",
          "columnNames": [
            "created_by_id"
          ],
          "localTableName": "public.asset",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.client_user",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "asset_id": {
          "name": "asset_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "port": {
          "name": "port",
          "type": "int",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "integer"
        },
        "protocol": {
          "name": "protocol",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "service": {
          "name": "service",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "description": {
          "name": "description",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "status": {
          "name": "status",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "last_scan": {
          "name": "last_scan",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        }
      },
      "name": "port_mapping",
      "schema": "public",
      "indexes": [
        {
          "keyName": "port_mapping_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "port_mapping_asset_id_foreign": {
          "constraintName": "port_mapping_asset_id_foreign",
          "columnNames": [
            "asset_id"
          ],
          "localTableName": "public.port_mapping",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.asset",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "incident_id": {
          "name": "incident_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "asset_id": {
          "name": "asset_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "incident_affected_assets",
      "schema": "public",
      "indexes": [
        {
          "keyName": "incident_affected_assets_pkey",
          "columnNames": [
            "incident_id",
            "asset_id"
          ],
          "composite": true,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "incident_affected_assets_incident_id_foreign": {
          "constraintName": "incident_affected_assets_incident_id_foreign",
          "columnNames": [
            "incident_id"
          ],
          "localTableName": "public.incident_affected_assets",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.incident",
          "deleteRule": "cascade",
          "updateRule": "cascade"
        },
        "incident_affected_assets_asset_id_foreign": {
          "constraintName": "incident_affected_assets_asset_id_foreign",
          "columnNames": [
            "asset_id"
          ],
          "localTableName": "public.incident_affected_assets",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.asset",
          "deleteRule": "cascade",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "password": {
          "name": "password",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "first_name": {
          "name": "first_name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "last_name": {
          "name": "last_name",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "role": {
          "name": "role",
          "type": "text",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "'ADMIN'",
          "enumItems": [
            "GLOBAL_ADMIN",
            "ADMIN",
            "USER"
          ],
          "mappedType": "enum"
        },
        "is_active": {
          "name": "is_active",
          "type": "boolean",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "true",
          "mappedType": "boolean"
        },
        "last_login": {
          "name": "last_login",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 6,
          "mappedType": "datetime"
        }
      },
      "name": "system_user",
      "schema": "public",
      "indexes": [
        {
          "columnNames": [
            "email"
          ],
          "composite": false,
          "keyName": "system_user_email_unique",
          "constraint": true,
          "primary": false,
          "unique": true
        },
        {
          "keyName": "system_user_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {},
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "system_user_id": {
          "name": "system_user_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "client_user_id": {
          "name": "client_user_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "action": {
          "name": "action",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "entity_type": {
          "name": "entity_type",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "entity_id": {
          "name": "entity_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "details": {
          "name": "details",
          "type": "jsonb",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "mappedType": "json"
        },
        "ip_address": {
          "name": "ip_address",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "user_agent": {
          "name": "user_agent",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        }
      },
      "name": "audit_log",
      "schema": "public",
      "indexes": [
        {
          "keyName": "audit_log_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "audit_log_organization_id_foreign": {
          "constraintName": "audit_log_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.audit_log",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        },
        "audit_log_system_user_id_foreign": {
          "constraintName": "audit_log_system_user_id_foreign",
          "columnNames": [
            "system_user_id"
          ],
          "localTableName": "public.audit_log",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.system_user",
          "deleteRule": "set null",
          "updateRule": "cascade"
        },
        "audit_log_client_user_id_foreign": {
          "constraintName": "audit_log_client_user_id_foreign",
          "columnNames": [
            "client_user_id"
          ],
          "localTableName": "public.audit_log",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.client_user",
          "deleteRule": "set null",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    },
    {
      "columns": {
        "id": {
          "name": "id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamptz",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 6,
          "mappedType": "datetime"
        },
        "organization_id": {
          "name": "organization_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "length": 255,
          "mappedType": "string"
        },
        "system_user_id": {
          "name": "system_user_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "client_user_id": {
          "name": "client_user_id",
          "type": "varchar(255)",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": true,
          "length": 255,
          "mappedType": "string"
        },
        "is_active": {
          "name": "is_active",
          "type": "boolean",
          "unsigned": false,
          "autoincrement": false,
          "primary": false,
          "nullable": false,
          "default": "true",
          "mappedType": "boolean"
        }
      },
      "name": "user_organization",
      "schema": "public",
      "indexes": [
        {
          "keyName": "user_organization_pkey",
          "columnNames": [
            "id"
          ],
          "composite": false,
          "constraint": true,
          "primary": true,
          "unique": true
        }
      ],
      "checks": [],
      "foreignKeys": {
        "user_organization_organization_id_foreign": {
          "constraintName": "user_organization_organization_id_foreign",
          "columnNames": [
            "organization_id"
          ],
          "localTableName": "public.user_organization",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.organization",
          "updateRule": "cascade"
        },
        "user_organization_system_user_id_foreign": {
          "constraintName": "user_organization_system_user_id_foreign",
          "columnNames": [
            "system_user_id"
          ],
          "localTableName": "public.user_organization",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.system_user",
          "deleteRule": "set null",
          "updateRule": "cascade"
        },
        "user_organization_client_user_id_foreign": {
          "constraintName": "user_organization_client_user_id_foreign",
          "columnNames": [
            "client_user_id"
          ],
          "localTableName": "public.user_organization",
          "referencedColumnNames": [
            "id"
          ],
          "referencedTableName": "public.client_user",
          "deleteRule": "set null",
          "updateRule": "cascade"
        }
      },
      "nativeEnums": {}
    }
  ],
  "nativeEnums": {}
}

================
File: Migration20241211202532.ts
================
import { Migration } from '@mikro-orm/migrations';

export class Migration20241211202532 extends Migration {

  override async up(): Promise<void> {
    this.addSql(`create table "organization" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "name" varchar(255) not null, "type" text check ("type" in ('SERVICE_PROVIDER', 'CLIENT')) not null, "description" varchar(255) null, "is_active" boolean not null default true, "is_service_provider" boolean not null default false, "primary_contact" varchar(255) null, "email" varchar(255) null, "phone" varchar(255) null, "address" varchar(255) null, constraint "organization_pkey" primary key ("id"));`);

    this.addSql(`create table "continuity_plan" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "organization_id" varchar(255) not null, "title" varchar(255) not null, "version" varchar(255) not null, "status" varchar(255) not null, "review_date" timestamptz not null, "next_review_date" timestamptz not null, "content" jsonb not null, constraint "continuity_plan_pkey" primary key ("id"));`);

    this.addSql(`create table "artifact" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "organization_id" varchar(255) not null, "name" varchar(255) not null, "description" varchar(255) null, "type" text check ("type" in ('POLICY', 'PROCEDURE', 'DOCUMENTATION', 'SCAN_RESULT', 'CONFIGURATION', 'TRAINING', 'AUDIT_LOG', 'EVIDENCE', 'OTHER')) not null, "status" text check ("status" in ('DRAFT', 'IN_REVIEW', 'APPROVED', 'ARCHIVED', 'REJECTED')) not null default 'DRAFT', "version" varchar(255) not null, "file_url" varchar(255) not null, "mime_type" varchar(255) not null, "file_size" int not null, "metadata" jsonb null, "last_reviewed_at" timestamptz null, "expires_at" timestamptz null, "created_by" varchar(255) not null, "last_reviewed_by" varchar(255) null, "approved_by" varchar(255) null, constraint "artifact_pkey" primary key ("id"));`);

    this.addSql(`create table "artifact_revision" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "artifact_id" varchar(255) not null, "version" varchar(255) not null, "file_url" varchar(255) not null, "changes" varchar(255) null, "created_by" varchar(255) not null, constraint "artifact_revision_pkey" primary key ("id"));`);

    this.addSql(`create table "poam" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "organization_id" varchar(255) not null, "finding" varchar(255) not null, "recommendation" varchar(255) not null, "priority" varchar(255) not null, "status" varchar(255) not null, "target_date" timestamptz not null, "completion_date" timestamptz null, "responsible_party" varchar(255) not null, "mitigation_plan" varchar(255) not null, "residual_risk" varchar(255) null, constraint "poam_pkey" primary key ("id"));`);

    this.addSql(`create table "service_provider_client" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "provider_id" varchar(255) not null, "client_id" varchar(255) not null, "status" varchar(255) not null, "start_date" timestamptz not null, "end_date" timestamptz null, "contract_details" varchar(255) null, constraint "service_provider_client_pkey" primary key ("id"));`);
    this.addSql(`alter table "service_provider_client" add constraint "service_provider_client_provider_id_client_id_unique" unique ("provider_id", "client_id");`);

    this.addSql(`create table "system" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "organization_id" varchar(255) not null, "name" varchar(255) not null, "description" varchar(255) null, "system_type" text check ("system_type" in ('WEB_APPLICATION', 'NETWORK_SYSTEM', 'DATABASE_SYSTEM', 'CLOUD_SERVICE', 'LEGACY_SYSTEM', 'OTHER')) not null, "criticality" text check ("criticality" in ('HIGH', 'MODERATE', 'LOW')) not null, "status" text check ("status" in ('ACTIVE', 'INACTIVE', 'DECOMMISSIONED', 'UNDER_DEVELOPMENT')) not null default 'ACTIVE', "owner" varchar(255) null, "custodian" varchar(255) null, "boundaries" varchar(255) null, "location" varchar(255) null, constraint "system_pkey" primary key ("id"));`);

    this.addSql(`create table "atopackage" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "system_id" varchar(255) not null, "name" varchar(255) not null, "description" varchar(255) null, "framework" varchar(255) not null, "status" text check ("status" in ('DRAFT', 'IN_PROGRESS', 'UNDER_REVIEW', 'APPROVED', 'REJECTED', 'EXPIRED')) not null default 'DRAFT', "current_phase" text check ("current_phase" in ('PREPARATION', 'INITIAL_ASSESSMENT', 'CONTROL_IMPLEMENTATION', 'TESTING', 'VALIDATION', 'FINAL_REVIEW', 'AUTHORIZATION', 'MONITORING')) not null default 'PREPARATION', "valid_from" timestamptz null, "valid_until" timestamptz null, "last_assessment" timestamptz null, "next_assessment" timestamptz null, constraint "atopackage_pkey" primary key ("id"));`);

    this.addSql(`create table "control_assessment" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "ato_package_id" varchar(255) not null, "control_id" varchar(255) not null, "title" varchar(255) not null, "description" varchar(255) null, "status" text check ("status" in ('NOT_IMPLEMENTED', 'PLANNED', 'PARTIALLY_IMPLEMENTED', 'IMPLEMENTED', 'NOT_APPLICABLE')) not null default 'NOT_IMPLEMENTED', "implementation_status" varchar(255) null, "test_results" jsonb null, "tested_date" timestamptz null, constraint "control_assessment_pkey" primary key ("id"));`);

    this.addSql(`create table "document" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "control_id" varchar(255) not null, "type" text check ("type" in ('SSP', 'RAR', 'SAR', 'SAP', 'POA_M', 'EVIDENCE', 'POLICY', 'PROCEDURE', 'CONFIGURATION', 'TEST_RESULT', 'OTHER')) not null, "title" varchar(255) not null, "description" varchar(255) null, "version" varchar(255) not null, "file_url" varchar(255) not null, "mime_type" varchar(255) null, "file_size" int null, "status" text check ("status" in ('PENDING', 'APPROVED', 'REJECTED', 'NEEDS_WORK')) not null default 'PENDING', "metadata" jsonb null, constraint "document_pkey" primary key ("id"));`);

    this.addSql(`create table "control_artifact" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "control_id" varchar(255) not null, "artifact_id" varchar(255) not null, "association" varchar(255) not null, "notes" varchar(255) null, constraint "control_artifact_pkey" primary key ("id"));`);
    this.addSql(`alter table "control_artifact" add constraint "control_artifact_control_id_artifact_id_unique" unique ("control_id", "artifact_id");`);

    this.addSql(`create table "user" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "email" varchar(255) not null, "password" varchar(255) not null, "name" varchar(255) not null, "system_role" text check ("system_role" in ('GLOBAL_ADMIN', 'ADMIN', 'USER')) not null default 'USER', "is_active" boolean not null default true, "last_login" timestamptz null, constraint "user_pkey" primary key ("id"));`);
    this.addSql(`alter table "user" add constraint "user_email_unique" unique ("email");`);

    this.addSql(`create table "incident" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "organization_id" varchar(255) not null, "title" varchar(255) not null, "description" varchar(255) not null, "severity" text check ("severity" in ('CRITICAL', 'HIGH', 'MEDIUM', 'LOW')) not null, "status" text check ("status" in ('OPEN', 'INVESTIGATING', 'MITIGATING', 'RESOLVED', 'CLOSED')) not null default 'OPEN', "reporter_id" varchar(255) not null, "assignee_id" varchar(255) null, "resolution" varchar(255) null, "resolved_date" timestamptz null, constraint "incident_pkey" primary key ("id"));`);

    this.addSql(`create table "audit_log" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "organization_id" varchar(255) not null, "user_id" varchar(255) not null, "action" varchar(255) not null, "entity_type" varchar(255) not null, "entity_id" varchar(255) not null, "details" jsonb not null, "ip_address" varchar(255) null, "user_agent" varchar(255) null, constraint "audit_log_pkey" primary key ("id"));`);

    this.addSql(`create table "asset" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "system_id" varchar(255) not null, "name" varchar(255) not null, "type" varchar(255) not null, "status" varchar(255) not null, "created_by_id" varchar(255) not null, "description" varchar(255) null, "version" varchar(255) null, "location" varchar(255) null, "purchase_date" timestamptz null, "end_of_life" timestamptz null, constraint "asset_pkey" primary key ("id"));`);

    this.addSql(`create table "port_mapping" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "asset_id" varchar(255) not null, "port" int not null, "protocol" varchar(255) not null, "service" varchar(255) not null, "description" varchar(255) null, "status" varchar(255) not null, "last_scan" timestamptz null, constraint "port_mapping_pkey" primary key ("id"));`);

    this.addSql(`create table "incident_affected_assets" ("incident_id" varchar(255) not null, "asset_id" varchar(255) not null, constraint "incident_affected_assets_pkey" primary key ("incident_id", "asset_id"));`);

    this.addSql(`create table "approval" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "entity_type" varchar(255) not null, "entity_id" varchar(255) not null, "approver_id" varchar(255) not null, "status" text check ("status" in ('PENDING', 'APPROVED', 'REJECTED', 'NEEDS_WORK')) not null default 'PENDING', "comments" varchar(255) null, "approved_at" timestamptz null, "document_id" varchar(255) null, "control_assessment_id" varchar(255) null, "ato_package_id" varchar(255) null, "continuity_plan_id" varchar(255) null, "poam_id" varchar(255) null, constraint "approval_pkey" primary key ("id"));`);

    this.addSql(`create table "user_organization" ("id" varchar(255) not null, "created_at" timestamptz not null, "updated_at" timestamptz not null, "user_id" varchar(255) not null, "organization_id" varchar(255) not null, "org_role" text check ("org_role" in ('AODR', 'SCA', 'SCAR', 'AUDITOR', 'ISSM', 'ISSO')) not null, "is_active" boolean not null default true, constraint "user_organization_pkey" primary key ("id"));`);
    this.addSql(`alter table "user_organization" add constraint "user_organization_user_id_organization_id_unique" unique ("user_id", "organization_id");`);

    this.addSql(`alter table "continuity_plan" add constraint "continuity_plan_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);

    this.addSql(`alter table "artifact" add constraint "artifact_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);

    this.addSql(`alter table "artifact_revision" add constraint "artifact_revision_artifact_id_foreign" foreign key ("artifact_id") references "artifact" ("id") on update cascade;`);

    this.addSql(`alter table "poam" add constraint "poam_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);

    this.addSql(`alter table "service_provider_client" add constraint "service_provider_client_provider_id_foreign" foreign key ("provider_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "service_provider_client" add constraint "service_provider_client_client_id_foreign" foreign key ("client_id") references "organization" ("id") on update cascade;`);

    this.addSql(`alter table "system" add constraint "system_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);

    this.addSql(`alter table "atopackage" add constraint "atopackage_system_id_foreign" foreign key ("system_id") references "system" ("id") on update cascade;`);

    this.addSql(`alter table "control_assessment" add constraint "control_assessment_ato_package_id_foreign" foreign key ("ato_package_id") references "atopackage" ("id") on update cascade;`);

    this.addSql(`alter table "document" add constraint "document_control_id_foreign" foreign key ("control_id") references "control_assessment" ("id") on update cascade;`);

    this.addSql(`alter table "control_artifact" add constraint "control_artifact_control_id_foreign" foreign key ("control_id") references "control_assessment" ("id") on update cascade;`);
    this.addSql(`alter table "control_artifact" add constraint "control_artifact_artifact_id_foreign" foreign key ("artifact_id") references "artifact" ("id") on update cascade;`);

    this.addSql(`alter table "incident" add constraint "incident_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "incident" add constraint "incident_reporter_id_foreign" foreign key ("reporter_id") references "user" ("id") on update cascade;`);
    this.addSql(`alter table "incident" add constraint "incident_assignee_id_foreign" foreign key ("assignee_id") references "user" ("id") on update cascade on delete set null;`);

    this.addSql(`alter table "audit_log" add constraint "audit_log_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "audit_log" add constraint "audit_log_user_id_foreign" foreign key ("user_id") references "user" ("id") on update cascade;`);

    this.addSql(`alter table "asset" add constraint "asset_system_id_foreign" foreign key ("system_id") references "system" ("id") on update cascade;`);
    this.addSql(`alter table "asset" add constraint "asset_created_by_id_foreign" foreign key ("created_by_id") references "user" ("id") on update cascade;`);

    this.addSql(`alter table "port_mapping" add constraint "port_mapping_asset_id_foreign" foreign key ("asset_id") references "asset" ("id") on update cascade;`);

    this.addSql(`alter table "incident_affected_assets" add constraint "incident_affected_assets_incident_id_foreign" foreign key ("incident_id") references "incident" ("id") on update cascade on delete cascade;`);
    this.addSql(`alter table "incident_affected_assets" add constraint "incident_affected_assets_asset_id_foreign" foreign key ("asset_id") references "asset" ("id") on update cascade on delete cascade;`);

    this.addSql(`alter table "approval" add constraint "approval_approver_id_foreign" foreign key ("approver_id") references "user" ("id") on update cascade;`);
    this.addSql(`alter table "approval" add constraint "approval_document_id_foreign" foreign key ("document_id") references "document" ("id") on update cascade on delete set null;`);
    this.addSql(`alter table "approval" add constraint "approval_control_assessment_id_foreign" foreign key ("control_assessment_id") references "control_assessment" ("id") on update cascade on delete set null;`);
    this.addSql(`alter table "approval" add constraint "approval_ato_package_id_foreign" foreign key ("ato_package_id") references "atopackage" ("id") on update cascade on delete set null;`);
    this.addSql(`alter table "approval" add constraint "approval_continuity_plan_id_foreign" foreign key ("continuity_plan_id") references "continuity_plan" ("id") on update cascade on delete set null;`);
    this.addSql(`alter table "approval" add constraint "approval_poam_id_foreign" foreign key ("poam_id") references "poam" ("id") on update cascade on delete set null;`);

    this.addSql(`alter table "user_organization" add constraint "user_organization_user_id_foreign" foreign key ("user_id") references "user" ("id") on update cascade;`);
    this.addSql(`alter table "user_organization" add constraint "user_organization_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
  }

}

================
File: Migration20241212053500.ts
================
import { Migration } from '@mikro-orm/migrations';

export class Migration20241212053500 extends Migration {

  override async up(): Promise<void> {
    this.addSql(`create table "risk_profile" (
      "id" varchar(255) not null, 
      "created_at" timestamptz not null, 
      "updated_at" timestamptz not null, 
      "business_functions" varchar(255) not null,
      "key_assets" varchar(255) not null,
      "compliance_frameworks" text[] not null,
      "data_types" text[] not null,
      "operational_risk" text check ("operational_risk" in ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')) not null,
      "data_security_risk" text check ("data_security_risk" in ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')) not null,
      "compliance_risk" text check ("compliance_risk" in ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')) not null,
      "financial_risk" text check ("financial_risk" in ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')) not null,
      "organization_id" varchar(255) not null,
      constraint "risk_profile_pkey" primary key ("id")
    );`);

    this.addSql(`create table "quantitative_risk" (
      "id" varchar(255) not null,
      "created_at" timestamptz not null,
      "updated_at" timestamptz not null,
      "annual_loss" int not null,
      "probability_of_occurrence" float not null,
      "impact_score" float not null,
      "risk_score" float not null,
      "organization_id" varchar(255) not null,
      constraint "quantitative_risk_pkey" primary key ("id")
    );`);

    this.addSql(`create table "risk_matrix_entry" (
      "id" varchar(255) not null,
      "created_at" timestamptz not null,
      "updated_at" timestamptz not null,
      "impact" int not null,
      "likelihood" int not null,
      "value" int not null,
      "organization_id" varchar(255) not null,
      constraint "risk_matrix_entry_pkey" primary key ("id")
    );`);

    this.addSql(`create table "mitigation_priority" (
      "id" varchar(255) not null,
      "created_at" timestamptz not null,
      "updated_at" timestamptz not null,
      "risk" varchar(255) not null,
      "priority" int not null,
      "strategy" varchar(255) not null,
      "timeline" varchar(255) not null,
      "timeframe" text check ("timeframe" in ('IMMEDIATE', 'SHORT_TERM', 'MEDIUM_TERM', 'LONG_TERM')) not null,
      "risk_area" varchar(255) not null,
      "success_criteria" varchar(255) not null,
      "resources" varchar(255) not null,
      "estimated_cost" varchar(255) not null,
      "responsible_party" varchar(255) not null,
      "organization_id" varchar(255) not null,
      constraint "mitigation_priority_pkey" primary key ("id")
    );`);

    this.addSql(`alter table "risk_profile" add constraint "risk_profile_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "quantitative_risk" add constraint "quantitative_risk_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "risk_matrix_entry" add constraint "risk_matrix_entry_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "mitigation_priority" add constraint "mitigation_priority_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
  }

}

================
File: Migration20241212063915.ts
================
import { Migration } from '@mikro-orm/migrations';

export class Migration20241212063915 extends Migration {

  override async up(): Promise<void> {
    // Drop existing foreign key constraints
    this.addSql(`alter table "user_organization" drop constraint if exists "user_organization_organization_id_foreign";`);
    this.addSql(`alter table "service_provider_client" drop constraint if exists "service_provider_client_provider_id_foreign";`);
    this.addSql(`alter table "service_provider_client" drop constraint if exists "service_provider_client_client_id_foreign";`);
    this.addSql(`alter table "system" drop constraint if exists "system_organization_id_foreign";`);
    this.addSql(`alter table "incident" drop constraint if exists "incident_organization_id_foreign";`);
    this.addSql(`alter table "continuity_plan" drop constraint if exists "continuity_plan_organization_id_foreign";`);
    this.addSql(`alter table "poam" drop constraint if exists "poam_organization_id_foreign";`);
    this.addSql(`alter table "audit_log" drop constraint if exists "audit_log_organization_id_foreign";`);
    this.addSql(`alter table "artifact" drop constraint if exists "artifact_organization_id_foreign";`);
    this.addSql(`alter table "mitigation_priority" drop constraint if exists "mitigation_priority_organization_id_foreign";`);
    this.addSql(`alter table "quantitative_risk" drop constraint if exists "quantitative_risk_organization_id_foreign";`);
    this.addSql(`alter table "risk_matrix_entry" drop constraint if exists "risk_matrix_entry_organization_id_foreign";`);
    this.addSql(`alter table "risk_profile" drop constraint if exists "risk_profile_organization_id_foreign";`);

    // Add constraints back with ON DELETE CASCADE
    this.addSql(`alter table "user_organization" add constraint "user_organization_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
    this.addSql(`alter table "service_provider_client" add constraint "service_provider_client_provider_id_foreign" foreign key ("provider_id") references "organization" ("id") on update cascade on delete cascade;`);
    this.addSql(`alter table "service_provider_client" add constraint "service_provider_client_client_id_foreign" foreign key ("client_id") references "organization" ("id") on update cascade on delete cascade;`);
    this.addSql(`alter table "system" add constraint "system_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
    this.addSql(`alter table "incident" add constraint "incident_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
    this.addSql(`alter table "continuity_plan" add constraint "continuity_plan_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
    this.addSql(`alter table "poam" add constraint "poam_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
    this.addSql(`alter table "audit_log" add constraint "audit_log_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
    this.addSql(`alter table "artifact" add constraint "artifact_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
    this.addSql(`alter table "mitigation_priority" add constraint "mitigation_priority_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
    this.addSql(`alter table "quantitative_risk" add constraint "quantitative_risk_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
    this.addSql(`alter table "risk_matrix_entry" add constraint "risk_matrix_entry_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
    this.addSql(`alter table "risk_profile" add constraint "risk_profile_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade on delete cascade;`);
  }

  override async down(): Promise<void> {
    // Remove cascade delete constraints
    this.addSql(`alter table "user_organization" drop constraint if exists "user_organization_organization_id_foreign";`);
    this.addSql(`alter table "service_provider_client" drop constraint if exists "service_provider_client_provider_id_foreign";`);
    this.addSql(`alter table "service_provider_client" drop constraint if exists "service_provider_client_client_id_foreign";`);
    this.addSql(`alter table "system" drop constraint if exists "system_organization_id_foreign";`);
    this.addSql(`alter table "incident" drop constraint if exists "incident_organization_id_foreign";`);
    this.addSql(`alter table "continuity_plan" drop constraint if exists "continuity_plan_organization_id_foreign";`);
    this.addSql(`alter table "poam" drop constraint if exists "poam_organization_id_foreign";`);
    this.addSql(`alter table "audit_log" drop constraint if exists "audit_log_organization_id_foreign";`);
    this.addSql(`alter table "artifact" drop constraint if exists "artifact_organization_id_foreign";`);
    this.addSql(`alter table "mitigation_priority" drop constraint if exists "mitigation_priority_organization_id_foreign";`);
    this.addSql(`alter table "quantitative_risk" drop constraint if exists "quantitative_risk_organization_id_foreign";`);
    this.addSql(`alter table "risk_matrix_entry" drop constraint if exists "risk_matrix_entry_organization_id_foreign";`);
    this.addSql(`alter table "risk_profile" drop constraint if exists "risk_profile_organization_id_foreign";`);

    // Add back constraints without cascade delete
    this.addSql(`alter table "user_organization" add constraint "user_organization_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "service_provider_client" add constraint "service_provider_client_provider_id_foreign" foreign key ("provider_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "service_provider_client" add constraint "service_provider_client_client_id_foreign" foreign key ("client_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "system" add constraint "system_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "incident" add constraint "incident_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "continuity_plan" add constraint "continuity_plan_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "poam" add constraint "poam_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "audit_log" add constraint "audit_log_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "artifact" add constraint "artifact_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "mitigation_priority" add constraint "mitigation_priority_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "quantitative_risk" add constraint "quantitative_risk_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "risk_matrix_entry" add constraint "risk_matrix_entry_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
    this.addSql(`alter table "risk_profile" add constraint "risk_profile_organization_id_foreign" foreign key ("organization_id") references "organization" ("id") on update cascade;`);
  }
}

================
File: Migration20241212175619.ts
================
import { Migration } from '@mikro-orm/migrations';

export class Migration20241212175619 extends Migration {

  override async up(): Promise<void> {
    // Add last_name as nullable first
    this.addSql(`alter table "user" add column "last_name" varchar(255);`);
    
    // Update existing records with a default value
    this.addSql(`update "user" set "last_name" = '' where "last_name" is null;`);
    
    // Make last_name non-nullable
    this.addSql(`alter table "user" alter column "last_name" set not null;`);

    // Rename existing columns
    this.addSql(`alter table "user" rename column "name" to "first_name";`);
    this.addSql(`alter table "user" rename column "system_role" to "role";`);
  }

  override async down(): Promise<void> {
    this.addSql(`alter table "user" drop column "last_name";`);
    this.addSql(`alter table "user" rename column "first_name" to "name";`);
    this.addSql(`alter table "user" rename column "role" to "system_role";`);
  }

}

================
File: Migration20241212180400.ts
================
import { Migration } from '@mikro-orm/migrations';

export class Migration20241212180400 extends Migration {
  async up(): Promise<void> {
    this.addSql('CREATE EXTENSION IF NOT EXISTS "uuid-ossp";');
  }

  async down(): Promise<void> {
    this.addSql('DROP EXTENSION IF EXISTS "uuid-ossp";');
  }
}

================
File: Migration20241212183455.ts
================
import { Migration } from '@mikro-orm/migrations';

export class Migration20241212183455 extends Migration {
  async up(): Promise<void> {
    // Create client_user table
    this.addSql(`create table "client_user" (
      "id" uuid not null default uuid_generate_v4(),
      "created_at" timestamptz(0) not null default now(),
      "updated_at" timestamptz(0) not null default now(),
      "email" varchar(255) not null,
      "password" varchar(255) not null,
      "first_name" varchar(255) not null,
      "last_name" varchar(255) not null,
      "is_active" boolean not null default true,
      "last_login" timestamptz(0) null,
      constraint "client_user_pkey" primary key ("id"),
      constraint "client_user_email_unique" unique ("email")
    );`);

    // Create system_user table
    this.addSql(`create table "system_user" (
      "id" uuid not null default uuid_generate_v4(),
      "created_at" timestamptz(0) not null default now(),
      "updated_at" timestamptz(0) not null default now(),
      "email" varchar(255) not null,
      "password" varchar(255) not null,
      "first_name" varchar(255) not null,
      "last_name" varchar(255) not null,
      "role" text check ("role" in ('GLOBAL_ADMIN', 'ADMIN')) not null default 'ADMIN',
      "is_active" boolean not null default true,
      "last_login" timestamptz(0) null,
      constraint "system_user_pkey" primary key ("id"),
      constraint "system_user_email_unique" unique ("email")
    );`);

    // Create incident table if it doesn't exist
    this.addSql(`create table if not exists "incident" (
      "id" uuid not null default uuid_generate_v4(),
      "created_at" timestamptz(0) not null default now(),
      "updated_at" timestamptz(0) not null default now(),
      "organization_id" uuid not null,
      "title" varchar(255) not null,
      "description" text not null,
      "severity" text check ("severity" in ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')) not null,
      "status" text check ("status" in ('OPEN', 'IN_PROGRESS', 'RESOLVED', 'CLOSED')) not null default 'OPEN',
      "reporter_id" uuid not null references "client_user" ("id") on update cascade,
      "assignee_id" uuid null references "client_user" ("id") on update cascade on delete set null,
      "resolution" text null,
      "resolved_date" timestamptz(0) null,
      constraint "incident_pkey" primary key ("id")
    );`);

    // Create approval table if it doesn't exist
    this.addSql(`create table if not exists "approval" (
      "id" uuid not null default uuid_generate_v4(),
      "created_at" timestamptz(0) not null default now(),
      "updated_at" timestamptz(0) not null default now(),
      "entity_type" varchar(255) not null,
      "entity_id" varchar(255) not null,
      "approver_id" uuid not null references "client_user" ("id") on update cascade,
      "status" text check ("status" in ('PENDING', 'APPROVED', 'REJECTED')) not null default 'PENDING',
      "comments" text null,
      "approved_at" timestamptz(0) null,
      constraint "approval_pkey" primary key ("id")
    );`);

    // Create asset table if it doesn't exist
    this.addSql(`create table if not exists "asset" (
      "id" uuid not null default uuid_generate_v4(),
      "created_at" timestamptz(0) not null default now(),
      "updated_at" timestamptz(0) not null default now(),
      "system_id" uuid not null,
      "name" varchar(255) not null,
      "type" varchar(255) not null,
      "status" varchar(255) not null,
      "created_by_id" uuid not null references "client_user" ("id") on update cascade,
      "description" text null,
      "version" varchar(255) null,
      "location" varchar(255) null,
      "purchase_date" timestamptz(0) null,
      "end_of_life" timestamptz(0) null,
      constraint "asset_pkey" primary key ("id")
    );`);

    // Update audit_log table
    this.addSql(`alter table if exists "audit_log" 
      add column if not exists "system_user_id" uuid null references "system_user" ("id") on update cascade on delete set null,
      add column if not exists "client_user_id" uuid null references "client_user" ("id") on update cascade on delete set null;`);

    // Update user_organization table
    this.addSql(`alter table if exists "user_organization" 
      add column if not exists "system_user_id" uuid null references "system_user" ("id") on update cascade on delete set null,
      add column if not exists "client_user_id" uuid null references "client_user" ("id") on update cascade on delete set null;`);
  }

  async down(): Promise<void> {
    // Drop foreign key constraints
    this.addSql(`alter table "incident" drop constraint if exists "incident_reporter_id_foreign";`);
    this.addSql(`alter table "incident" drop constraint if exists "incident_assignee_id_foreign";`);
    this.addSql(`alter table "approval" drop constraint if exists "approval_approver_id_foreign";`);
    this.addSql(`alter table "asset" drop constraint if exists "asset_created_by_id_foreign";`);
    this.addSql(`alter table "audit_log" drop constraint if exists "audit_log_system_user_id_foreign";`);
    this.addSql(`alter table "audit_log" drop constraint if exists "audit_log_client_user_id_foreign";`);
    this.addSql(`alter table "user_organization" drop constraint if exists "user_organization_system_user_id_foreign";`);
    this.addSql(`alter table "user_organization" drop constraint if exists "user_organization_client_user_id_foreign";`);

    // Drop columns from audit_log
    this.addSql(`alter table "audit_log" drop column if exists "system_user_id";`);
    this.addSql(`alter table "audit_log" drop column if exists "client_user_id";`);

    // Drop columns from user_organization
    this.addSql(`alter table "user_organization" drop column if exists "system_user_id";`);
    this.addSql(`alter table "user_organization" drop column if exists "client_user_id";`);

    // Drop tables
    this.addSql(`drop table if exists "client_user" cascade;`);
    this.addSql(`drop table if exists "system_user" cascade;`);
  }
}

================
File: Migration20241212183500.ts
================
import { Migration } from '@mikro-orm/migrations';

export class Migration20241212183500 extends Migration {
  async up(): Promise<void> {
    this.addSql('CREATE EXTENSION IF NOT EXISTS "uuid-ossp";');
  }

  async down(): Promise<void> {
    this.addSql('DROP EXTENSION IF EXISTS "uuid-ossp";');
  }
}

================
File: organizations/audit-logging.service.ts
================
import { Injectable } from '@nestjs/common';
import { EntityManager } from '@mikro-orm/postgresql';
import { AuditLog } from '../entities/audit-log.entity';
import { OrganizationAction } from '../entities/organization-audit-log.entity';
import { Request } from 'express';
import { Organization } from '../entities/organization.entity';
import { SystemUser } from '../entities/system-user.entity';
interface AuditLogFilter {
    startDate?: Date;
    endDate?: Date;
    actions?: OrganizationAction[];
    performedById?: string;
}
@Injectable()
export class AuditLoggingService {
    constructor(private readonly em: EntityManager) { }
    async logOrganizationActivity(action: OrganizationAction, organizationId: string, organizationName: string, userId: string, userEmail: string, details: any, req: Request) {
        const organization = await this.em.findOne(Organization, { id: organizationId });
        const systemUser = await this.em.findOne(SystemUser, { id: userId });
        if (!organization || !systemUser) {
            throw new Error("Organization or user not found");
        }
        const auditLog = new AuditLog();
        auditLog.entityType = "organization";
        auditLog.entityId = organizationId;
        auditLog.action = action;
        auditLog.details = {
            ...details,
            organizationName,
            userEmail,
        };
        auditLog.ipAddress = req.ip;
        auditLog.userAgent = req.headers["user-agent"];
        auditLog.organization = organization;
        auditLog.systemUser = systemUser;
        await this.em.persistAndFlush(auditLog);
        return auditLog;
    }
    async getOrganizationAuditLogs(organizationId: string, filter: AuditLogFilter) {
        const organization = await this.em.findOne(Organization, { id: organizationId });
        if (!organization) {
            throw new Error("Organization not found");
        }
        const qb = this.em.createQueryBuilder(AuditLog, "al")
            .where({ organization });
        if (filter.startDate) {
            qb.andWhere({ createdAt: { $gte: filter.startDate } });
        }
        if (filter.endDate) {
            qb.andWhere({ createdAt: { $lte: filter.endDate } });
        }
        if (filter.actions?.length) {
            qb.andWhere({ action: { $in: filter.actions } });
        }
        if (filter.performedById) {
            const systemUser = await this.em.findOne(SystemUser, { id: filter.performedById });
            if (systemUser) {
                qb.andWhere({ systemUser });
            }
        }
        return qb.orderBy({ createdAt: "DESC" }).getResult();
    }
}

================
File: organizations/dto/create-organization.dto.ts
================
import { Type } from 'class-transformer';
import { IsString, IsOptional, IsBoolean, IsEnum, IsArray, IsNumber, ValidateNested, Min, Max } from 'class-validator';
import { OrgType } from '../../enums/organization.enum';
import { RiskLevel, TimeFrame } from '../../enums/risk.enum';
export class CreateRiskProfileDto {
    @IsString()
    businessFunctions!: string;
    @IsString()
    keyAssets!: string;
    @IsArray()
    @IsString({ each: true })
    complianceFrameworks!: string[];
    @IsArray()
    @IsString({ each: true })
    dataTypes!: string[];
    @IsEnum(RiskLevel)
    operationalRisk!: RiskLevel;
    @IsEnum(RiskLevel)
    dataSecurityRisk!: RiskLevel;
    @IsEnum(RiskLevel)
    complianceRisk!: RiskLevel;
    @IsEnum(RiskLevel)
    financialRisk!: RiskLevel;
}
export class CreateQuantitativeRiskDto {
    @IsNumber()
    @Min(0)
    annualLoss!: number;
    @IsNumber()
    @Min(0)
    @Max(1)
    probabilityOfOccurrence!: number;
    @IsNumber()
    @Min(1)
    @Max(10)
    impactScore!: number;
    @IsNumber()
    riskScore!: number;
}
export class CreateRiskMatrixEntryDto {
    @IsNumber()
    @Min(0)
    @Max(4)
    impact!: number;
    @IsNumber()
    @Min(0)
    @Max(4)
    likelihood!: number;
    @IsNumber()
    value!: number;
}
export class CreateMitigationPriorityDto {
    @IsString()
    risk!: string;
    @IsNumber()
    priority!: number;
    @IsString()
    strategy!: string;
    @IsString()
    timeline!: string;
    @IsEnum(TimeFrame)
    timeframe!: TimeFrame;
    @IsString()
    riskArea!: string;
    @IsString()
    successCriteria!: string;
    @IsString()
    resources!: string;
    @IsString()
    estimatedCost!: string;
    @IsString()
    responsibleParty!: string;
}
export class CreateOrganizationDto {
    @IsString()
    name!: string;
    @IsEnum(OrgType)
    type!: OrgType;
    @IsString()
    @IsOptional()
    description?: string;
    @IsBoolean()
    @IsOptional()
    isActive?: boolean;
    @IsBoolean()
    @IsOptional()
    isServiceProvider?: boolean;
    @IsString()
    @IsOptional()
    primaryContact?: string;
    @IsString()
    @IsOptional()
    email?: string;
    @IsString()
    @IsOptional()
    phone?: string;
    @IsString()
    @IsOptional()
    address?: string;
    @IsOptional()
    @ValidateNested()
    @Type(() => CreateRiskProfileDto)
    riskProfile?: CreateRiskProfileDto;
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CreateQuantitativeRiskDto)
    quantitativeRisks?: CreateQuantitativeRiskDto[];
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CreateRiskMatrixEntryDto)
    riskMatrix?: CreateRiskMatrixEntryDto[];
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CreateMitigationPriorityDto)
    mitigationPriorities?: CreateMitigationPriorityDto[];
}

================
File: organizations/dto/update-organization.dto.ts
================
import { PartialType } from '@nestjs/swagger';
import { CreateOrganizationDto } from './create-organization.dto';
export class UpdateOrganizationDto extends PartialType(CreateOrganizationDto) {
}

================
File: organizations/organizations.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete, UseGuards, Request, Query, Inject, Logger, } from '@nestjs/common';
import { OrganizationsService } from './organizations.service';
import { AuditLoggingService } from './audit-logging.service';
import { CreateOrganizationDto } from './dto/create-organization.dto';
import { UpdateOrganizationDto } from './dto/update-organization.dto';
import { OrganizationJwtGuard } from '../auth/guards/organization-jwt.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { ClientRolesGuard } from '../auth/guards/client-roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { ClientRoles } from '../auth/decorators/client-roles.decorator';
import { SystemRole } from '../common/enums/system-role.enum';
import { ClientRole } from '../common/enums/client-role.enum';
import { OrganizationAction } from '../entities/organization-audit-log.entity';
@Controller("organizations")
@UseGuards(OrganizationJwtGuard, RolesGuard, ClientRolesGuard)
export class OrganizationsController {
    private readonly logger = new Logger(OrganizationsController.name);
    constructor(private readonly organizationsService: OrganizationsService, private readonly auditLoggingService: AuditLoggingService) { }
    @Post()
    @Roles(SystemRole.GLOBAL_ADMIN)
    async create(
    @Body()
    createOrganizationDto: CreateOrganizationDto, 
    @Request()
    req) {
        this.logger.log(`Creating organization: ${JSON.stringify(createOrganizationDto)}`);
        const organization = await this.organizationsService.create(createOrganizationDto, req.user.id, req);
        this.logger.log(`Organization created: ${organization.id}`);
        return { data: organization };
    }
    @Get()
    async findAll(
    @Request()
    req) {
        this.logger.log(`Finding all organizations for user: ${req.user.id}`);
        const organizations = await this.organizationsService.findAll(req.user.id);
        this.logger.log(`Found ${organizations.length} organizations`);
        return { data: organizations };
    }
    @Get(":id")
    async findOne(
    @Param("id")
    id: string, 
    @Request()
    req) {
        this.logger.log(`Finding organization by ID: ${id} for user: ${req.user.id}`);
        const organization = await this.organizationsService.findOne(id, req.user.id);
        this.logger.log(`Organization found: ${JSON.stringify(organization)}`);
        return { data: organization };
    }
    @Get(":id/users")
    @ClientRoles(ClientRole.ADMIN, ClientRole.MANAGER)
    async getUsers(
    @Param("id")
    id: string, 
    @Query("page")
    page = 1, 
    @Query("pageSize")
    pageSize = 10, 
    @Request()
    req) {
        this.logger.log(`Getting users for organization: ${id}, page: ${page}, pageSize: ${pageSize}`);
        // First check if the user has access to this organization
        await this.organizationsService.findOne(id, req.user.id);
        // If findOne doesn't throw, the user has access
        const users = await this.organizationsService.getOrganizationUsers(id, page, pageSize);
        this.logger.log(`Found ${users.length} users for organization: ${id}`);
        return {
            data: {
                data: users,
                total: users.length,
                page,
                pageSize
            }
        };
    }
    @Patch(":id")
    @Roles(SystemRole.GLOBAL_ADMIN, SystemRole.ADMIN)
    @ClientRoles(ClientRole.ADMIN, ClientRole.MANAGER)
    async update(
    @Param("id")
    id: string, 
    @Body()
    updateOrganizationDto: UpdateOrganizationDto, 
    @Request()
    req) {
        this.logger.log(`Updating organization: ${id} with data: ${JSON.stringify(updateOrganizationDto)}`);
        const organization = await this.organizationsService.update(id, updateOrganizationDto, req.user.id, req);
        this.logger.log(`Organization updated: ${organization.id}`);
        return { data: organization };
    }
    @Delete(":id")
    @Roles(SystemRole.GLOBAL_ADMIN)
    async remove(
    @Param("id")
    id: string, 
    @Request()
    req) {
        this.logger.log(`Removing organization: ${id}`);
        const organization = await this.organizationsService.remove(id, req.user.id);
        this.logger.log(`Organization removed: ${organization.id}`);
        return { data: organization };
    }
    @Post(":id/users")
    @Roles(SystemRole.GLOBAL_ADMIN, SystemRole.ADMIN)
    @ClientRoles(ClientRole.ADMIN)
    async addUser(
    @Param("id")
    id: string, 
    @Body("email")
    email: string, 
    @Request()
    req) {
        this.logger.log(`Adding user ${email} to organization: ${id}`);
        const userOrg = await this.organizationsService.addUser(id, email, req.user.id);
        this.logger.log(`User added to organization: ${JSON.stringify(userOrg)}`);
        return { data: userOrg };
    }
    @Delete(":id/users/:userId")
    @Roles(SystemRole.GLOBAL_ADMIN, SystemRole.ADMIN)
    @ClientRoles(ClientRole.ADMIN)
    async removeUser(
    @Param("id")
    id: string, 
    @Param("userId")
    userId: string, 
    @Request()
    req) {
        this.logger.log(`Removing user ${userId} from organization: ${id}`);
        const userOrg = await this.organizationsService.removeUser(id, userId, req.user.id);
        this.logger.log(`User removed from organization: ${JSON.stringify(userOrg)}`);
        return { data: userOrg };
    }
    @Get(":id/audit-logs")
    @Roles(SystemRole.GLOBAL_ADMIN, SystemRole.ADMIN)
    @ClientRoles(ClientRole.ADMIN, ClientRole.MANAGER)
    async getAuditLogs(
    @Request()
    req, 
    @Param("id")
    id: string, 
    @Query("startDate")
    startDate?: string, 
    @Query("endDate")
    endDate?: string, 
    @Query("actions")
    actions?: OrganizationAction[], 
    @Query("performedById")
    performedById?: string) {
        this.logger.log(`Getting audit logs for organization: ${id}`);
        const auditLogs = await this.auditLoggingService.getOrganizationAuditLogs(id, {
            startDate: startDate ? new Date(startDate) : undefined,
            endDate: endDate ? new Date(endDate) : undefined,
            actions,
            performedById,
        });
        this.logger.log(`Found ${auditLogs.length} audit logs`);
        return { data: auditLogs };
    }
}

================
File: organizations/organizations.module.ts
================
import { Module } from '@nestjs/common';
import { MikroOrmModule } from '@mikro-orm/nestjs';
import { OrganizationsService } from './organizations.service';
import { OrganizationsController } from './organizations.controller';
import { AuditLoggingService } from './audit-logging.service';
import { Organization } from '../entities/organization.entity';
import { UserOrganization } from '../entities/user-organization.entity';
import { ClientUser } from '../entities/client-user.entity';
import { SystemUser } from '../entities/system-user.entity';
import { System } from '../entities/system.entity';
import { ServiceProviderClient } from '../entities/service-provider-client.entity';
import { RiskProfile } from '../entities/risk-profile.entity';
import { QuantitativeRisk } from '../entities/quantitative-risk.entity';
import { RiskMatrixEntry } from '../entities/risk-matrix-entry.entity';
import { MitigationPriority } from '../entities/mitigation-priority.entity';
import { AuditLog } from '../entities/audit-log.entity';
@Module({
    imports: [
        MikroOrmModule.forFeature([
            Organization,
            UserOrganization,
            ClientUser,
            SystemUser,
            System,
            ServiceProviderClient,
            RiskProfile,
            QuantitativeRisk,
            RiskMatrixEntry,
            MitigationPriority,
            AuditLog
        ])
    ],
    controllers: [OrganizationsController],
    providers: [OrganizationsService, AuditLoggingService],
    exports: [OrganizationsService], // Export the service so it can be used by other modules
})
export class OrganizationsModule {
}

================
File: organizations/organizations.service.ts
================
import { Injectable, UnauthorizedException, Logger } from '@nestjs/common';
import { EntityManager, wrap } from '@mikro-orm/postgresql';
import { Organization } from '../entities/organization.entity';
import { SystemUser } from '../entities/system-user.entity';
import { ClientUser } from '../entities/client-user.entity';
import { UserOrganization } from '../entities/user-organization.entity';
import { RiskMatrixEntry } from '../entities/risk-matrix-entry.entity';
import { RiskProfile } from '../entities/risk-profile.entity';
import { CreateOrganizationDto } from './dto/create-organization.dto';
import { UpdateOrganizationDto } from './dto/update-organization.dto';
import { SystemRole } from '../common/enums/system-role.enum';
import { AuditLoggingService } from './audit-logging.service';
import { OrganizationAction } from '../entities/organization-audit-log.entity';
import { RiskLevel } from '../enums/risk.enum';
import { Request } from 'express';
@Injectable()
export class OrganizationsService {
    private readonly logger = new Logger(OrganizationsService.name);
    constructor(private readonly em: EntityManager, private readonly auditLoggingService: AuditLoggingService) { }
    async getOrganizationUsers(organizationId: string, page: number = 1, pageSize: number = 10) {
        this.logger.log(`[getOrganizationUsers] Finding organization: ${organizationId}`);
        const organization = await this.em.findOne(Organization, { id: organizationId });
        if (!organization) {
            this.logger.error(`[getOrganizationUsers] Organization not found: ${organizationId}`);
            throw new UnauthorizedException("Organization not found");
        }
        this.logger.log(`[getOrganizationUsers] Finding users for organization: ${organizationId}`);
        const userOrgs = await this.em.find(UserOrganization, { organization }, {
            populate: ["systemUser", "clientUser"],
            limit: pageSize,
            offset: (page - 1) * pageSize,
        });
        this.logger.log(`[getOrganizationUsers] Found ${userOrgs.length} users`);
        return userOrgs;
    }
    async create(createOrganizationDto: CreateOrganizationDto, userId: string, req: Request) {
        // Fork the EntityManager to create a new context for the transaction
        const em = this.em.fork();
        try {
            this.logger.log(`[create] Finding system user: ${userId}`);
            const systemUser = await em.findOne(SystemUser, { id: userId });
            if (!systemUser) {
                this.logger.error(`[create] System user not found: ${userId}`);
                throw new UnauthorizedException("User not found");
            }
            // Only GLOBAL_ADMIN can create organizations
            if (systemUser.role !== SystemRole.GLOBAL_ADMIN) {
                this.logger.error(`[create] User ${userId} is not a GLOBAL_ADMIN`);
                throw new UnauthorizedException("Only global admins can create organizations");
            }
            // Begin transaction
            await em.begin();
            this.logger.log(`[create] Creating new organization: ${createOrganizationDto.name}`);
            const organization = new Organization();
            organization.name = createOrganizationDto.name;
            organization.type = createOrganizationDto.type;
            organization.description = createOrganizationDto.description;
            organization.isActive = createOrganizationDto.isActive ?? true;
            organization.isServiceProvider = createOrganizationDto.isServiceProvider ?? false;
            organization.primaryContact = createOrganizationDto.primaryContact;
            organization.email = createOrganizationDto.email;
            organization.phone = createOrganizationDto.phone;
            organization.address = createOrganizationDto.address;
            // Create risk profile using provided data or defaults
            this.logger.log(`[create] Creating risk profile for organization`);
            const riskProfile = new RiskProfile();
            if (createOrganizationDto.riskProfile) {
                riskProfile.businessFunctions = createOrganizationDto.riskProfile.businessFunctions;
                riskProfile.keyAssets = createOrganizationDto.riskProfile.keyAssets;
                riskProfile.complianceFrameworks = createOrganizationDto.riskProfile.complianceFrameworks;
                riskProfile.dataTypes = createOrganizationDto.riskProfile.dataTypes;
                riskProfile.operationalRisk = createOrganizationDto.riskProfile.operationalRisk;
                riskProfile.dataSecurityRisk = createOrganizationDto.riskProfile.dataSecurityRisk;
                riskProfile.complianceRisk = createOrganizationDto.riskProfile.complianceRisk;
                riskProfile.financialRisk = createOrganizationDto.riskProfile.financialRisk;
            }
            else {
                riskProfile.businessFunctions = "Not specified";
                riskProfile.keyAssets = "Not specified";
                riskProfile.complianceFrameworks = [];
                riskProfile.dataTypes = [];
                riskProfile.operationalRisk = RiskLevel.LOW;
                riskProfile.dataSecurityRisk = RiskLevel.LOW;
                riskProfile.complianceRisk = RiskLevel.LOW;
                riskProfile.financialRisk = RiskLevel.LOW;
            }
            riskProfile.organization = organization;
            // Handle risk matrix entries if provided
            if (createOrganizationDto.riskMatrix) {
                this.logger.log(`[create] Creating ${createOrganizationDto.riskMatrix.length} risk matrix entries`);
                createOrganizationDto.riskMatrix.forEach(entry => {
                    const riskMatrixEntry = new RiskMatrixEntry();
                    riskMatrixEntry.impact = entry.impact;
                    riskMatrixEntry.likelihood = entry.likelihood;
                    riskMatrixEntry.value = entry.value;
                    riskMatrixEntry.organization = organization;
                    em.persist(riskMatrixEntry);
                });
            }
            // Persist organization and risk profile
            em.persist(organization);
            em.persist(riskProfile);
            await em.flush();
            this.logger.log(`[create] Organization created: ${organization.id}`);
            const userOrg = new UserOrganization();
            userOrg.systemUser = systemUser;
            userOrg.organization = organization;
            userOrg.isActive = true;
            em.persist(userOrg);
            await em.flush();
            this.logger.log(`[create] UserOrganization created: ${userOrg.id}`);
            // Commit transaction
            await em.commit();
            await this.auditLoggingService.logOrganizationActivity(OrganizationAction.CREATED, organization.id, organization.name, systemUser.id, systemUser.email, {
                name: organization.name,
                type: organization.type,
                description: organization.description,
                isActive: organization.isActive,
                isServiceProvider: organization.isServiceProvider,
                primaryContact: organization.primaryContact,
                email: organization.email,
                phone: organization.phone,
                address: organization.address
            }, req);
            // Return organization with populated relations
            return await em.findOne(Organization, { id: organization.id }, {
                populate: ["riskProfile", "riskMatrix"]
            });
        }
        catch (error) {
            this.logger.error(`[create] Error creating organization: ${error.message}`);
            await em.rollback();
            throw error;
        }
    }
    async findAll(userId: string) {
        this.logger.log(`[findAll] Finding user: ${userId}`);
        const systemUser = await this.em.findOne(SystemUser, { id: userId });
        if (systemUser) {
            this.logger.log(`[findAll] Found system user with role: ${systemUser.role}`);
            // System users (GLOBAL_ADMIN and ADMIN)
            if (systemUser.role === SystemRole.GLOBAL_ADMIN) {
                this.logger.log("[findAll] User is GLOBAL_ADMIN, finding all organizations");
                const orgs = await this.em.find(Organization, {}, {
                    populate: ["riskProfile", "riskMatrix"]
                });
                this.logger.log(`[findAll] Found ${orgs.length} organizations`);
                return orgs;
            }
            // For ADMIN and other roles, find their assigned organizations with populated data
            this.logger.log("[findAll] Finding organizations through UserOrganization");
            const userOrgs = await this.em.find(UserOrganization, { systemUser }, {
                populate: ["organization.riskProfile", "organization.riskMatrix"]
            });
            this.logger.log(`[findAll] Found ${userOrgs.length} organizations for system user`);
            return userOrgs.map(uo => uo.organization);
        }
        // Check if it's a client user
        this.logger.log(`[findAll] Finding client user: ${userId}`);
        const clientUser = await this.em.findOne(ClientUser, { id: userId });
        if (clientUser) {
            this.logger.log("[findAll] Finding organizations through UserOrganization for client user");
            const userOrgs = await this.em.find(UserOrganization, { clientUser }, {
                populate: ["organization.riskProfile", "organization.riskMatrix"]
            });
            this.logger.log(`[findAll] Found ${userOrgs.length} organizations for client user`);
            return userOrgs.map(uo => uo.organization);
        }
        this.logger.error(`[findAll] No user found with ID: ${userId}`);
        throw new UnauthorizedException("User not found");
    }
    async findOne(id: string, userId: string) {
        this.logger.log(`[findOne] Finding organization: ${id}`);
        const organization = await this.em.findOne(Organization, { id }, {
            populate: ["riskProfile", "riskMatrix"]
        });
        if (!organization) {
            this.logger.warn(`[findOne] Organization not found: ${id}`);
            return null;
        }
        this.logger.log(`[findOne] Finding system user: ${userId}`);
        const systemUser = await this.em.findOne(SystemUser, { id: userId });
        if (systemUser) {
            this.logger.log(`[findOne] Found system user with role: ${systemUser.role}`);
            // System users (GLOBAL_ADMIN and ADMIN)
            if (systemUser.role === SystemRole.GLOBAL_ADMIN) {
                this.logger.log("[findOne] User is GLOBAL_ADMIN, returning organization");
                return organization;
            }
            const userOrg = await this.em.findOne(UserOrganization, {
                systemUser,
                organization,
            });
            if (!userOrg) {
                this.logger.error(`[findOne] User ${userId} not authorized for organization ${id}`);
                throw new UnauthorizedException("User not authorized for this organization");
            }
            return organization;
        }
        // Check if it's a client user
        this.logger.log(`[findOne] Finding client user: ${userId}`);
        const clientUser = await this.em.findOne(ClientUser, { id: userId });
        if (clientUser) {
            const userOrg = await this.em.findOne(UserOrganization, {
                clientUser,
                organization,
            });
            if (!userOrg) {
                this.logger.error(`[findOne] Client user ${userId} not authorized for organization ${id}`);
                throw new UnauthorizedException("User not authorized for this organization");
            }
            return organization;
        }
        this.logger.error(`[findOne] No user found with ID: ${userId}`);
        throw new UnauthorizedException("User not found");
    }
    async update(id: string, updateOrganizationDto: UpdateOrganizationDto, userId: string, req: Request) {
        // Fork the EntityManager to create a new context for the transaction
        const em = this.em.fork();
        try {
            this.logger.log(`[update] Finding system user: ${userId}`);
            const systemUser = await em.findOne(SystemUser, { id: userId });
            if (!systemUser) {
                this.logger.error(`[update] System user not found: ${userId}`);
                throw new UnauthorizedException("User not found");
            }
            this.logger.log(`[update] Finding organization: ${id}`);
            const organization = await em.findOne(Organization, { id }, {
                populate: ["riskMatrix", "riskProfile"]
            });
            if (!organization) {
                this.logger.warn(`[update] Organization not found: ${id}`);
                return null;
            }
            // Check if user has access to this organization
            if (systemUser.role !== SystemRole.GLOBAL_ADMIN) {
                const userOrg = await em.findOne(UserOrganization, {
                    systemUser,
                    organization,
                });
                if (!userOrg) {
                    this.logger.error(`[update] User ${userId} not authorized for organization ${id}`);
                    throw new UnauthorizedException("User not authorized for this organization");
                }
            }
            const changes = {
                before: {
                    name: organization.name,
                    type: organization.type,
                    description: organization.description,
                    isActive: organization.isActive,
                    isServiceProvider: organization.isServiceProvider,
                    primaryContact: organization.primaryContact,
                    email: organization.email,
                    phone: organization.phone,
                    address: organization.address
                },
                after: null as any
            };
            // Begin transaction
            await em.begin();
            // Handle risk matrix entries if provided
            if (updateOrganizationDto.riskMatrix) {
                // First, remove all existing risk matrix entries for this organization
                this.logger.log(`[update] Removing existing risk matrix entries for organization: ${id}`);
                await em.nativeDelete(RiskMatrixEntry, { organization: { id } });
                await em.flush();
                // Then create new entries
                this.logger.log(`[update] Creating ${updateOrganizationDto.riskMatrix.length} new risk matrix entries`);
                const newEntries = updateOrganizationDto.riskMatrix.map(entry => {
                    const riskMatrixEntry = new RiskMatrixEntry();
                    riskMatrixEntry.impact = entry.impact;
                    riskMatrixEntry.likelihood = entry.likelihood;
                    riskMatrixEntry.value = entry.value;
                    riskMatrixEntry.organization = organization;
                    return riskMatrixEntry;
                });
                // Persist all new entries at once
                em.persist(newEntries);
                await em.flush();
            }
            // Update risk profile if provided
            if (updateOrganizationDto.riskProfile) {
                this.logger.log(`[update] Updating risk profile for organization: ${id}`);
                const riskProfile = await em.findOne(RiskProfile, { organization: { id } });
                if (riskProfile) {
                    wrap(riskProfile).assign(updateOrganizationDto.riskProfile);
                    await em.flush();
                }
            }
            this.logger.log(`[update] Updating organization: ${id}`);
            // Only update non-risk matrix fields
            const { riskMatrix, riskProfile, ...updateFields } = updateOrganizationDto;
            wrap(organization).assign(updateFields, { em });
            await em.flush();
            // Commit transaction
            await em.commit();
            // Fetch the updated organization with populated relations
            const updatedOrganization = await em.findOne(Organization, { id }, {
                populate: ["riskProfile", "riskMatrix"]
            });
            changes.after = {
                name: organization.name,
                type: organization.type,
                description: organization.description,
                isActive: organization.isActive,
                isServiceProvider: organization.isServiceProvider,
                primaryContact: organization.primaryContact,
                email: organization.email,
                phone: organization.phone,
                address: organization.address
            };
            // Log the update
            await this.auditLoggingService.logOrganizationActivity(OrganizationAction.UPDATED, organization.id, organization.name, systemUser.id, systemUser.email, changes, req);
            return updatedOrganization;
        }
        catch (error) {
            this.logger.error(`[update] Error updating organization: ${error.message}`);
            await em.rollback();
            throw error;
        }
    }
    async remove(id: string, userId: string) {
        this.logger.log(`[remove] Finding system user: ${userId}`);
        const systemUser = await this.em.findOne(SystemUser, { id: userId });
        if (!systemUser) {
            this.logger.error(`[remove] System user not found: ${userId}`);
            throw new UnauthorizedException("User not found");
        }
        if (systemUser.role !== SystemRole.GLOBAL_ADMIN) {
            this.logger.error(`[remove] User ${userId} is not a GLOBAL_ADMIN`);
            throw new UnauthorizedException("Only global admins can delete organizations");
        }
        this.logger.log(`[remove] Finding organization: ${id}`);
        const organization = await this.em.findOne(Organization, { id });
        if (!organization) {
            this.logger.warn(`[remove] Organization not found: ${id}`);
            return null;
        }
        await this.em.removeAndFlush(organization);
        this.logger.log(`[remove] Organization removed: ${id}`);
        return organization;
    }
    async addUser(organizationId: string, userEmail: string, adminUserId: string) {
        this.logger.log(`[addUser] Finding admin user: ${adminUserId}`);
        const adminUser = await this.em.findOne(SystemUser, { id: adminUserId });
        if (!adminUser || adminUser.role !== SystemRole.GLOBAL_ADMIN) {
            this.logger.error(`[addUser] User ${adminUserId} is not a GLOBAL_ADMIN`);
            throw new UnauthorizedException("Only global admins can add users to organizations");
        }
        this.logger.log(`[addUser] Finding organization: ${organizationId}`);
        const organization = await this.em.findOne(Organization, { id: organizationId });
        if (!organization) {
            this.logger.error(`[addUser] Organization not found: ${organizationId}`);
            throw new UnauthorizedException("Organization not found");
        }
        // Try to find user in both system and client users
        this.logger.log(`[addUser] Finding user by email: ${userEmail}`);
        const systemUser = await this.em.findOne(SystemUser, { email: userEmail });
        const clientUser = await this.em.findOne(ClientUser, { email: userEmail });
        if (!systemUser && !clientUser) {
            this.logger.error(`[addUser] No user found with email: ${userEmail}`);
            throw new UnauthorizedException("User not found");
        }
        // Check if user is already in organization
        this.logger.log(`[addUser] Checking if user already exists in organization`);
        let existingUserOrg;
        if (systemUser) {
            existingUserOrg = await this.em.findOne(UserOrganization, {
                systemUser,
                organization
            });
        }
        else if (clientUser) {
            existingUserOrg = await this.em.findOne(UserOrganization, {
                clientUser,
                organization
            });
        }
        if (existingUserOrg) {
            this.logger.error(`[addUser] User ${userEmail} is already in organization ${organizationId}`);
            throw new UnauthorizedException("User is already in this organization");
        }
        // Create new UserOrganization instance
        this.logger.log(`[addUser] Creating new UserOrganization`);
        const userOrg = new UserOrganization();
        userOrg.organization = organization;
        // Set either systemUser or clientUser, but not both
        if (systemUser) {
            userOrg.systemUser = systemUser;
            userOrg.clientUser = null;
        }
        else if (clientUser) {
            userOrg.clientUser = clientUser;
            userOrg.systemUser = null;
        }
        userOrg.isActive = true;
        // Begin transaction
        const em = this.em.fork();
        try {
            this.logger.log(`[addUser] Starting transaction`);
            await em.begin();
            await em.persistAndFlush(userOrg);
            await em.commit();
            // Refresh the entity to ensure all relations are properly loaded
            await em.refresh(userOrg);
            this.logger.log(`[addUser] User added successfully: ${userOrg.id}`);
            return userOrg;
        }
        catch (error) {
            this.logger.error(`[addUser] Error adding user: ${error.message}`);
            await em.rollback();
            throw error;
        }
    }
    async removeUser(organizationId: string, userId: string, adminUserId: string) {
        this.logger.log(`[removeUser] Finding admin user: ${adminUserId}`);
        const adminUser = await this.em.findOne(SystemUser, { id: adminUserId });
        if (!adminUser || adminUser.role !== SystemRole.GLOBAL_ADMIN) {
            this.logger.error(`[removeUser] User ${adminUserId} is not a GLOBAL_ADMIN`);
            throw new UnauthorizedException("Only global admins can remove users from organizations");
        }
        this.logger.log(`[removeUser] Finding organization: ${organizationId}`);
        const organization = await this.em.findOne(Organization, { id: organizationId });
        if (!organization) {
            this.logger.error(`[removeUser] Organization not found: ${organizationId}`);
            throw new UnauthorizedException("Organization not found");
        }
        // Try to find user in both system and client users
        this.logger.log(`[removeUser] Finding user: ${userId}`);
        const systemUser = await this.em.findOne(SystemUser, { id: userId });
        const clientUser = await this.em.findOne(ClientUser, { id: userId });
        if (!systemUser && !clientUser) {
            this.logger.error(`[removeUser] No user found with ID: ${userId}`);
            throw new UnauthorizedException("User not found");
        }
        // Find user organization relationship
        this.logger.log(`[removeUser] Finding UserOrganization relationship`);
        const userOrg = await this.em.findOne(UserOrganization, {
            $or: [
                { systemUser: systemUser || null, organization },
                { clientUser: clientUser || null, organization }
            ]
        });
        if (!userOrg) {
            this.logger.error(`[removeUser] User ${userId} is not in organization ${organizationId}`);
            throw new UnauthorizedException("User is not in this organization");
        }
        await this.em.removeAndFlush(userOrg);
        this.logger.log(`[removeUser] User removed from organization: ${userOrg.id}`);
        return userOrg;
    }
}

================
File: risk-profile/dto/update-risk-profile.dto.ts
================
import { IsString, IsEnum, IsArray, IsOptional } from 'class-validator';
import { RiskLevel } from '../../enums/risk.enum';
export class UpdateRiskProfileDto {
    @IsString()
    @IsOptional()
    id?: string;
    @IsString()
    businessFunctions!: string;
    @IsString()
    keyAssets!: string;
    @IsArray()
    @IsString({ each: true })
    complianceFrameworks!: string[];
    @IsArray()
    @IsString({ each: true })
    dataTypes!: string[];
    @IsEnum(RiskLevel)
    operationalRisk!: RiskLevel;
    @IsEnum(RiskLevel)
    dataSecurityRisk!: RiskLevel;
    @IsEnum(RiskLevel)
    complianceRisk!: RiskLevel;
    @IsEnum(RiskLevel)
    financialRisk!: RiskLevel;
}

================
File: risk-profile/risk-profile.controller.ts
================
import { Controller, Patch, Param, Body, UseGuards } from '@nestjs/common';
import { RiskProfileService } from './risk-profile.service';
import { UpdateRiskProfileDto } from './dto/update-risk-profile.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
@Controller("risk-profiles")
@UseGuards(JwtAuthGuard, RolesGuard)
export class RiskProfileController {
    constructor(private readonly riskProfileService: RiskProfileService) { }
    @Patch(":id")
    async update(
    @Param("id")
    id: string, 
    @Body()
    updateRiskProfileDto: UpdateRiskProfileDto) {
        const updatedProfile = await this.riskProfileService.update(id, updateRiskProfileDto);
        return {
            success: true,
            data: updatedProfile
        };
    }
}

================
File: risk-profile/risk-profile.module.ts
================
import { Module } from '@nestjs/common';
import { MikroOrmModule } from '@mikro-orm/nestjs';
import { RiskProfileController } from './risk-profile.controller';
import { RiskProfileService } from './risk-profile.service';
import { RiskProfile } from '../entities/risk-profile.entity';
@Module({
    imports: [
        MikroOrmModule.forFeature([RiskProfile])
    ],
    controllers: [RiskProfileController],
    providers: [RiskProfileService],
    exports: [RiskProfileService]
})
export class RiskProfileModule {
}

================
File: risk-profile/risk-profile.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { EntityManager } from '@mikro-orm/core';
import { RiskProfile } from '../entities/risk-profile.entity';
import { UpdateRiskProfileDto } from './dto/update-risk-profile.dto';
@Injectable()
export class RiskProfileService {
    constructor(private readonly em: EntityManager) { }
    async update(id: string, updateRiskProfileDto: UpdateRiskProfileDto): Promise<RiskProfile> {
        const riskProfile = await this.em.findOne(RiskProfile, { id });
        if (!riskProfile) {
            throw new NotFoundException(`Risk profile with ID ${id} not found`);
        }
        // Update risk profile properties
        this.em.assign(riskProfile, updateRiskProfileDto);
        // Save changes
        await this.em.flush();
        return riskProfile;
    }
    async findOne(id: string): Promise<RiskProfile> {
        const riskProfile = await this.em.findOne(RiskProfile, { id }, {
            populate: ["organization"]
        });
        if (!riskProfile) {
            throw new NotFoundException(`Risk profile with ID ${id} not found`);
        }
        return riskProfile;
    }
}

================
File: seeders/DatabaseSeeder.ts
================
import type { EntityManager } from '@mikro-orm/core';
import { Seeder } from '@mikro-orm/seeder';
import { SystemUserSeeder } from './SystemUserSeeder';
import { OrganizationSeeder } from './OrganizationSeeder';
import { UserOrganizationSeeder } from './UserOrganizationSeeder';
export class DatabaseSeeder extends Seeder {
    async run(em: EntityManager): Promise<void> {
        return this.call(em, [
            SystemUserSeeder, // First create system users
            OrganizationSeeder, // Then create organizations
            UserOrganizationSeeder // Finally establish relationships between them
        ]);
    }
}

================
File: seeders/OrganizationSeeder.ts
================
import type { EntityManager } from '@mikro-orm/core';
import { Seeder } from '@mikro-orm/seeder';
import { Organization } from '../entities/organization.entity';
import { OrgType } from '../enums/organization.enum';
import { RiskProfile } from '../entities/risk-profile.entity';
import { RiskLevel } from '../enums/risk.enum';
export class OrganizationSeeder extends Seeder {
    async run(em: EntityManager): Promise<void> {
        // The White Council - Service Provider
        const whiteCouncil = em.create(Organization, {
            name: "The White Council",
            type: OrgType.SERVICE_PROVIDER,
            description: "Ancient order of security practitioners providing oversight and protection across Middle-earth",
            isActive: true,
            isServiceProvider: true,
            primaryContact: "Gandalf the Grey",
            email: "mithrandir@white-council.me",
            phone: "(555) 675-7655",
            address: "Isengard Tower, Middle-earth",
        });
        const whiteCouncilProfile = em.create(RiskProfile, {
            businessFunctions: `
        - Magical Defense Systems
        - Ring Detection & Monitoring
        - Dark Force Prevention
        - Ancient Knowledge Protection
        - Inter-realm Security Coordination
      `,
            keyAssets: `
        - Palantri Network
        - White Council Archives
        - Elven Ring Management Systems
        - Istari Knowledge Base
        - Ancient Artifact Repository
      `,
            complianceFrameworks: [
                "MIST 800-53 (Middle-earth Institute of Security)",
                "ISO 27001 First Age Edition",
                "Ring Bearer Security Controls",
                "Council of Elrond Protocols",
                "Valar Security Standards"
            ],
            dataTypes: [
                "Ring Bearer PII",
                "Ancient Spells",
                "Magical Artifacts Data",
                "Council Communications",
                "Dark Force Intelligence"
            ],
            operationalRisk: RiskLevel.LOW,
            dataSecurityRisk: RiskLevel.HIGH,
            complianceRisk: RiskLevel.LOW,
            financialRisk: RiskLevel.LOW,
            organization: whiteCouncil
        });
        // Rivendell Data Haven
        const rivendell = em.create(Organization, {
            name: "Rivendell Data Haven",
            type: OrgType.CLIENT,
            description: "Premier facility for the preservation and protection of ancient knowledge and artifacts",
            isActive: true,
            isServiceProvider: false,
            primaryContact: "Elrond",
            email: "elrond@rivendell.me",
            phone: "(555) 454-4532",
            address: "Valley of Imladris, Middle-earth",
        });
        const rivendellProfile = em.create(RiskProfile, {
            businessFunctions: `
        - Ancient Text Digitization
        - Artifact Authentication
        - Lore Preservation
        - Historical Data Analytics
        - Elvish Knowledge Management
      `,
            keyAssets: `
        - Historical Archives
        - Artifact Database
        - Elvish Manuscripts
        - Ancient Maps Repository
        - Healing Knowledge Base
      `,
            complianceFrameworks: [
                "Elvish Data Protection Act",
                "Ancient Knowledge Preservation Standard",
                "First Age Compliance Controls",
                "Ring Bearer Privacy Framework",
                "Council of Elrond Security Protocols"
            ],
            dataTypes: [
                "Ancient Manuscripts",
                "Magical Artifact Specifications",
                "Historical Records",
                "Healing Arts Data",
                "Elvish Lore"
            ],
            operationalRisk: RiskLevel.MEDIUM,
            dataSecurityRisk: RiskLevel.CRITICAL,
            complianceRisk: RiskLevel.HIGH,
            financialRisk: RiskLevel.LOW,
            organization: rivendell
        });
        // Gondor Defense Systems
        const gondor = em.create(Organization, {
            name: "Gondor Defense Systems",
            type: OrgType.CLIENT,
            description: "Leading provider of border security and early warning systems in Middle-earth",
            isActive: true,
            isServiceProvider: false,
            primaryContact: "Boromir",
            email: "captain@gondor.me",
            phone: "(555) 545-3432",
            address: "White Tower, Minas Tirith, Gondor",
        });
        const gondorProfile = em.create(RiskProfile, {
            businessFunctions: `
        - Border Monitoring Systems
        - Beacon Network Management
        - Palantr Communications
        - Troop Deployment Analytics
        - Enemy Movement Detection
      `,
            keyAssets: `
        - Beacon Network Infrastructure
        - Defense Plans Database
        - Troop Movement Tracking System
        - Enemy Intelligence Repository
        - Emergency Response Protocols
      `,
            complianceFrameworks: [
                "Gondorian Military Standards",
                "Beacon Network Security Protocol",
                "Palant\u00EDr Usage Guidelines",
                "Border Defense Framework",
                "Military Intelligence Protection"
            ],
            dataTypes: [
                "Military Intelligence",
                "Troop Movements",
                "Enemy Activity Reports",
                "Defense Plans",
                "Emergency Protocols"
            ],
            operationalRisk: RiskLevel.CRITICAL,
            dataSecurityRisk: RiskLevel.HIGH,
            complianceRisk: RiskLevel.HIGH,
            financialRisk: RiskLevel.MEDIUM,
            organization: gondor
        });
        // Erebor Vault Technologies
        const erebor = em.create(Organization, {
            name: "Erebor Vault Technologies",
            type: OrgType.CLIENT,
            description: "Specialized in high-security storage solutions and access control systems",
            isActive: true,
            isServiceProvider: false,
            primaryContact: "Thorin Oakenshield",
            email: "king@erebor.me",
            phone: "(555) 234-3432",
            address: "Lonely Mountain, Rhovanion",
        });
        const ereborProfile = em.create(RiskProfile, {
            businessFunctions: `
        - Vault Security Systems
        - Dragon Detection Analytics
        - Treasury Management
        - Access Control Solutions
        - Dwarf Authentication Services
      `,
            keyAssets: `
        - Vault Security Grid
        - Treasury Database
        - Mithril Inventory System
        - Access Control Matrix
        - Gem Classification Database
      `,
            complianceFrameworks: [
                "Dwarven Security Standards",
                "Treasury Protection Protocol",
                "Mithril Handling Guidelines",
                "Mountain Access Controls",
                "Gem Classification Framework"
            ],
            dataTypes: [
                "Treasury Records",
                "Mithril Inventory",
                "Access Credentials",
                "Security Patterns",
                "Vault Blueprints"
            ],
            operationalRisk: RiskLevel.HIGH,
            dataSecurityRisk: RiskLevel.CRITICAL,
            complianceRisk: RiskLevel.MEDIUM,
            financialRisk: RiskLevel.HIGH,
            organization: erebor
        });
        // Set up bidirectional relationships
        whiteCouncil.riskProfile = whiteCouncilProfile;
        rivendell.riskProfile = rivendellProfile;
        gondor.riskProfile = gondorProfile;
        erebor.riskProfile = ereborProfile;
        // Persist everything
        await em.persistAndFlush([
            whiteCouncil,
            rivendell,
            gondor,
            erebor,
            whiteCouncilProfile,
            rivendellProfile,
            gondorProfile,
            ereborProfile
        ]);
    }
}

================
File: seeders/reset-db.ts
================
import { MikroORM } from '@mikro-orm/core';
import { DatabaseSeeder } from './DatabaseSeeder';
import config from '../../mikro-orm.config';

(async () => {
    try {
        console.log("Initializing ORM...");
        const orm = await MikroORM.init(config);
        const generator = orm.getSchemaGenerator();

        // Drop all tables
        console.log("Dropping all tables...");
        await generator.dropSchema();

        // Create fresh schema from migrations
        console.log("Creating fresh schema...");
        await generator.createSchema();

        // Run all migrations
        console.log("Running migrations...");
        const migrator = orm.getMigrator();
        await migrator.up();

        // Run seeders in sequence
        console.log("Running seeders...");
        const seeder = orm.getSeeder();
        await seeder.seed(DatabaseSeeder);

        console.log("Database reset and seeding complete!");
        await orm.close(true);
        process.exit(0);
    }
    catch (error) {
        console.error("Error resetting database:", error);
        process.exit(1);
    }
})();

================
File: seeders/run-org-seed.ts
================
import { MikroORM } from '@mikro-orm/core';
import { OrganizationSeeder } from './OrganizationSeeder';
import config from '../../mikro-orm.config';
(async () => {
    const orm = await MikroORM.init(config);
    const seeder = orm.getSeeder();
    await seeder.seed(OrganizationSeeder);
    await orm.close(true);
    process.exit(0);
})().catch(error => {
    console.error("Error while seeding database:", error);
    process.exit(1);
});

================
File: seeders/run-seeder.ts
================
import { MikroORM } from '@mikro-orm/core';
import { DatabaseSeeder } from './DatabaseSeeder';
import config from '../../mikro-orm.config';
(async () => {
    try {
        const orm = await MikroORM.init(config);
        const generator = orm.getSchemaGenerator();
        const seeder = orm.getSeeder();
        await seeder.seed(DatabaseSeeder);
        await orm.close(true);
        process.exit(0);
    }
    catch (error) {
        console.error("Error running seeder:", error);
        process.exit(1);
    }
})();

================
File: seeders/seed.ts
================
import { EntityManager } from '@mikro-orm/postgresql';
import { SystemUser } from '../entities/system-user.entity';
import { Organization } from '../entities/organization.entity';
import { UserOrganization } from '../entities/user-organization.entity';
import { SystemRole } from '../common/enums/system-role.enum';
import { OrgType } from '../enums/organization.enum';
import * as bcrypt from 'bcrypt';
import { MikroORM } from '@mikro-orm/core';
import config from '../../mikro-orm.config';
import { SystemUserSeeder } from './SystemUserSeeder';
export const seedDatabase = async (em: EntityManager) => {
    try {
        console.log("Starting database seed...");
        // Check if admin user already exists
        const existingAdmin = await em.findOne(SystemUser, {
            email: process.env.INITIAL_ADMIN_EMAIL || "admin@securecenter.com",
        });
        if (existingAdmin) {
            console.log("Admin user already exists, proceeding with additional system users seed...");
        }
        else {
            console.log("Creating admin user...");
            // Create admin user
            const adminUser = new SystemUser();
            adminUser.email = process.env.INITIAL_ADMIN_EMAIL || "admin@securecenter.com";
            adminUser.password = await bcrypt.hash(process.env.INITIAL_ADMIN_PASSWORD || "changeme123!", 10);
            adminUser.firstName = process.env.INITIAL_ADMIN_FIRST_NAME || "Global";
            adminUser.lastName = process.env.INITIAL_ADMIN_LAST_NAME || "Administrator";
            adminUser.role = SystemRole.GLOBAL_ADMIN;
            adminUser.isActive = true;
            await em.persistAndFlush(adminUser);
            console.log("Admin user created successfully");
            // Create initial organization
            console.log("Creating default organization...");
            const organization = new Organization();
            organization.name = "Default Organization";
            organization.description = "Default organization created during initial setup";
            organization.isActive = true;
            organization.isServiceProvider = true;
            organization.type = OrgType.SERVICE_PROVIDER;
            await em.persistAndFlush(organization);
            console.log("Default organization created successfully");
            // Link admin to organization
            console.log("Linking admin to organization...");
            const userOrg = new UserOrganization();
            userOrg.systemUser = adminUser;
            userOrg.organization = organization;
            userOrg.isActive = true;
            await em.persistAndFlush(userOrg);
            console.log("Admin linked to organization successfully");
        }
        // Run the SystemUserSeeder
        console.log("Creating additional system users...");
        const systemUserSeeder = new SystemUserSeeder();
        await systemUserSeeder.run(em);
        console.log("Additional system users created successfully");
        console.log("Database seeded successfully");
    }
    catch (error) {
        console.error("Error seeding database:", error);
        throw error;
    }
};
// Self-executing function to run the seeder
(async () => {
    try {
        console.log("Initializing MikroORM...");
        const orm = await MikroORM.init(config);
        console.log("MikroORM initialized successfully");
        const em = orm.em.fork();
        await seedDatabase(em);
        await orm.close();
        console.log("Database connection closed");
    }
    catch (error) {
        console.error("Failed to seed database:", error);
        process.exit(1);
    }
})();

================
File: seeders/SystemUserSeeder.ts
================
import type { EntityManager } from '@mikro-orm/core';
import { Seeder } from '@mikro-orm/seeder';
import { SystemUser } from '../entities/system-user.entity';
import { SystemRole } from '../common/enums/system-role.enum';
import * as bcrypt from 'bcrypt';
export class SystemUserSeeder extends Seeder {
    async run(em: EntityManager): Promise<void> {
        const basePassword = "systemUser!";
        const saltRounds = 10;
        // Check if any of our seeded users already exist
        const existingUser = await em.findOne(SystemUser, {
            email: "admin@securecenter.com",
        });
        if (existingUser) {
            console.log("Seeded users already exist, skipping system user seed");
            return;
        }
        // Create default admin user
        const defaultAdmin = {
            email: "admin@securecenter.com",
            password: await bcrypt.hash("admin123!", saltRounds),
            firstName: "Admin",
            lastName: "User",
            role: SystemRole.GLOBAL_ADMIN,
            isActive: true,
        };
        // Create additional system users (3 GLOBAL_ADMIN and 3 ADMIN)
        const systemUsers = await Promise.all([
            defaultAdmin,
            {
                email: "globaladmin1@system.com",
                password: await bcrypt.hash(`${basePassword}1`, saltRounds),
                firstName: "Global",
                lastName: "Admin One",
                role: SystemRole.GLOBAL_ADMIN,
                isActive: true,
            },
            {
                email: "globaladmin2@system.com",
                password: await bcrypt.hash(`${basePassword}2`, saltRounds),
                firstName: "Global",
                lastName: "Admin Two",
                role: SystemRole.GLOBAL_ADMIN,
                isActive: true,
            },
            {
                email: "globaladmin3@system.com",
                password: await bcrypt.hash(`${basePassword}3`, saltRounds),
                firstName: "Global",
                lastName: "Admin Three",
                role: SystemRole.GLOBAL_ADMIN,
                isActive: true,
            },
            {
                email: "admin4@system.com",
                password: await bcrypt.hash(`${basePassword}4`, saltRounds),
                firstName: "Admin",
                lastName: "User One",
                role: SystemRole.ADMIN,
                isActive: true,
            },
            {
                email: "admin5@system.com",
                password: await bcrypt.hash(`${basePassword}5`, saltRounds),
                firstName: "Admin",
                lastName: "User Two",
                role: SystemRole.ADMIN,
                isActive: true,
            },
            {
                email: "admin6@system.com",
                password: await bcrypt.hash(`${basePassword}6`, saltRounds),
                firstName: "Admin",
                lastName: "User Three",
                role: SystemRole.ADMIN,
                isActive: true,
            },
        ]);
        for (const userData of systemUsers) {
            const user = em.create(SystemUser, userData);
            await em.persist(user);
        }
        await em.flush();
        console.log("System users seeded successfully");
    }
}

================
File: seeders/UserOrganizationSeeder.ts
================
import type { EntityManager } from '@mikro-orm/core';
import { Seeder } from '@mikro-orm/seeder';
import { SystemUser } from '../entities/system-user.entity';
import { Organization } from '../entities/organization.entity';
import { UserOrganization } from '../entities/user-organization.entity';
import { SystemRole } from '../common/enums/system-role.enum';
import { OrgType } from '../enums/organization.enum';
export class UserOrganizationSeeder extends Seeder {
    async run(em: EntityManager): Promise<void> {
        // Get all system users
        const systemUsers = await em.find(SystemUser, {});
        const organizations = await em.find(Organization, {});
        // Get service provider organization (The White Council)
        const serviceProvider = organizations.find(org => org.isServiceProvider);
        // Get client organizations
        const clientOrgs = organizations.filter(org => !org.isServiceProvider);
        // Get global admins and regular admins
        const globalAdmins = systemUsers.filter(user => user.role === SystemRole.GLOBAL_ADMIN);
        const admins = systemUsers.filter(user => user.role === SystemRole.ADMIN);
        // Create relationships
        const relationships: UserOrganization[] = [];
        // Assign all GLOBAL_ADMINs to all organizations
        for (const globalAdmin of globalAdmins) {
            for (const org of organizations) {
                relationships.push(em.create(UserOrganization, {
                    systemUser: globalAdmin,
                    organization: org,
                    isActive: true
                }));
            }
        }
        // Assign ADMINs to client organizations (distribute evenly)
        admins.forEach((admin, index) => {
            // Each admin gets assigned to some client organizations
            const assignedOrgs = clientOrgs.filter((_, orgIndex) => orgIndex % admins.length === index);
            for (const org of assignedOrgs) {
                relationships.push(em.create(UserOrganization, {
                    systemUser: admin,
                    organization: org,
                    isActive: true
                }));
            }
            // Also assign to service provider if it exists
            if (serviceProvider) {
                relationships.push(em.create(UserOrganization, {
                    systemUser: admin,
                    organization: serviceProvider,
                    isActive: true
                }));
            }
        });
        // Check if any relationships already exist
        const existingCount = await em.count(UserOrganization, {});
        if (existingCount > 0) {
            console.log("User-Organization relationships already exist, skipping seeding");
            return;
        }
        // Persist all relationships
        await em.persistAndFlush(relationships);
        console.log(`Created ${relationships.length} user-organization relationships`);
    }
}

================
File: system-users/dto/create-system-user.dto.ts
================
import { IsEmail, IsString, IsEnum, IsOptional } from 'class-validator';
import { SystemRole } from '../../common/enums/system-role.enum';
export class CreateSystemUserDto {
    @IsEmail()
    email!: string;
    @IsString()
    password!: string;
    @IsString()
    firstName!: string;
    @IsString()
    lastName!: string;
    @IsEnum(SystemRole)
    @IsOptional()
    role?: SystemRole = SystemRole.ADMIN;
}

================
File: system-users/dto/update-system-user.dto.ts
================
import { IsEmail, IsString, IsEnum, IsOptional, IsBoolean } from 'class-validator';
import { SystemRole } from '../../common/enums/system-role.enum';
export class UpdateSystemUserDto {
    @IsEmail()
    @IsOptional()
    email?: string;
    @IsString()
    @IsOptional()
    firstName?: string;
    @IsString()
    @IsOptional()
    lastName?: string;
    @IsEnum(SystemRole)
    @IsOptional()
    role?: SystemRole;
    @IsBoolean()
    @IsOptional()
    isActive?: boolean;
    @IsString()
    @IsOptional()
    password?: string;
}

================
File: system-users/system-users.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete, UseGuards, Request, } from '@nestjs/common';
import { SystemUsersService } from './system-users.service';
import { CreateSystemUserDto } from './dto/create-system-user.dto';
import { UpdateSystemUserDto } from './dto/update-system-user.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { SystemRole } from '../common/enums/system-role.enum';
@Controller("system-users")
@UseGuards(JwtAuthGuard)
export class SystemUsersController {
    constructor(private readonly systemUsersService: SystemUsersService) { }
    @Post()
    @UseGuards(RolesGuard)
    @Roles(SystemRole.GLOBAL_ADMIN)
    async create(
    @Body()
    createSystemUserDto: CreateSystemUserDto) {
        const user = await this.systemUsersService.create(createSystemUserDto);
        return { data: user };
    }
    @Get()
    @UseGuards(RolesGuard)
    @Roles(SystemRole.GLOBAL_ADMIN)
    async findAll() {
        const users = await this.systemUsersService.findAll();
        return { data: users };
    }
    @Get("me")
    async findMe(
    @Request()
    req) {
        const user = await this.systemUsersService.findOne(req.user.id);
        return { data: user };
    }
    @Get(":id")
    @UseGuards(RolesGuard)
    @Roles(SystemRole.GLOBAL_ADMIN)
    async findOne(
    @Param("id")
    id: string) {
        const user = await this.systemUsersService.findOne(id);
        return { data: user };
    }
    @Patch(":id")
    @UseGuards(RolesGuard)
    @Roles(SystemRole.GLOBAL_ADMIN)
    async update(
    @Param("id")
    id: string, 
    @Body()
    updateSystemUserDto: UpdateSystemUserDto) {
        const user = await this.systemUsersService.update(id, updateSystemUserDto);
        return { data: user };
    }
    @Delete(":id")
    @UseGuards(RolesGuard)
    @Roles(SystemRole.GLOBAL_ADMIN)
    async remove(
    @Param("id")
    id: string) {
        const user = await this.systemUsersService.remove(id);
        return { data: user };
    }
}

================
File: system-users/system-users.module.ts
================
import { Module } from '@nestjs/common';
import { SystemUsersService } from './system-users.service';
import { SystemUsersController } from './system-users.controller';
import { MikroOrmModule } from '@mikro-orm/nestjs';
import { SystemUser } from '../entities/system-user.entity';
@Module({
    imports: [
        MikroOrmModule.forFeature([SystemUser])
    ],
    controllers: [SystemUsersController],
    providers: [SystemUsersService],
    exports: [SystemUsersService]
})
export class SystemUsersModule {
}

================
File: system-users/system-users.service.ts
================
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { EntityManager } from '@mikro-orm/postgresql';
import * as bcrypt from 'bcrypt';
import { SystemUser } from '../entities/system-user.entity';
import { CreateSystemUserDto } from './dto/create-system-user.dto';
import { UpdateSystemUserDto } from './dto/update-system-user.dto';
import { SystemUserResponse } from './types/system-user.types';
import { SystemRole } from '../common/enums/system-role.enum';
@Injectable()
export class SystemUsersService {
    constructor(private readonly em: EntityManager) { }
    private mapToResponse(user: SystemUser): SystemUserResponse {
        return {
            id: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            role: user.role,
            isActive: user.isActive,
            lastLogin: user.lastLogin,
            createdAt: user.createdAt,
            updatedAt: user.updatedAt,
            organizations: user.organizations.isInitialized() ? user.organizations.getItems() : [],
        };
    }
    async create(createDto: CreateSystemUserDto): Promise<SystemUserResponse> {
        const existingUser = await this.em.findOne(SystemUser, { email: createDto.email });
        if (existingUser) {
            throw new UnauthorizedException("Email already exists");
        }
        const hashedPassword = await bcrypt.hash(createDto.password, 10);
        const user = new SystemUser();
        user.email = createDto.email;
        user.password = hashedPassword;
        user.firstName = createDto.firstName;
        user.lastName = createDto.lastName;
        user.role = createDto.role || SystemRole.ADMIN;
        user.isActive = true;
        await this.em.persistAndFlush(user);
        return this.mapToResponse(user);
    }
    async findAll(): Promise<SystemUserResponse[]> {
        const users = await this.em.find(SystemUser, {}, {
            populate: ["organizations"]
        });
        return users.map(user => this.mapToResponse(user));
    }
    async findOne(id: string): Promise<SystemUserResponse | null> {
        const user = await this.em.findOne(SystemUser, { id }, {
            populate: ["organizations"]
        });
        return user ? this.mapToResponse(user) : null;
    }
    async findByEmail(email: string): Promise<SystemUser | null> {
        return this.em.findOne(SystemUser, { email }, {
            populate: ["organizations"]
        });
    }
    async update(id: string, updateDto: UpdateSystemUserDto): Promise<SystemUserResponse> {
        const user = await this.em.findOne(SystemUser, { id });
        if (!user) {
            throw new UnauthorizedException("User not found");
        }
        if (updateDto.password) {
            updateDto.password = await bcrypt.hash(updateDto.password, 10);
        }
        this.em.assign(user, updateDto);
        await this.em.persistAndFlush(user);
        return this.mapToResponse(user);
    }
    async remove(id: string): Promise<SystemUserResponse> {
        const user = await this.em.findOne(SystemUser, { id });
        if (!user) {
            throw new UnauthorizedException("User not found");
        }
        await this.em.removeAndFlush(user);
        return this.mapToResponse(user);
    }
    async validateCredentials(email: string, password: string): Promise<SystemUser | null> {
        const user = await this.findByEmail(email);
        if (user && await bcrypt.compare(password, user.password)) {
            return user;
        }
        return null;
    }
    async updateLastLogin(id: string): Promise<void> {
        const user = await this.em.findOne(SystemUser, { id });
        if (user) {
            user.lastLogin = new Date();
            await this.em.persistAndFlush(user);
        }
    }
}

================
File: system-users/types/system-user.types.ts
================
import { SystemRole } from '../../common/enums/system-role.enum';
import { UserOrganization } from '../../entities/user-organization.entity';
export interface SystemUserResponse {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    role: SystemRole;
    isActive: boolean;
    lastLogin?: Date;
    createdAt: Date;
    updatedAt: Date;
    organizations: UserOrganization[];
}
export interface SystemUserLoginResponse {
    access_token: string;
    user: SystemUserResponse;
}

================
File: users/dto/create-user.dto.ts
================
import { SystemRole } from '../../common/enums/system-role.enum';
import { IsEmail, IsString, IsOptional, IsBoolean, IsEnum, } from 'class-validator';
export class CreateUserDto {
    @IsEmail()
    email: string;
    @IsString()
    password: string;
    @IsString()
    name: string;
    @IsOptional()
    @IsEnum(SystemRole)
    systemRole?: SystemRole;
    @IsOptional()
    @IsBoolean()
    isActive?: boolean;
}

================
File: users/dto/update-user.dto.ts
================
import { SystemRole } from '../../common/enums/system-role.enum';
import { IsEmail, IsString, IsOptional, IsBoolean, IsEnum, } from 'class-validator';
export class UpdateUserDto {
    @IsOptional()
    @IsEmail()
    email?: string;
    @IsOptional()
    @IsString()
    firstName?: string;
    @IsOptional()
    @IsString()
    lastName?: string;
    @IsOptional()
    @IsEnum(SystemRole)
    role?: SystemRole;
    @IsOptional()
    @IsBoolean()
    isActive?: boolean;
}

================
File: users/types/user.types.ts
================
import { SystemRole } from '../../common/enums/system-role.enum';
export interface UserResponse {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    role: SystemRole;
    isActive: boolean;
    lastLogin?: Date;
    createdAt: Date;
    updatedAt: Date;
}

================
File: users/users.controller.ts
================
import { Controller, Get, Body, Patch, Param, Delete, UseGuards, } from '@nestjs/common';
import { UsersService } from './users.service';
import { UpdateUserDto } from './dto/update-user.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { SystemRole } from '../common/enums/system-role.enum';
@Controller("system-users")
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles(SystemRole.GLOBAL_ADMIN) // Only GLOBAL_ADMIN can manage system users
export class UsersController {
    constructor(private readonly usersService: UsersService) { }
    @Get()
    async findAll() {
        const users = await this.usersService.findAll();
        return { data: users };
    }
    @Get(":id")
    async findOne(
    @Param("id")
    id: string) {
        const user = await this.usersService.findOne(id);
        return { data: user };
    }
    @Patch(":id")
    async update(
    @Param("id")
    id: string, 
    @Body()
    updateUserDto: UpdateUserDto) {
        const user = await this.usersService.update(id, updateUserDto);
        return { data: user };
    }
    @Delete(":id")
    async remove(
    @Param("id")
    id: string) {
        const user = await this.usersService.remove(id);
        return { data: user };
    }
}

================
File: users/users.module.ts
================
import { Module } from '@nestjs/common';
import { MikroOrmModule } from '@mikro-orm/nestjs';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { SystemUser } from '../entities/system-user.entity';
@Module({
    imports: [
        MikroOrmModule.forFeature([SystemUser])
    ],
    controllers: [UsersController],
    providers: [UsersService],
    exports: [UsersService],
})
export class UsersModule {
}

================
File: users/users.service.ts
================
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { EntityManager } from '@mikro-orm/postgresql';
import { SystemUser } from '../entities/system-user.entity';
import { UpdateUserDto } from './dto/update-user.dto';
import { UserResponse } from './types/user.types';
import { SystemRole } from '../common/enums/system-role.enum';
@Injectable()
export class UsersService {
    constructor(private readonly em: EntityManager) { }
    async findAll(): Promise<UserResponse[]> {
        // Only fetch system users (GLOBAL_ADMIN and ADMIN)
        const users = await this.em.find(SystemUser, {
            role: { $in: [SystemRole.GLOBAL_ADMIN, SystemRole.ADMIN] }
        }, {
            fields: [
                "id",
                "email",
                "firstName",
                "lastName",
                "role",
                "isActive",
                "lastLogin",
                "createdAt",
                "updatedAt"
            ]
        });
        return users.map(user => ({
            id: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            role: user.role,
            isActive: user.isActive,
            lastLogin: user.lastLogin,
            createdAt: user.createdAt,
            updatedAt: user.updatedAt
        }));
    }
    async findOne(id: string): Promise<UserResponse | null> {
        const user = await this.em.findOne(SystemUser, {
            id,
            role: { $in: [SystemRole.GLOBAL_ADMIN, SystemRole.ADMIN] }
        }, {
            fields: [
                "id",
                "email",
                "firstName",
                "lastName",
                "role",
                "isActive",
                "lastLogin",
                "createdAt",
                "updatedAt"
            ]
        });
        if (!user)
            return null;
        return {
            id: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            role: user.role,
            isActive: user.isActive,
            lastLogin: user.lastLogin,
            createdAt: user.createdAt,
            updatedAt: user.updatedAt
        };
    }
    async findByEmail(email: string): Promise<SystemUser | null> {
        return this.em.findOne(SystemUser, {
            email,
            role: { $in: [SystemRole.GLOBAL_ADMIN, SystemRole.ADMIN] }
        });
    }
    async update(id: string, updateUserDto: UpdateUserDto): Promise<UserResponse | null> {
        const user = await this.em.findOne(SystemUser, {
            id,
            role: { $in: [SystemRole.GLOBAL_ADMIN, SystemRole.ADMIN] }
        });
        if (!user) {
            return null;
        }
        // Ensure we can't change a system user to a client user
        if (updateUserDto.role && updateUserDto.role === SystemRole.USER) {
            throw new UnauthorizedException("Cannot change system user to client user");
        }
        this.em.assign(user, updateUserDto);
        await this.em.persistAndFlush(user);
        return {
            id: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            role: user.role,
            isActive: user.isActive,
            lastLogin: user.lastLogin,
            createdAt: user.createdAt,
            updatedAt: user.updatedAt
        };
    }
    async remove(id: string): Promise<UserResponse | null> {
        const user = await this.em.findOne(SystemUser, {
            id,
            role: { $in: [SystemRole.GLOBAL_ADMIN, SystemRole.ADMIN] }
        });
        if (!user) {
            return null;
        }
        await this.em.removeAndFlush(user);
        return {
            id: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            role: user.role,
            isActive: user.isActive,
            lastLogin: user.lastLogin,
            createdAt: user.createdAt,
            updatedAt: user.updatedAt
        };
    }
}
